<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Advanced Data Structures & Algorithms in Java: Working with the Binary Heap Transcript">
<title>Advanced Data Structures & Algorithms in Java: Working with the Binary Heap Transcript</title>
</head>
<body>
<h1>Advanced Data Structures & Algorithms in Java: Working with the Binary Heap</h1>
<p><p>The binary heap, the data structure used to implement a priority queue, is an interesting data structure. Recognizing how best to work with the binary heap is part of creating sturdy and fast software programs.</p>
<p>In this course, you&#39;ll explore the binary heap data structure used to implement a priority queue in a performant and efficient manner. You&#39;ll recognize how the binary heap is essentially a binary tree that satisfies two additional constraints: the heap property and the shape property.</p>
<p>You&#39;ll examine how the binary heap can be represented using an array and how it allows us to implement add, remove, and access operations on a priority queue in an extremely high-performing manner. Finally, you&#39;ll learn how the binary heap helps us implement an efficient sort algorithm: the heap sort.</p></p>
<div>
<h2>Table of Contents</h2>
<ol><li><a href="#493de3a7-a01f-461f-b250-2b406bc02ce8">Course Overview</a></li>
<li><a href="#822f6a19-9ecb-4f28-97f3-929fbb8ff618">The Priority Queue</a></li>
<li><a href="#9ffc3f55-b976-4f86-850e-f5858d0b5cec">The Binary Heap</a></li>
<li><a href="#1ace72b3-3659-4181-bb96-1d88324e82f6">Binary Heap: Implementation</a></li>
<li><a href="#573d55f3-ff34-463a-babf-0d65f7f85605">Binary Heap: Heapify</a></li>
<li><a href="#c0bb5a11-85cf-4499-b82c-0596778e849c">Binary Heap: Insert and Remove</a></li>
<li><a href="#98d12f36-1522-47de-970a-52e219c97ea8">The Heap Base Class</a></li>
<li><a href="#95bf278b-0dca-4804-b986-dc8d20a3e7db">The Maximum Heap</a></li>
<li><a href="#5446a5d8-de87-4b0a-bd13-763f6adaee5e">Operations on a Maximum Heap</a></li>
<li><a href="#7ba79ae6-2dee-4a3c-8108-997a16bb4987">The Minimum Heap and Operations on a Minimum Heap</a></li>
<li><a href="#f6dfeeae-c61c-496b-ae33-0b6c31769199">Heap Sort</a></li>
<li><a href="#757e8850-1b6b-4d3a-be58-80e88c1ef587">Heap Sort: Heapify</a></li>
<li><a href="#de214435-482c-4391-83f5-e71bf5aa6c88">Heap Sort: Sort</a></li>
<li><a href="#040fe514-356d-45bb-826f-a3c93aca8c5b">Implementing Heapify</a></li>
<li><a href="#1c6ebbd8-9bb5-4541-822d-3a344a349257">Implementing Sort</a></li>
<li><a href="#d603605e-0bf4-44a0-a323-ea758d319543">Course Summary</a></li>
</ol></div>
<div>
<h2 id="493de3a7-a01f-461f-b250-2b406bc02ce8">
Course Overview
</h2>
<div>[Video description begins] <em>Topic title: Course Overview</em> [Video description ends]<br /><br />Hi, and welcome to this course, working with the binary heap in Java.<br /><br />[Video description begins] <em>Your host for this session is Janani Ravi. She is a software engineer and big data expert.</em> [Video description ends]<br /><br />My name is Janani Ravi, and I will be your instructor for this course. A little about myself first. I did my master&#39;s from Stanford University, and have worked at various companies, including Google and Microsoft. I presently work for LoonyCorn, a studio for high quality video content. The study of data structures and algorithms involves the study of concepts that are the foundation of writing correct, clean, and robust programs.<br /><br />The knowledge of basic data structures, their characteristics, and the algorithms that go hand in hand with these data structures are important tools in a software engineer&#39;s toolkit. Having the right tools for the job can make the job a lot easier. Being trained in the proper use of the tools is essential to be effective. Data structures and algorithms allow you to write performant code, which minimizes the use of scarce resources and helps ensure that your code is not just correct, but also fast. In this course, we&#39;ll explore a very interesting data structure that is used to implement a priority queue in an efficient manner. This is the binary heap.<br /><br />We&#39;ll see how the binary heap is essentially a binary tree which satisfies two additional constraints, called the heap property and the shape property. We&#39;ll understand how the binary heap can be represented using an array, and how this heap allows us to implement, add, remove and access operations on a priority queue in an extremely performant way. We&#39;ll visualize how binary heaps work and also implement the minimum heap and maximum heap using Java code. And we&#39;ll finally round off this course by using the maximum heap to implement sorting, the heap sort.</div>
</div>
<div>
<h2 id="822f6a19-9ecb-4f28-97f3-929fbb8ff618">
The Priority Queue
</h2>
<div>[Video description begins] <em>Topic title: The Priority Queue. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />In this course, we&#39;ll be learning about a very interesting data structure, the Binary Heap. The binary heap has special significance in the world of computer science. Because the binary heap data structure is what we use to implement priority queues. So before we go in and understand how binary heaps work, let&#39;s talk about priority queues. And what we need to consider while implementing priority queues. What is a priority queue?<br /><br />This is a collection where elements in the collection have weights or priorities assigned to them. A common use case that you might have is to process that element with the highest priority first. If this is a collection of tasks, the highest priority element could be the most urgent task. If this is a collection of people waiting in a call center queue, maybe the highest priority element is the person who has waited the longest.<br /><br />A data structure that you can use to store elements which allows the highest priority element to be accessed and processed first is called a priority queue. The elements are processed in the order of priority. So at every step, we&#39;ll access the element with the highest priority.<br /><br />This means that this data structure needs to understand the underlying priorities of the elements that it holds. The need for the priority queue is pretty obvious and straightforward. Let&#39;s see some of the common operations that we&#39;ll perform using a priority queue. The first is of course, you need to be able to insert elements or entities into this priority queue. The elements should also contain the priority information.<br /><br />Once elements have been added to a priority queue, you need to be able to access these elements. And these elements have to be accessed in their priority order. The highest priority element should be accessed first. And finally, with a priority queue, you should be able to remove the highest priority element.<br /><br />Once you&#39;ve finished processing an element, that element needs to be removed from the queue. Priority queues are extremely widely used in the real world because they have many, many real world applications and practical use cases. Such as an event simulation. You need to be able to process events in the order of priority.<br /><br />Priority queues are useful for thread scheduling as well. When you&#39;re writing your code, it&#39;s possible for you to associate priorities with your threads, such that higher priority threads are not interrupted till they have to be. And finally, priority queues can also be used to handle emergency room cases. The most urgent case will require care first.<br /><br />So the operations that we want performed on a priority queue have to be implemented, such as insert into a queue. We need to specify the priority at the time of insertion. Once we&#39;ve inserted elements, we need to access the highest priority element first. And finally, we need to be able to remove elements from our priority queue. Now imagine that we were to use an unordered array or list to store elements for a priority queue. Insertion into such a list will have time complexity O(1).<br /><br />Since the array or list is unordered, we&#39;ll simply add in an element anywhere in the list along with priority information. With our unordered list implementation of the priority queue, when the time comes to access the highest priority element, we&#39;ll need to perform a linear search of all the elements in our unordered array to get the highest priority element. This has time complexity O(N). Similarly, if we were to remove an element from our unordered array implementation of a priority queue, well, that has time complexity O(N). Because the highest priority element has to be found first.<br /><br />Clearly, an unordered array doesn&#39;t give us great running times for the most common operations in a priority queue. Insertion is fast, but access and removal are both very slow. Let&#39;s try using an ordered array for our priority queue. While you insert a new element into an array, you need to find the right position of that element in that array based on priority. This will be O(N). You&#39;ll actually have to search through all of the elements to find the right position for this new element to be inserted. If you need to access the highest priority element, well, the time complexity there is pretty good. It&#39;s O(1) constant time complexity.<br /><br />Since this is an ordered array, the highest priority element will be easily accessible. We know exactly where that is. And similarly, removing the highest priority element will have constant time complexity as well. If we know where the highest priority element is, it&#39;s easy to remove. Using an ordered array as a priority queue seems to be an improvement over the unordered array. We&#39;ve performed a trade off here. Insertion has become very slow, but access and removal is fast. But the trade off needs to be better.<br /><br />We can&#39;t have inserts being O(N) and that&#39;s why we look to the balanced binary search tree. In a balanced binary search tree, insertion operations have the worst case complexity, O(log N). Finding the right position is a log N operation. Access to the highest priority element is once again O(log N). And removing the highest priority element from a balanced binary search tree is again O(log N). The one thing that should be obvious here is that there is no operation that is really slow and there is no operation that is blazingly fast. We&#39;ve made the right trade off. With the balanced binary search tree, the insertion and access are both moderately fast.<br /><br />Any list-based or array-based solution tend to favor one operation over another. So some operations will be super fast, but other operations will be very slow. The balanced binary search tree seems like a good option. But can we do better? Yes, we can. Instead of using a balanced binary search tree, we can use the binary heap as our priority queue implementation. Let&#39;s see the running times for all of the common operations in our priority queue. Inserting a new element into the priority queue has time complexity O(log N).<br /><br />Accessing the highest priority element is blazingly fast. It has constant time complexity O(1). And finally, removing the highest priority element in the binary heap implementation of a priority queue is O(log N). As you can see, we made access faster without compromising on the time complexity for insertion and remove operations. The binary heap is a clearly better implementation than the balanced binary search tree.</div>
</div>
<div>
<h2 id="9ffc3f55-b976-4f86-850e-f5858d0b5cec">
The Binary Heap
</h2>
<div>[Video description begins] <em>Topic title: The Binary Heap. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />We now know that Binary Heaps are great for implementing the Priority Queue. But what exactly is a Binary Heap? Well, the binary heap is essentially a binary tree with some special properties. The special properties associated with the binary heap add additional constraints to the node values in a binary tree. This constraint is referred to as the heap property. The heap property is what makes a binary heap a heap rather than just a binary tree. This is a special property that serves as a constraint on the binary tree nodes.<br /><br />The fact that a binary tree supports this heap property makes it a binary heap. And the binary heap need not be represented as a tree with nodes left and right children, it can be represented as an array. Which makes the heap data structure very easy and intuitive to work with. The heap property can be expressed in two forms, giving us two types of binary heaps. We have the minimum heap or the min heap. And we have the maximum heap, the max heap. The heap property as it applies to the minimum heap, basically states that every node&#39;s value should be less than or equal to the value of its children.<br /><br />So if a node has children, its value should be less than equal to the value of its children. This makes it such that in a minimum heap, the node with the smallest value will be the root node of the binary tree. All other nodes will be internal nodes or leaf nodes, but we know that the node with the smallest value has to be the root. The heap property that your binary tree needs to satisfy for it to be a maximum heap is a little different. Every node&#39;s value should be greater than or equal to the value of it&#39;s children.<br /><br />Notice that the constraint is exactly opposite that of the minimum heap. This heap property immediately implies that for a maximum heap, the largest element in the heap will be the root node. That&#39;s the only way the constraint that a node&#39;s value should be greater than equal to its children can be satisfied. In addition to the heap property, a binary heap needs to satisfy some other properties as well. If H is the height of the tree, the leaf nodes should only be at level H or level H-1. This essentially means that lower levels need to be filled up first before we move on to filling up higher levels.<br /><br />Second, the heap should form a complete binary tree. All levels except the last level should be completely filled. If the heap is a complete binary tree, leaf nodes will only be at level H or H-1. And this is referred to as the shape property of the binary heap. We&#39;ve already studied complete binary trees earlier in this learning path but here is a quick recap. It&#39;s a special kind of binary tree in which all levels are completely filled, except the lowest level which is filled from the left most node. Here is an example of a complete binary tree. You can see that all levels are completely filled with nodes. Here is another example of a complete binary tree.<br /><br />The lowest level is not filled and the one node that is at the lowest level has been filled in from the left. If you add nodes to this binary tree, moving leftwards along the lowest level, you&#39;ll continue to have complete binary trees. Here is an example of a binary tree that is not complete. That&#39;s because the nodes at the lowest level are not filled in from the left. A binary heap should be a complete binary tree, that is the shape property of a binary heap. Let&#39;s understand the minimum heap in some detail. What we have here on screen is a minimum heap. The smallest value in the entire heap is the root node of this tree.<br /><br />The value 5 here is less than and equal to the value of the child nodes of the node 5. 8 and 6 are the children of 5. This is true recursively for every node in this tree. Notice that the value 8 of the parent node is less than equal to 9 and 10, which are the values of the child nodes. Similarly, the value 6 of the parent node is less than or equal to the values 11 and 7 of the child nodes. And one last example here, the value 9 of the parent node is less than or equal to the values 15 and 10 of the child nodes. <br /><br />This is the heap property as it applies to a minimum heap. Now that we&#39;ve understood the minimum heap, we can move on to understanding the maximum heap. The maximum value in the entire tree for this max heap is the root node. Observe the children of the root node and you&#39;ll see that the heap property holds here. The root node has a value greater than or equal to its direct children. The heap property applies recursively to every node in this binary heap. The node 32 is greater than or equal to the value of its children, 9 and 12.<br /><br />The node 28 is also greater than or equal to the value of its children, 11 and 7. And finally, here at the bottom left, the node 9 has a value greater than or equal to the value of its children, 5 and 3. This is the heap property as it applies to the maximum heap. As we move on to understanding the shape property of a binary heap, let&#39;s talk about only the minimum heap. Whatever we are discussing here applies to the maximum heap as well.<br /><br />Notice the leaf nodes of this binary heap structure. All of the leaf nodes are either at level H or level H-1, where H is the height of this binary tree. These nodes that you see highlighted here cannot have children till all nodes at the previous level have both of their left and right children filled in. Only then can we move on to the next level having child nodes. This means that all nodes at level H-1 have to be filled before moving on to level H, this is the shape property.</div>
</div>
<div>
<h2 id="1ace72b3-3659-4181-bb96-1d88324e82f6">
Binary Heap: Implementation
</h2>
<div>[Video description begins] <em>Topic title: Binary Heap: Implementation. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />We&#39;ve seen that a binary heap is essentially just a binary tree with special constraints. The heap property and the shape property. But the implementation of the binary heap, as a binary tree structure, is rather inefficient. Implementing the binary heap as a binary tree structure makes theoretical sense. So we could do that. We represent a binary tree data structure using nodes. Every node is a container for some data, and it has a left child and a right child, references that point to the left and right children.<br /><br />To start off with, let&#39;s just consider this implementation of binary heap and talk about the most common operations that we want to perform on a heap. In a binary heap, we want to be able to traverse down from the root node to reach all leaf nodes of the heap. In addition to this, we also need to be able to traverse upwards from the leaf nodes towards the root. Now our binary heap implementation becomes a little different.<br /><br />For every node, we need to be able to access the left child for that node, we need to be able to access the right child for that node. This is required for downward traversal from the root to the leaf node. In addition, for upward traversal from the leaf node towards the root, we need to be able to access the parent node from every node as well. Now, representing the binary heap using a binary tree structure looks a little complicated. A node would need, not just two child pointers, but it will also require a parent pointer. This means for every bit of data that we store within our binary heap, we require three bits of additional information.<br /><br />For every element, we have two child nodes and a parent node. This is rather inefficient. It&#39;s much more efficient to represent a binary heap data structure in the form of an array. In the array representation of a binary heap, you have an implicit relationship between the index of the parent node and the indices of the child nodes. And you can use mathematical computations to get these values. The shape property of a binary heap mandates that every level of the binary tree representation of a heap is filled, except perhaps the last level.<br /><br />This means that contiguous slots in an array can be used to represent binary tree levels. If it&#39;s hard for you to imagine how a binary heap can be represented using an array, don&#39;t worry, that&#39;s exactly what we&#39;ll see now. Let&#39;s consider the implicit relationship that exists between the parent node and its child nodes in a binary heap.<br /><br />If a parent node is at index 0, the child nodes will be at index 1 and 2. If the parent node is at index 3, the child nodes for this node will be at index 7 and 8. This allows us to derive a mathematical relationship between the parent node index and the child node indices. If we have a node at index i, the left child will be at index 2 multiplied by i &#43; 1, and the right child will be at index 2 multiplied by i &#43; 2.<br /><br />This mathematical relationship between the parent node and the child nodes is only possible because a binary heap is a complete binary tree. Similarly, it&#39;s possible for us to compute the reverse relationship, given a node, we can get its parent. So if you have a node at index 5, the parent index will be equal to 2. Or if you have a node at index 12, the parent index for that node will be equal to 5. This allows us to express this relationship mathematically. For a node at index i, the parent of that node is at index i - 1, the whole thing divided by 2. Once again, this relationship exists in a binary heap only because the binary heap is a complete binary tree.<br /><br />We had mentioned earlier the common operations that we would like to perform on a binary heap. We&#39;d like to be able to traverse downwards from the root to the leaf nodes and upwards from the leaf nodes up to the root. This requires us to access the left child and the right child and also access the parent of a node. What you see here onscreen is a binary heap. This is a min heap because it has the smallest element as the root of the tree. I&#39;m now going to assign index values to each node within this binary heap, and we&#39;ll see how we can represent this binary heap using an array.<br /><br />Observe that we have assigned index values to the nodes in this binary tree in a breadth-wise manner. Index value 0 goes to the root node, its children have index values 1 and 2, and so on. Now let&#39;s see how the elements in this binary heap map to an array data structure. We&#39;ll be using the index positions that we just set up. Consider the root node in our binary heap, this is the one to which I&#39;ve assigned index 0. I&#39;m going to take this root node and assign it to the zeroth position in our array. Having filled in the root node into our array implementation, let&#39;s consider the first child of the root node.<br /><br />Remember a node at index i has left child at index 2i &#43; 1. 2 multiplied by 0 &#43; 1 is equal to 1, that is the left child of our root node. And I&#39;m going to fill in this left child at index 1 in our array. For a node at index i, its right child is at index 2i &#43; 2. I&#39;m going to take the right child of our root node which is the value 6, and fill that in at index 2 of our array. Observe how the mathematical relationships between the parent index and the child indices have been maintained. Left child at 2i &#43;1, right child at 2i &#43; 2, and we fill in the corresponding values in our array.<br /><br />We can now move on and consider the left child of the root node, that is node 8, and compute the positions of its child node. The left child of node 8 will be at 2 multiplied by 1 &#43; 1, that is equal to 3. We fill in node 9 at index position 3 in our array. The right child of node 8 is at index position 4. This is 2 multiplied by 1 &#43; 2, we fill in node 12 at index position 4 in our array. Now let&#39;s move on to node 6. The left child of this node is at index position 5, 2 multiplied by 2 &#43; 1. We fill in the element 11 at index position 5 in our array.<br /><br />The right child of node 6 is at index position 6, so we fill in the value 7 at index position 6 in our array. We can now move on to consider the left and right children of node 9. Node 9 is at index 3, its left child is at index 7. So we fill in 15 at index 7 in our array. The right child of node 9 is at index position 8. So we fill in the element 10 at index position 8 of our array. At this point, we&#39;ve taken the entire heap data structure and transformed it to an array representation. The implicit relationship that exists between the parent index and the child indices is what made this possible.</div>
</div>
<div>
<h2 id="573d55f3-ff34-463a-babf-0d65f7f85605">
Binary Heap: Heapify
</h2>
<div>[Video description begins] <em>Topic title: Binary Heap: Heapify. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />We know that the basic operations in a binary heap are traversing down the heap towards the leaf nodes and traversing up the heap towards the root node. But these basic operations actually support an operation that converts a binary tree into a heap. This is the heapify operation. The question now arises, why is this heapify operation needed? While inserting an element into a binary heap, how do we know which is the right position for the element to occupy such that the heap property is maintained? Or while removing an element from a binary heap, how do we know the remaining elements still satisfy the heap property?<br /><br />This is why the heapify operation is needed to ensure that the heap property is always satisfied. So essentially, what the heapify operation tries to ensure is that all heap properties are satisfied. So if an element is placed in the wrong position in our binary heap, we&#39;ll try and find the right position for that element. This process of finding the right position within a binary heap for any element in the heap is called heapify. This heapify process will make use of the basic heap operations, get left child, get right child, and get parent. Within this heapify operation, we have two broad operations that are performed.<br /><br />The first of these is the sift down. This is when an element in the heap is in the wrong position with respect to other elements below it in the heap. So this element has to be sifted down so that it occupies the right position. The operation is called sift down because the element has to be moved downwards in the heap towards the leaf nodes. Alternatively, for any element in the heap, you might find that the element is in the wrong position with respect to other elements above it in the heap. So this element has to be moved upwards in your heap till the right position is found. That&#39;s why this operation is called sift up.<br /><br />The element has to be moved upwards in the heap towards the root node of the heap. Both sift up and sift down are part of the heapify process. You can think of these as sub-processes within heapify. Let&#39;s see an example of how sift down and sift up work as a part of the heapification process. Consider that we are working with a minimum heap. In a minimum heap, the heap property basically implies that the smallest node in the binary heap should be the root node. But here you can see that the root node is the element 13.<br /><br />The value 13 is clearly not in the right position with respect to the nodes below it. You can see that the child nodes of 13 are 8 and 6. 13 is not smaller than 8 or 6, it cannot be in this position. Another thing to note here is that it&#39;s only element 13 that is in the wrong place. The remaining elements within this binary heap satisfy the minimum heap property. So we need to find the right position for node 13. 13 has to be moved downwards till the right position for it has been found. This is the sift down process. Let&#39;s see how that works. We start off by comparing the child nodes of the node 13, which is in the wrong position.<br /><br />Now amongst the two children, you can see that the value 6 is less than the value 8. So the right child is smaller than the left child. We&#39;ll perform a swap operation such that the element 13 is swapped with its right child. Even in this position, 13 does not satisfy the minimum heap property. It&#39;s not smaller than its child nodes. Once again, we&#39;ll look at the left child and the right child of node 13 and figure out which one is smaller. Here, the node 7 is clearly smaller than the node 11. This means another swap is required. We&#39;ll perform a swap operation and move 13 down to the position where 7 used to be. 13 is now in the right position.<br /><br />The heapify operation is now complete. The entire binary tree structure now satisfies the heap property. This is once again a minimum heap. Now let&#39;s understand how this sift up process in heapify works. Consider this node at the very bottom here, this is node 4. The value 4 is not in the right position with respect to the nodes above it.<br /><br />The minimum heap property is not satisfied. The parent of node 4 is 9, 9 is clearly smaller than 4. It cannot be its parent. Now in order to get node 4 in the right position, we need to sift up. So we&#39;ll compare node 4 with its parent, 4 is clearly less than 9. We then perform a swap operation, and we swap the positions of node 9 and node 4. 4 is now at a new position, but once again this is not the right position for 4. If you compare 4 with its parent 8, 4 is smaller than 8. This means that 4 needs to be swapped once again with its parent.<br /><br />We&#39;ll perform another swap operation and we&#39;ll swap the position of node 4 with its parent 8. Once again, if you were to compare node 4 with its parent, 4 is still smaller than 6. 4 is not in the right position with respect to its parent. This needs another swap operation. 4 is less than 6, perform another swap, and now 4 is the root node of this binary heap. And this is the correct position for this element. The sift up operation in the heapify process is now complete.</div>
</div>
<div>
<h2 id="c0bb5a11-85cf-4499-b82c-0596778e849c">
Binary Heap: Insert and Remove
</h2>
<div>[Video description begins] <em>Topic title: Binary Heap: Insert and Remove. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />Once you&#39;ve understood the heapify operation and you understand how sift up and sift down work in a heap, you can now implement other heap operations. Such as inserting a new element into a heap and removing the highest priority element from the heap. Remember a heap is after all a priority queue. We&#39;ll first understand how the insert operation works in a heap data structure. Now when you insert a new element into a heap, we won&#39;t try to find the right position of that element immediately as it&#39;s inserted. We&#39;ll simply go ahead and insert this new element as a leaf node in the binary heap.<br /><br />We simply take the new element and add it somewhere near the end of the heap. At this position where you&#39;ve inserted this new element, it&#39;s quite possible that the element is in the wrong position with respect to all nodes above it. You simply shoved an element in there at a leaf node. But we don&#39;t know if it&#39;s in the right position with respect to elements above. For example, if you were representing the heap using the array implementation, which is the most common implementation, the newly inserted element would be at the very end of the array. You&#39;d have the new element be the last element in your array.<br /><br />Now, once it&#39;s in that position, you need to get this element to the right position before the heap property is satisfied for your heap once again. This is a heapify operation. And this heapify operation requires that we sift up the newly inserted element towards the root node to find its right position. Let&#39;s visualize how this works using an actual heap data structure. Here on screen we have a binary heap. This is a min-heap. The smallest node 2 is the root node of this heap structure. We want to insert the element 3 into this heap.<br /><br />We&#39;ll first add 3 to the very end of this heap as a leaf node. If this heap were represented using an array implementation, 3 would be added to the end of the array. The last position in the array is essentially the last leaf node. Here is where 3 is to start off with. Clearly 3 is in the wrong position with respect to nodes above it. In order to get 3 into the right position, we need to sift up the element 3 till its right position has been found. This requires us to perform a swap operation, we&#39;ll swap 3 with its parent.<br /><br />Once again, 3 is in the wrong position with respect to its parent 4. This means we need to perform another swap operation and sift up the node 3. If you now compare the node 3 with its parent, it&#39;s in the correct position. The final position for our newly inserted node has been found. This means each time we perform an insert operation on our heap, we need to implement the heapify process using the sift up operation.<br /><br />After having understood how insert works in a binary heap, let&#39;s move on to understanding how we would implement the remove operation in a binary heap. Now the remove operation is done in a kind of tricky way. We&#39;ll first need to remove the highest priority element in the heap which is essentially the root node. The highest priority element in a minimum heap is the element with the lowest value. The highest priority element in a maximum heap is the element with the highest value.<br /><br />In any binary tree data structure, accessing the root node is always a constant time operation. It&#39;s an O(1) operation. In an array implementation of a binary heap, the highest priority element will always be at index 0. To access the highest priority element in our heap, we simply access the element at index 0 in our array implementation of the heap. Now to remove this element, we have to get rid of this element altogether. And the way we do it is little tricky and interesting. We&#39;ll copy over the last element in our array to index 0.<br /><br />So, in effect, we are swapping the highest priority element out, and swapping in the last element in our heap. Once we&#39;ve done this, we know that the element at index 0 might be in the wrong position with respect to all elements below it. So our root node is in the wrong position with respect to all nodes below it. We know how to deal with this situation. This requires a heapify operation which performs a sift down. We need to move this element downward till the right position for it has been found.<br /><br />The remaining elements still satisfy the heap property. It&#39;s only the root node that is in the wrong position, which is then sifted down to find the right position. It&#39;s always easier to visualize this operation using an example. We have a binary heap here, this is a minimum heap with the smallest value 2 at the root node of this heap data structure. Now we need to remove the highest priority element, that is the node 2.<br /><br />In a minimum heap, the highest priority element is the one with the smallest value. Now in order to remove 2, we&#39;ll simply move the last element in our heap data structure to overwrite the root node. In an array implementation we are not really removing 2, we are overwriting 2 by copying over the last element in the heap to index position 0. 15 is now the new root node of this heap data structure.<br /><br />Now immediately you can see that the heap property has been violated. The node 15 is not in the right position with respect to the remaining elements in the heap. In order to fix this, we need to perform a sift down operation to sift node 15 down to its correct position. This requires comparing the two child nodes of node 15. After looking at the children of node 15, we&#39;ll find the element that is smaller, and perform a swap with the smaller child. So swap 15 with the minimum of its left and right child.<br /><br />In our case, it happens to be the node 4 which has now moved up to be the new root node. Element 15 now has a new position, but it&#39;s pretty clear that our work isn&#39;t done yet. This element is still in the wrong position with respect to nodes below it in the heap. A further sift down operation is required. We find the smaller child, the smaller child is 6, and we perform a swap operation where we swap node 6 with node 15. At this point, we&#39;ve reposition node 15 to be at the right place in this binary heap. We&#39;ve performed a heapify operation using sift down.<br /><br />We can now go back to discussing the time complexities for operations on a binary heap. Remember the binary heap is the preferred implementation for a priority queue. We&#39;ve seen how we can insert a new element into a binary heap. This requires a sift up operation after adding the element as a leaf node. The sift up operation takes O(log N) time, which is why insertion takes O(log N) time. Accessing the highest priority element in a binary heap is a constant time operation O(1).<br /><br />In the array implementation of the heap, we simply access the element at index 0. In a binary tree representation of a heap, we simply access the root node. And finally, if you want to remove the highest priority element in a heap, this requires a sift down operation because we swap the last element of the heap with the root node. The sift down can be performed in O(log N) time, which is why the remove operation takes O(log N).</div>
</div>
<div>
<h2 id="98d12f36-1522-47de-970a-52e219c97ea8">
The Heap Base Class
</h2>
<div>[Video description begins] <em>Topic title: The Heap Base Class. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />In this demo, we&#39;ll see how we can use Java to implement a heap data structure.<br /><br />[Video description begins] <em>The screen displays an Eclipse IDE window. A Main.java tab is open, which shows various lines of code.</em> [Video description ends]<br /><br />As we&#39;ve discussed earlier, the heap is essentially a binary tree which satisfies a few special properties. First, all levels of the heap binary tree are completely filled, except the last one, which is filled from the left. Second, this binary tree satisfies the heap property. The heap property is a little different based on whether we are working with a max heap or a min heap. For a max heap, every node should be larger than either of its child nodes. For a min heap, every node should be smaller than either of its child nodes.<br /><br />Now, I&#39;m going to set up a base heap class, which we&#39;ll then use to implement a max heap as well as a min heap. We&#39;ll create a new file that will hold our heap base class. Right-click on the package, go to new and choose Class and this will bring up a dialog that allows you to specify your class name and other details. I&#39;ll first set up classes for the exceptions that can be thrown by the heap data structure that we&#39;d used. This is the HeapfullException which extends from the base Exception class. This is a check exception, which means it has to be caught or thrown explicitly in code.<br /><br />[Video description begins] <em>She pastes various lines of code. She highlights the following line of code in Line 5: private static final long serialVersionUID &#61; 1L;.</em> [Video description ends]<br /><br />The Exception base class implements the serializable interface, so we need to specify a serialVersionUID. And there is a constructor here which takes in a String message.<br /><br />[Video description begins] <em>She highlights the following lines of code from Line 7 to Line 9: Line 7: public HeapFullException(String message) { Line 8: super(message); Line 9: }.</em> [Video description ends]<br /><br />I&#39;ll now create another class for another exception that can be thrown by our heap data structure, and that is the HeapEmptyException. This will be thrown if you try to access an element from a empty heap. HeapEmptyException also inherits from the Exception base class. That is, it is a checked exception. We need to set up a serialVersionUID and set up a constructor which accepts a String message. With the exception setup, we can now set up the base class for our heap data structure. Right-click, go to new, and choose the Class option.<br /><br />I&#39;m going to call this base class simply Heap since it will serve as the base class for the min heap as well as the max heap. Now I&#39;m going to have this Heap base class be a generic and abstract class. This is an abstract class because there will be methods that remain unimplemented in this base class.<br /><br />These methods implementations will be different based on whether we are choosing to implement a min heap or a max heap. This Heap base class is also a generic class with a bounded type. It can hold any kind of data so long as the type extends comparable, elements of the heap should be comparable in order for us to implement the heap.<br /><br />The next step is to set up the import statements for some of the libraries that we&#39;ll use java.lang.reflect.Array and java.util.Arrays. Next, let&#39;s specify the maximum size that our heap data structure can hold. You&#39;re going to implement the heap using arrays, which means the MAX_SIZE has to be specified up front. I&#39;ve chosen the MAX_SIZE to be equal to 10. I then set up an array which holds objects of type T and I&#39;ll use a variable count to keep track of the number of elements in my heap. Initially count is equal to zero.<br /><br />[Video description begins] <em>She pastes various lines of code. She highlights the following line of code in Line 15: public Heap(Class&lt;T&gt; clazz) {.</em> [Video description ends]<br /><br />The next step is to set up a constructor for this class. This constructor takes as an input argument the class of the generic type, which we&#39;ll then use to instantiate our array. This is how an array of a generic type is instantiated.<br /><br />[Video description begins] <em>She highlights the following line of code in Line 17: array &#61; (T[]) Array.newInstance(clazz, MAX_SIZE);.</em> [Video description ends]<br /><br />We call Array.newInstance, pass the class of the data type in, and specify the size of array and cast the return value to be of type T. This will create a new array of MAX_SIZE which contains objects of type T. Next, we&#39;ll set up a number of utility methods in our heap data structure.<br /><br />The getCount method will return the number of elements in our heap is empty, which will return true if count is equal to zero will tell us if this heap has elements or not. isFull will return true when this heap contains MAX_SIZE elements. If count is equal to array.length, the heap is full. If you want to access an element at a particular index within the underlying array of this heap, you can use getElementAtIndex. This simply returns the object at this index position.<br /><br />[Video description begins] <em>She highlights the following lines of code from Line 32 to Line 34: Line 32: public T getElementAtIndex(int index) { Line 33: return array[index]; Line 34: }.</em> [Video description ends]<br /><br />We&#39;ve seen how we can use the array data structure to store the elements of a heap, whether it&#39;s a max heap or min heap. For every index i, we can calculate the left child of i using a certain mathematical computation. And that&#39;s what this method getLeftChildIndex does. It takes as an input argument, the parentIndex, which is an integer. If parentIndex is less than zero, we return minus one indicating that this is not a valid index, there is no left child. We then compute the left child of this parent while using the formula 2 * parentIndex &#43; 1.<br /><br />This will give us the index value of the left child. If we find that the left child goes beyond the number of elements that we have in our array, that is leftChildIndex greater than equal to count this means that this parentIndex has no left child, we return -1. Otherwise we return the leftChildIndex that we&#39;ve computed.<br /><br />The nodes in our heap can have right children as well. The rightChildIndex can also be computed using a simple mathematical formula. getRightChildIndex takes in the parentIndex as an input argument, if the parentIndex is less than zero, we return minus one indicating no right child. Otherwise, we compute the index of the right child using the formula 2 * parentIndex &#43;2. If we find that the rightChildIndex goes beyond the number of elements that we currently have in our heap, we know that this node at parentIndex has no right child, we return -1. Otherwise we return the rightChildIndex.<br /><br />Just like we can compute childIndex values for heap elements, we can compute parentIndex values as well. That&#39;s what getParentIndex does. It takes as an input argument the childIndex. If this is an invalid index that is less than or equal to 0, or greater than or equal to count, we return -1.<br /><br />If it&#39;s a valid index, we return the parentIndex that is computed using childIndex -1, the whole thing divided by 2. In addition to the public methods exposed by this heap data structure, I&#39;ll add in a protected method as well which will be used by derived classes. This is the swap method, which swaps the elements at two index positions.<br /><br />[Video description begins] <em>She highlights the following lines of code from Line 78 to Line 83: Line 78: protected void swap(int index1, int index2) { Line 80: T tempValue &#61; array [index1]; Line 82: array [index1] &#61; array [index2]; Line 83: array [index2] &#61; tempValue;.</em> [Video description ends]<br /><br />The code within this swap method swaps the element at index1 with the element at index2. This method is protected; it will be used by derived classes. I&#39;ll now add in two more protected methods which are abstract. The implementation for these methods will be provided by the derived class as the implementations will be different based on whether it&#39;s a min heap or a max heap. This is the siftDown method and the siftUp method.<br /><br />[Video description begins] <em>She highlights the following line of code in Line 86: protected abstract void siftDown(int index);.</em> [Video description ends]<br /><br />siftDown will be invoked on an element at a particular index when that element is in the wrong position and has to be moved down to the right position. Similarly siftUp will be called when the element at index is at the wrong position and has to be sifted up the heap to the right position. Let&#39;s continue defining our heap data structures interface in the base class.<br /><br />We&#39;ll have a method called getHighestPriority, that will get us the highest priority element in this heap. For a max heap, the highest priority element will be the largest element and for a min heap, the highest priority element will be the smallest element. Now if we find that our heap is empty, count is equal to 0, we&#39;ll simply throw the new HeapEmptyException.<br /><br />Otherwise, we return the element at index 0 that is always the highest priority element. We return the highest priority element, we don&#39;t remove it from the heap. The heap remains unchanged. The next utility method that we&#39;ll see here in the heap base class is the insert method. This is what we&#39;ll use to insert a new value into the heap. Insert takes as an input argument, the value that we want to insert. And if we find that the heap is full, that is the count of elements is greater than equal to the length of the array, we simply throw the HeapFullException.<br /><br />If the heap still has place for new elements, we add this element to the very end of the array at index count. This is the code on line 103, array[count] &#61; value. We then increment count by 1, we&#39;ve added one additional element after all and we print out to screen the value that we&#39;ve inserted. Now the value that we&#39;ve inserted might be in the wrong position in the heap. We&#39;ve added it to the end of the array that is at the last element of this heap but we now need to find the right position for this newly inserted value.<br /><br />This we do by performing the siftUp operation. We siftUp starting from the index position of the newly inserted value which is now count -1. This is because we incremented count just a moment ago. Another method exposed by this heap class is removeHighestPriority. This is where we actually change the underlying heap and take out the highest priority element. This can throw the HeapEmptyException. We use the helper method that we had written before, and access the highest priority element using getHighestPriority and we store it in the variable first. This is the element at array index zero.<br /><br />Now in order to get rid of this element completely from our underlying array implementation of the heap, we copy over the element which is at the end of the heap at index count -1 to the position 0. This is what the code on line 114 does. We then set the element at index count -1 to be equal to null. Now the last element is now at index position 0, we decrement count by one because we&#39;ve removed one element. But the element at index position zero is in the wrong position with respect to the other elements in our heap.<br /><br />We then invoke siftDown and pass in index 0, to sift down that element to the right position. And finally, the highest priority element stored in the variable first is what we return to the user. And finally, we&#39;ll override the two string method which returns a string representation of the array that we use for the heap data structure.</div>
</div>
<div>
<h2 id="95bf278b-0dca-4804-b986-dc8d20a3e7db">
The Maximum Heap
</h2>
<div>[Video description begins] <em>Topic title: The Maximum Heap. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />We are now ready to implement the max heap. This max heap will derive from the base heap class that we wrote in an earlier demo.<br /><br />[Video description begins] <em>The screen displays the Eclipse IDE window in continuation with the previous video.</em> [Video description ends]<br /><br />Right click on the package, choose New and Class and we&#39;ll name this class MaxHeap because that is the data structure that it represents. This MaxHeap can hold any kind of data. It is a generic class, so long as the data type T extends Comparable. MaxHeap derives from the heap base class. You can see that it extends Heap T. Next, I set up a constructor for this MaxHeap. It takes as an input argument, the class of the data type that it holds, and simply calls the super class constructor.<br /><br />[Video description begins] <em>She pastes various lines of code.</em> [Video description ends]<br /><br />The MaxHeap derived class has to override two abstract methods from the base class. And that&#39;s all that it needs to do in order to have for us a MaxHeap implementation. The first of these methods is the siftDown. The siftDown method starts with the element at the index, which is passed in as an input argument and moves that element down the heap till the right position is found for that element. To help us debug and to see what&#39;s going on with our heap, each time siftDown is invoked, I&#39;m going to print out to screen, Sifting down and the element.<br /><br />We then access the left and the right child indices for this particular element. The base heap class has methods that we can use for this. We invoke getLeftChildIndex and get the left child index and getRightChildIndex will give us the right child&#39;s index. Now, since this is a max heap, in order to sift down the current element to the right position, we need to compare the two children of this element, that is the left child and the right child, and find the element that is larger.<br /><br />I&#39;m going to store the index of the larger element in the largerIndex variable. I&#39;ve defined this variable here on line 18, largerIndex is currently initialized to -1. The first if condition check on line 20 checks to see that the current element has a left child and a right child. If leftIndex is not equal to -1 and the rightIndex is not equal to -1, we can access the leftElement and the rightElement, the two children of the current node.<br /><br />[Video description begins] <em>She highlights the following line of code in Line 25: largerIndex &#61; leftElement.compareTo(rightElement) &gt; 0 ? leftIndex : rightIndex;.</em> [Video description ends]<br /><br />In order to figure out which element is larger, we call leftElement.compareTo(rightElement). This will work because all elements stored in our heap implement the comparable interface. If we find that leftElement.compareTo(rightElement) is greater than 0, we know the left child is larger. We assign the leftIndex to be the largerIndex.<br /><br />Otherwise, we assign the rightIndex to be the largerIndex. If the current node doesn&#39;t have two children, we check to see whether leftIndex is not equal to -1. That is whether it has a left child. If it has only a left child, we set largerIndex to be equal to leftIndex on line 29. And finally in the last else if block, if rightIndex is not equal to -1, that is the current node has just a right child, we set the largerIndex to be the right child&#39;s index.<br /><br />Once the execution of the code comes to line 36, at that point in time, we know which child has the larger element or we know that this particular node has no children at all. If largerIndex is equal to -1, the left and the right child both do not exist. We can stop sifting down, we&#39;ve found the final position of this node.<br /><br />The current position of this element is the final position we simply return. If our execution reaches line 41, we know that this element has at least one child. We print out the larger child using getElementAtIndex and pass in largerIndex. We then compare the larger child with the current element, getElementAtIndex(largerIndex).compareTo(getElementAtIndex(index)). If the larger child is larger than the current element, we perform a swap operation. This swap makes the larger child the parent node and the current element becomes the child node. It replaces the original larger child. We then need to sift down further.<br /><br />We call siftDown on the largerIndex. This recursive call to sift down is needed because at this point, we don&#39;t know whether the current element, which has been moved to the position of the larger child is in the correct position yet. In addition to the siftDown method for which we&#39;ve already seen the code, the second method that needs to be overridden from the base heap class is siftUp. This is where the element at the current index passed into siftUp is in the wrong position and it needs to be moved up the heap data structure to the right position.<br /><br />Before we start the siftUp process, I&#39;m going to print out to screen sifting up and the element that we&#39;re moving upwards. Now for every index, we need to get the parent of that index and we&#39;ll do that using getParentIndex. If we find that the parentIndex is equal to -1, this particular element has no parent and is in the correct position. We stop sifting up, we found the position and we simply return. If parentIndex is not equal to -1, this node has a parent in the heap, we&#39;ll print out the element at the parent using getElementAtIndex.<br /><br />This is on line 69. The next step is to compare the child element that is the current element with the parent element for a max heap. If the child element at the current index is greater than the parent at, this child element needs to move upwards.<br /><br />If getElementAtIndex.compareTo(getElementAt(parentIndex)) is greater than 0, the child element is larger than the parent element, we perform a swap operation. So the parent element is swapped with the child. After the swap, we&#39;ll print out the array representation of the heap and then call siftUp once again, this time by passing in the parentIndex. Because the current element after having moved to the parent may still not be in the right position. So a further siftUp is needed. If the current element is smaller than the parent element, then we won&#39;t enter the if block at all. In that case, we stop sifting up, the final position for this element has been found.</div>
</div>
<div>
<h2 id="5446a5d8-de87-4b0a-bd13-763f6adaee5e">
Operations on a Maximum Heap
</h2>
<div>[Video description begins] <em>Topic title: Operations on a Maximum Heap. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />Now that we&#39;ve implemented the max heap, let&#39;s test out the max heap operation.<br /><br />[Video description begins] <em>The screen displays the Eclipse IDE window in continuation with the previous video.</em> [Video description ends]<br /><br />I&#39;ve headed over to Main.Java, and my Main method throws the HeapFullException as well as the HeapEmptyException.<br /><br />[Video description begins] <em>She pastes various lines of code. She highlights the following line of code in Line 7: MaxHeap&lt;Integer&gt; maxHeap &lt;&gt;(Integer.class);.</em> [Video description ends]<br /><br />The first thing that we&#39;ll do is instantiate a new MaxHeap. This is going to be an integer heap, that is the generic type is integer. It will keep things simple for our compare operations.<br /><br />[Video description begins] <em>She highlights the following line of code in Line 9: maxHeap.insert(9);.</em> [Video description ends]<br /><br />Once the heap has been instantiated, I&#39;m going to invoke the insert method on that heap and insert the first element. This is 9. I&#39;ll then print out the elements contained within my array implementation of the heap using System.out.println. Run this code and let&#39;s take a look at the result. If you remember, from the base class implementation, when we add a new element to the heap, this element is inserted into the last index position and then sifted up to the right position.<br /><br />Since we&#39;ve added just the first element to this heap, we find the right position right away. 9 is inserted at index 0, which is the correct position for this element in this heap. Now, let&#39;s go ahead and insert one more element into this max heap. We&#39;ll insert the element 4. Now let&#39;s take a look at the contents of the array as well, run this code and observe how 4 has been inserted. Element 4 has been added to the very end of the array at index position 1.<br /><br />We then start the process of sifting up 4. The parent of 4 is 9. The heap property has been satisfied here because the parent element is larger than the child element 4. So no further sifting up is needed, 4 is at the right position. Let&#39;s now insert another element 17. This is the largest element and we&#39;ll need sifting up. Go ahead and run this code, and let&#39;s see how we sift up 17 to be in the right position. Initially, 17 is added to the very end of the underlying array.<br /><br />It is at index position 2. 17 is inserted into this position with the line of code array of count equal to value. We then perform a sift up operation starting with this element at index 2. The parent of element 17 is 9. Clearly, the parent should be larger than the child. In a max heap, we perform the swap operation, 17 is swapped with 9, and we try to further sift up 17, we found the final position, we stop. And if you scroll down here in the Console window, you&#39;ll see the final structure of our heap. 17 is at index position 0, that is the root node.<br /><br />The children of 17 are 4 and 9, the heap property is satisfied. Let&#39;s try this once again. Let&#39;s go ahead and insert 6 into our heap. Run this code and let&#39;s see how 6 is inserted. In the Console window, you can see that 6 is initially the last element in our array. We then sift up 6, its parent is 4. We perform a swap operation, the elements 6 and 4 are swapped. We then find a new parent for the element 6, the parent is 17.<br /><br />The heap property satisfied since 17 is greater than 6. We stop sifting up. Let&#39;s try this once again with a large element, I&#39;ll insert 100 into this max heap. When this code is executed, observe that 100 is initially inserted at the last position in the array. 100&#39;s parent is 6, the heap property is not satisfied, so we swap the element 6 with 100. After the swap 100 is now at index 1. Once again, we checked the parent of 100 which is 17. We perform another swap, 100 with 17. And finally 100 is at index 0, we stop sifting up.<br /><br />We are now ready to explore some of the other methods available in the heap data structure. I&#39;m going to set up a max heap by performing a number of insert operations. And I&#39;m going to display a line after all of the insertions are complete. Next, let&#39;s try to access the highest priority element in a max heap. Using maxHeap.getHighestPriority, go ahead and run this code. And after the line, you can see that the highest priority element has been correctly identified as 247, that is the largest element in our heap.<br /><br />The next step is to test the removeHighestPriority method. We&#39;ll print out the maxHeap, this is on line 26, and then call maxHeap.removeHighestPriority. Let&#39;s run this code and we&#39;ll see how after removing the highest priority element, we sift down to re-heapify this heap. Now the highest priority element in our heap is the element 247. That&#39;s what we&#39;re about to remove. The way this element is removed is by swapping 247 with the last element in our heap, which is the element 4. So 4 goes to the head of the heap at index 0, 247 is removed.<br /><br />Once four is at index 0, we need to start sifting down 4. We look at the children of 4, the children of 4 are 144 and 100, the larger child is 144. We swap with 144 and we get the array 144 ,4, 100, and so on. The element 4 needs to be sifted down further, the right place for 4 hasn&#39;t been found. Now 4 has two children, the element 17 and 6 are both children of 4. 17 is at index position 3, 6 at index position 4. The larger child here is 17, we perform a swap operation and sift 4 down further. And now at this point, 4 has no children, we found the final position for 4.</div>
</div>
<div>
<h2 id="7ba79ae6-2dee-4a3c-8108-997a16bb4987">
The Minimum Heap and Operations on a Minimum Heap
</h2>
<div>[Video description begins] <em>Topic title: The Minimum Heap and Operations on a Minimum Heap. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />After having worked with the max heap in previous videos, in this demo, we&#39;ll see how we can work with the min heap. We&#39;ll create a min heap implementation by extending from the base Heap class that we had set up earlier<br /><br />[Video description begins] <em>The screen displays an Eclipse IDE window in continuation with the previous video. A MinHeap.java tab is open.</em> [Video description ends]<br /><br />The MinHeap class is a generic class, it accepts a generic type T that extends Comparable. T extending Comparable is important because in order to enforce the heap property, you need to be able to compare elements in a heap. The MinHeap class also derives from the base Heap class, which contains implementations for most of the common methods that heaps expose. Take a look at the constructor here, it accepts a class T and simply invokes the super class constructor.<br /><br />In the Heap base class, there are two abstract methods that need to be overridden within this MinHeap. These are methods which have different implementations based on whether you want a MinHeap or a MaxHeap. The first of these is the siftDown method. This is the method invoked once we delete the highest priority element in a heap. We place one of the leaf nodes in the heap in the highest priority position and then siftDown.<br /><br />The siftDown method accepts an input argument, the index from where we start sifting down. We&#39;ll put out a print statement to screen, and we&#39;ll calculate the child indices of this current element. The left child index and the right child index using getLeftChildIndex and getRightChildIndex. The heap property for a min heap is that every parent element should be smaller than child elements. We will compare the current parent element with both of its children, find the smaller element, and perform a swap with the smaller element.<br /><br />I&#39;ve initialized smallerIndex to be equal to -1 to start off with, this will hold the index of the smaller child, the child with the lower value. Then we perform an if condition check on line 20. If we find that both left and right children are present, leftIndex is not equal to -1, and rightIndex is not equal to -1. We&#39;ll access both the left and right children, leftElement and rightElement, and find which one is smaller. If leftElement.compareTo(rightElement) is less than 0, we know that the left child is smaller and the leftIndex is what we&#39;ll assign to smallerIndex. Otherwise, we&#39;ll assign rightIndex to smallerIndex.<br /><br />This first if block is what we execute if the current node has two children. Next we&#39;ll go into the first else block if we find that the current node has just the left child. If leftIndex is not equal to -1, then we say the smallerIndex is equal to leftIndex. We&#39;ll enter the second else block where rightIndex is not equal to -1, if the current node has just a right child, smallerIndex then is equal to rightIndex. We&#39;ll continue coding for sift down, if we find, on line 36, that smallerIndex is equal to -1, this means that the current node has no children at all.<br /><br />The current node is in the right position, we don&#39;t need to sift down further, we&#39;ll print out to screen, Stop sifting down, found position, and return. If execution reaches line 42, this means that the current node has some child. And we&#39;ve figured out the smaller child, we&#39;ll simply print out the smaller child to screen. The next step is to determine whether the current element needs to be swapped with one of its child elements.<br /><br />Our if check, here on line 47, is whether the smaller of the two children of the current node has a value lower than that of the current node. If getElementAtIndex(smallerIndex).compareTo(getElementAtIndex(index)) is less than 0. We know that the smaller child has a lower value than the parent. This means we need to perform a swap and further sifting down is necessary.
<p><br />We swap the smallerIndex with index, and then we call siftDown on the smallerIndex, we haven&#39;t yet found the right position for this element. If the smaller child between the two children is not smaller than the parent, then nothing needs to be done. The right index for the current element, the parent has been found, we don&#39;t need to sift down further. Well, this is all for siftDown, let&#39;s now see the code for the siftUp operation. Once again, we need to override this method from the Heap base class. The siftUp method is invoked when we insert a new element into the heap. The new element is always entered as a leaf node, the last element in the underlying array. It is then sifted up so that it&#39;s in the right position.<br /><br />And this is the code that&#39;ll do that for the min heap. Remember in a min heap, parent elements should be always smaller than child elements. We sift up starting at the current index which is passed in as an input argument. We then calculate the parentIndex of the current node using getParentIndex. If parentIndex is -1, then this child has no parent, it&#39;s in the right position on the heap. We simply stop sifting up since the position has been found and return, we&#39;ll then print out the value of the parent. If we find that the current element is smaller than the parent element, then further sifting up is needed.</p>
<p>That is what the if condition check on line 72 does. If the current element has a lower value than its parent, that&#39;s when we perform the swap. We swap the current element with the parent and then call siftUp on the parent. Further sifting up might be needed because we have no idea whether the element is now finally in the right position.</p>
<p>We&#39;ll only know after we go back to sift up and perform additional checks. Back in our Main.java file, we&#39;re ready to start testing out our heap code. We instantiate a new minimum heap of integers, and insert 9 into this min heap. Run this code, and let&#39;s see the results. For any newly inserted node, the element is always added to the end of the array representing the heap, that&#39;s what we do with 9. The end of the array here is the first element.<br /><br />We then try sifting up 9 to the right position. But this is the right position for 9 in a single element heap, we stop sifting up since the position has been found. Let&#39;s now try inserting the element 4 into this min heap. Now 4 is smaller than 9, which means 4 will have to be the parent node, and 9 will have to be the child node. Go ahead and run this code, and let&#39;s look at the result. Initially, 4 is inserted at the end of the array representing the heap at index 1. We then start sifting up 4, 4&#39;s parent is 9.<br /><br />Well, 4 is smaller than 9 so we perform a swap operation. Notice that after the swap, 4 is at index 0, 9 is at index 1. We try sifting up 4 further, but no further sifting up is needed, the final positions have been found. We are now ready to explore some of the other operations in the min heap. These operations function in a very similar manner to that of the max heap, except that the heap property is different. I&#39;ve constructed a heap here by performing a number of insert statements. I&#39;ve also printed out to the Console, a line indicating all the insertions are complete.<br /><br />After performing the insertions into this heap, I&#39;m going to invoke minHeap.getHighestPriority. This will give me the highest priority element at index 0 in the underlying array. Run this code and you can see that the highest priority element in this heap is 3. If you look at all of the elements that I&#39;ve inserted here in this heap, it&#39;s pretty obvious that 3 is the smallest element, the highest priority element. Accessing the highest priority element does not change the heap data structure. Let&#39;s now try removing the highest priority element, this requires a re-heapification of our heap so that all elements satisfy the heap property.<br /><br />Run this code and let&#39;s see what happens. If you look at the original heap data structure, you can see that 3 is at index 0, and 23 is the last element in the array. Then when we remove 3, that is remove the highest priority element, we copy over 23 into index 0. That operation is not explicitly seen here within your Console window, we then start sifting down 23. 23 has two children, 6 and 4, the smaller child is 4. We perform a swap operation where we swap 4 with 23, 4 is now at index 0, the highest priority element.<br /><br />We need to further sift down the element 23 so it&#39;s in the right position. You can see the message in the Console window which says Sifting down: 23, once again. Now we see the children of 23, the elements 17 and 13 are both children of 23 as you can see from the first line in the Console output. The smaller child is 13, we perform a swap operation and swap 23 with 13. After the swap, you can see that 13 is at index position 2, and 23 is the last element in the list. At this point we stop sifting down, the final position for 23 has been found.</p></div>
</div>
<div>
<h2 id="f6dfeeae-c61c-496b-ae33-0b6c31769199">
Heap Sort
</h2>
<div>[Video description begins] <em>Topic title: Heap Sort. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />Once we&#39;ve understood how binary heaps work, there&#39;s yet another sorting algorithm that is available for us to implement and understand, and this is heap sort. Heap sort makes use of the heap in order to perform the sorting operation. So we&#39;ll use a heap data structure, either a min heap or a max heap, to help sort elements in either ascending or descending order. Heap sort requires two distinct phases before we can completely sought an unsorted list.<br /><br />We&#39;ll first convert the unsorted list or array into a heap. This can be done in place without taking up additional space. Assume that we&#39;ve use the heapify process to convert our unsorted list into a maximum heap. Once the maximum heap has been set up, we can access the highest priority element that is the largest element in our heap in constant time.<br /><br />So we&#39;ll use the heap to access this largest element. And we&#39;ll place this maximum or largest element in the right position in the array at the very end of the array. We&#39;ll then shrink the size of our heap by 1. The largest element is no longer part of the heap. We&#39;ll then perform a reheapify operation to make sure that the remaining elements satisfy the heap property. So heap sort is performed using two distinct phases. We&#39;ll convert the unsorted list to a heap, we&#39;ll then use the heap to sort the elements. <br /><br />The heap is an integral portion of the heap sort operation. The first process is referred to as heapify. This is where we convert the unsorted list or array into a heap data structure. And we do this in place. This heap structure is built up from the unsorted array. We&#39;ll take a small portion of the array and make sure all elements in that portion satisfy the heap property. We&#39;ll then continuously add elements into the heap portion ensuring that the heap property continues to be satisfied. In this manner, we slowly and steadily grow the number of elements that exist within the heap. At some point, the heap will grow to encompass all elements in the array.<br /><br />This completes the first phase in heap sort, where we performed heapify operation to convert an unsorted list to a heap. We can then move on to the next distinct phase in heap sort, and that is the actual sorting operation. We&#39;ll use the heap that we&#39;ve constructed to access the largest element. And we&#39;ll take this largest element and put it in the right position in the array that we have. We know that the largest element always belongs at the very end of the array. Accessing the largest element, which will be the highest priority element is very straightforward and very fast in a binary heap.
<p><br />This is an action that can be performed in constant time. We&#39;ll then remove this largest element so that it&#39;s no longer part of the heap. It&#39;s now part of our sorted list. And once we remove the largest element, we need to recreate the heap in this iteration. And this we&#39;ll do for each iteration. Each time we remove the largest element, we&#39;ll perform a reheapfication to get the max heap back. In this way, step by step, our sorted array will grow to encompass all elements in the array. In order to cement our understanding of heap sort, we&#39;ll visualize how it works.<br /><br />We&#39;ll use a maximum heap so we can always access the largest element in constant time O(1) time. We know that a heap can be represented using an array, which is what we&#39;ll use. We&#39;ll use the same array with no additional space to perform heap sort. Thus, our heap sort will be an in-place sorting algorithm, no extra space use. The first phase will be to convert our unsorted array to a heap, that is a maximum heap.</p></div>
</div>
<div>
<h2 id="757e8850-1b6b-4d3a-be58-80e88c1ef587">
Heap Sort: Heapify
</h2>
<div>[Video description begins] <em>Topic title: Heap Sort: Heapify. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />We are now ready to visualize how heap sort works. And we&#39;ll start off with the first phase in heap sort, which is the heapify operation, converting an unsorted list to a heap data structure. Our first objective in heap sort is to heapify the entire array. This requires us to start with the parent index of the last element in the array and move backwards. And ensure that all elements as we move backwards through the array, that is move upwards, towards the root node in our heap satisfy the heap property. In order to get the elements in our array to satisfy the heap property, we need to percolate the elements down the heap to the right location.
<p>So, percolating the elements down is essentially the sift down operation. Let&#39;s see how this works with an unsorted array. This is the array or the list of elements that we want sorted in the ascending order. We start with the last elements in this array.<br /><br />These are the elements at index 9 and index 10. We try to find the parent of the last elements in this unsorted array. We know the mathematical relationship that connects a child node with its parent node. For a node at index i, it has a parent at index i- 1, the whole thing divided by 2. So for element 14 here, which is at index position 10, the parent element is the node at index 4, that is 10. You can see that the parent node and the child node 14 do not satisfy the maximum heap property. 10 is smaller than 14. This means that we need to perform a swap operation and we&#39;ll swap 10 with 14. Now, 14 is the parent element.<br /><br />We&#39;ll then compare the next element at index 9. 17 and 14, again, do not satisfy the max heap property. The parent element 14 is smaller than 17. Then we will perform a swap operation and this will make 17 the parent of both nodes 14 and 10. The nodes 14 and 10 are in the right position with respect to their parent. There are no more child nodes to consider, that is the nodes 14 and 10 don&#39;t have any child nodes that are part of the heap. We&#39;ll now move to the previous parent at index 3. The parent at index 3 has children which are at index 7 and 8.<br /><br />Let&#39;s compare 2 with its right child that is node 1, the max heap property is satisfied here. We move on to comparing 2 with the left child at index 7. The max heap property is not satisfied, we perform a swap operation. With this swap operation the parent at index 3 is in the right position with respect to its child nodes.<br /><br />So 2 and 1 satisfy the heap property as far as the parent is concerned. The nodes 2 and 1 don&#39;t have any children that are part of the heap. So we now move to the previous parent at index 2. At index 2 we have the node 9, and the children of 9 are at index 5 and 6. We compare the node 9 with its right child, the max heap property is not satisfied. This requires a swap operation. So now 12 becomes the parent of 9.<br /><br />We then compare the node 12 with the left child. Once again the max heap property is not satisfied. This requires another swap operation. The parent node 56 is now in the right relative position with respect to its child nodes, 12 and 9. 12 and 9 have no children in this heap, no further percolate down operations are required. We move to the previous parent at index 2. The node at index 2 is 6 and it has 5 and 17 as its children.<br /><br />We compare the node 6 with its right child 17. The heap property is not satisfied, so we perform a swap operation. We then move on to comparing node 17 with its left child 5. The max heap property is satisfied here, so we leave things as is. Now, it so happens that these elements 5 and 6 have children in this max heap implementation. So let&#39;s consider the children of node 5 first. Using the mathematical relationship between the parent node and the child nodes, we know that the left child of node 5 is node 2 and the right child is node 1. 5 is greater than both 2 and 1, the max heap property is satisfied. So we can move on to node 6.<br /><br />The left child of node 6 is node 14 and its right child is node 10. The max heap property is clearly not satisfied, 6 is smaller than 14. This requires a swap operation and we move 14 to be the parent node. We now compare 14 with node 10. This satisfies the max heap property, no further swaps are required. Nodes 6 and 10 have no children, they are leaf nodes. So we move back to index 0. We&#39;ve already processed index 1, this is the previous parent index. The right child of node 4 is the node 56. The heap property is not satisfied, 4 is smaller than 56.<br /><br />We perform a swap operation. So 56 becomes the parent. We then compare the node 56 with its left child, 17. The heap property is satisfied here, nothing more to be done. The nodes 17 and 4 though have children in this binary heap and we need to check that the heap property is satisfied for both of these. Let&#39;s start with node 17 and compare with its child nodes. The left child of node 17 is the node 5, the max heap property is satisfied here.<br /><br />The right child is a node 14, the max heap property is once again satisfied, 17 is larger than both 5 and 14. Because the max heap property was already satisfied, we don&#39;t need to check the child nodes of node 5 and node 14. We can move on to the right child of the root node, that is node 4. We&#39;ll compare the node 4 with its left child that is 12. Now, the max heap property is not satisfied, 4 is smaller than 12. We perform a swap operation, 12 becomes the parent node. Let&#39;s compare 12 with its right child that is 9.<br /><br />The max heap property is satisfied here, nothing to be done. Nodes 4 and 9 have no children in this binary heap, there are no further children to consider. We moved from the last element of this array, that is the leaf node in our heap, all the way through to index 0. This is now a max heap. Every node satisfies the max heap property. In order to satisfy ourselves that this is indeed a max heap, I&#39;m going to place the elements of our array implementation of the heap into a binary tree representation for verification. 56 is the parent node, 17 and 12 are the child nodes, the max heap property is satisfied. Next, with 17 as the parent node, the child nodes are 5 and 14.<br /><br />Once again, the max heap property is satisfied. We&#39;ll move on, with 12 as the parent node, the child nodes are 4 and 9. Once again the max heap property is satisfied. With 5 as the parent node, the child nodes are 2 and 1, 5 is greater than both of these elements. Moving on with 14 as the parent node, child nodes are 6 and 10. Once again, the parent is larger than its children. At this point, we&#39;ve successfully performed the heapification process to get a max heap, and this was entirely done in place. We&#39;ve completed the first phase in our heap sort, heapify.</p></div>
</div>
<div>
<h2 id="de214435-482c-4391-83f5-e71bf5aa6c88">
Heap Sort: Sort
</h2>
<div>[Video description begins] <em>Topic title: Heap Sort: Sort. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />The heapify operation that we just performed has converted our unsorted array to a maximum heap. We are now ready to perform the second phase in heap sort, the actual sort using the heap that we just built up. We constructed the heap and we verified that this is indeed a Max Heap. Let&#39;s move on with the Sort process working with this Max Heap data structure. We&#39;ll access the highest priority element in our Max Heap which is at index 0 and move it to the correct position in the sorted array. <br /><br />This requires us to perform a swap operation where we swap the maximum element with the element at the last position in the array. Now at this point, element 56 makes up our sorted array. It is in the right position in our final sort. At this point we leave the last element out of the Heap Data Structure that we&#39;re working with. The last element is no longer part of the heap. It&#39;s now part of the sorted array. Going back to our Heap Data Structure, the element at the root of the heap 10 is not in it&#39;s right position. It does not satisfy the heap property. We need to percolate down this element 10 to the right position in the heap.<br /><br />Let&#39;s compare the element 10 with both of its children. We&#39;ll find the larger of the two child elements, which is element 17 and then swap 10 with 17. We still don&#39;t know whether the element 10 isn&#39;t the right position with respect to its child nodes. Let&#39;s compare the element 10 with its children. Its children are 5 and 14. The heap property is not satisfied. The right child of element 10 is the element 14. So we&#39;ll perform a swap operation to swap the element 10 with its larger child, 14 is now the parent.<br /><br />Once again, let&#39;s take a look at element 10. And compare the element with its child nodes. The left child of node 10 is the element 6. The heap property is clearly satisfied here. The right child of node 10 would have been element 56. But remember the element 56 is no longer part of the heap. We&#39;ll simply pretend like 56 does not exist. Our heap is now recreated. So let&#39;s look at the highest priority element in this heap. That is the element 17.<br /><br />We now need to move 17 to the very end of our array to be part of the sorted list. This requires a swap operation with the element 6. We now have two elements that are in their final position, the last two elements. These elements no longer belong to the heap. They&#39;re instead part of the sorted list. But going back to our heap, which is now a little smaller element 6 is no longer in the right position. Let&#39;s compare the element 6 with its children. The larger child for element 6 is the element 14. We&#39;ll perform a swap operation. 14 is now the parent node.<br /><br />We&#39;ll look at the children of the elements 6 to see whether the heap property is satisfied here. It clearly is not. The right child of 6 is 10, which is larger than 6. We&#39;ll perform a swap operation and make 10 the parent. We&#39;ll now compare the element 6 with its children. But notice that both children of the element 6 are no longer part of our heap. They are part of the sorted array. So we are done here. 6 is in the right position in our binary heap. Which means we can go back to the process of accessing the largest element in our binary heap and moving it to its correct position in the sorted list. <br /><br />This requires us to swap the element 14 with the element 1. 14 is now part of our sorted list. It&#39;s no longer part of the heap. But if you look at element 1, it&#39;s not in the right position for our heap. Let&#39;s compare element 1 with its children. Its children are larger. Let&#39;s take the larger child 12 and perform a swap operation. Element 1 is still not in the right position in the heap. Let&#39;s compare element 1 with both of its children. Its children are 4 and 9. Let&#39;s take the larger child 9 and perform a swap operation.<br /><br />Element 1 is now in the right position. There are no children to process further. So let&#39;s go back to the largest element which is 12. We now need to move element 2 to the right position in the sorted list. We&#39;ll perform a swap operation where we swap 12 and 2. 12 is no longer part of our binary heap. It is now part of our sorted list. Let&#39;s compare the element 2 with its children to find the right position for 2. Its child 10 is clearly the larger child. We need to perform a swap operation to percolate down 2. We&#39;ll now compare the element 2 with its children to see whether the heap property has been satisfied. <br /><br />Now, 5 and 6 are both larger than 2. Let&#39;s take the larger child 6 and perform a swap operation. At this point element 2 is in the correct final position. The children of element 2 are no longer part of the heap. So there are no children to process. Back to the largest element in the heap. We need to move this into our sorted list. This requires a swap operation with element 1. Perform the swap operation. Now element 10 becomes part of the sorted list. It&#39;s no longer part of the heap. Element 1 is not in the right position in the heap. We need to percolate this element down. Compare with its children take the larger child 9 and perform a swap operation. We&#39;ll process element 1.<br /><br />Further compare element 1 with its children. There&#39;s just one child within the heap that is 4. We&#39;ll percolate element 1 down, by performing a swap. Element 1 is now in the right position. Our heap has been recreated. Back to the largest element in this heap, which is now 9. Let&#39;s move 9 into the right position within the sorted array. Which involves performing a swap operation with the element 1. 9 is now no longer part of this heap. It&#39;s now part of the sorted array.<br /><br />We have to deal with element 1 and compare it with its children to make sure that the heap property is satisfied. We&#39;ll perform a swap operation with the larger child of element 1, 6 is now the parent. Once again, we&#39;ll compare the node 1 with its children, 5 is the larger child.<br /><br />This requires another swap operation, 5 now becomes a parent. Node 1 is in the right position in our heap. There are no further children for node 1 to process. Back to the largest element in our heap, which is the element 6. We&#39;ll now perform a swap operation with element 2 which is at the end of our heap. Once the swap is performed, 6 is no longer part of the heap. It now becomes a part of our sorted list. We&#39;ll now percolate down the element 2 to the right position. 5 is the larger child of 2. We&#39;ll perform a swap operation to get 5 as the root node, the parent node. Let&#39;s compare 2 with its children.<br /><br />There&#39;s just one child 1, the heap property is satisfied here. Let&#39;s go back to the largest element in our heap now which is 5. We&#39;ll perform a swap operation with the element 1 to make 5 part of the sorted array. After the swap, 5 is part of the sorted list. It&#39;s no longer part of the heap. Let&#39;s compare the element 1 with its children.<br /><br />The larger child is the element 4. This requires a swap operation. So that 4 becomes the parent. There&#39;s nothing more to do here. 4 is now the largest element in our heap. 4 needs to be part of the sorted list. And this we&#39;ll accomplish by swapping the element 4 with the element 1. After the swap, 4 becomes part of the sorted list. It&#39;s no longer part of our heap. The element 1 needs to be moved down to the right position in the heap. We&#39;ll look at the child 2, perform a swap operation.<br /><br />2 is now at the head of this heap. 2 is the largest element. Now, we&#39;ll move this largest element of our heap to its final position by swapping it with the element 1. Once the swap operation is performed, 2 becomes part of the sorted list. The only element that is left in our heap is 1. We can automatically make 1 part of our sorted list. And we have a fully sorted list. After we&#39;ve completed the sort phase in heap sort.<br /><br />We&#39;re done with both heapify and sort. The running time for this algorithm is order of N log N. So heap sort performs as well as quicksort and merge sort that we&#39;ve seen before. The one advantage that heap sort has over other sorting algorithms for the same time complexity is that this is true for the best case, worst case, as well as the average case. Which means even in the absolute worst case, heap sort works out to be faster than quicksort.<br /><br />Heap sort is not an adaptive sort. So, somewhere midway between heapify and the sorting process if we find that the list is completely sorted, it won&#39;t be able to stop early. Heap sort is also not a stable sort. If we have equal elements in our unsorted list, they won&#39;t maintain their original order after sorting. And finally, heap sort performs sorting in-place, additional space is not required. So space complexity is O(1) constant time complexity.</div>
</div>
<div>
<h2 id="040fe514-356d-45bb-826f-a3c93aca8c5b">
Implementing Heapify
</h2>
<div>[Video description begins] <em>Topic title: Implementing Heapify. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />Now that we have a good understanding of how binary heaps work, we can take a look at one last sorting algorithm. This is the heap sort, which uses a heap data structure in order to perform sorting. <br /><br />[Video description begins] <em>The screen displays an Eclipse IDE window. A Main.java tab is open.</em> [Video description ends]<br /><br />Here I am in Main.java and here is where I&#39;ll write all of the helper methods, utilities and operations that we&#39;ll perform while performing heap sort. Set up the import statements here, we&#39;ll use java.util.Arrays. We won&#39;t use the heap data structure that we had set up earlier here, because that&#39;s kind of heavyweight and we don&#39;t really need all of those operations. Any methods that we&#39;ll use from the heap data structure, I&#39;ll just write the code for it here in Main.java.<br /><br />In this demo, we&#39;ll perform the heap sort operation using a maximum heap. This is where the largest element in the heap is present at the root node. The array implementation of the heap, this is at index zero. When we use a maximum heap, at every step in the heap sort process, we will remove the highest priority that is the largest element from the heap and we&#39;ll place that largest element at the end of the array in the right sorted position.<br /><br />We will then remove that element. It&#39;s no longer part of the heap, and we&#39;ll heapify the rest of the array. This is the process we follow over and over again till the entire array is sorted. The first helper method that I&#39;m going to write code for here is to get the parent index for a particular element. The index of the element is what we pass in at the input. Observe we have a second input argument as well, the endIndex.<br /><br />The endIndex is there to specify the index of the last element within this heap. Remember as the heap sort operation progresses, we&#39;ll remove elements from the end of the array data structure that holds our heap implementation, because they become part of the sorted array that is our end result which is why we need this endIndex here. The index of the current element in the index variable, if we find that it&#39;s less than 0, or it&#39;s greater than endIndex, we return -1. This element has no parent. Otherwise, we return index -1, the whole thing divided by 2.<br /><br />This is the mathematical computation to get the parent element. I&#39;ll set up another helper method here, the getLeftChildIndex which will compute the index position of the left child for any element. The current element index is in the index variable and we also pass in the endIndex, which will tell us what the last element of the heap is. We then compute the leftChildIndex using 2 multiplied by index plus 1. If the leftChildIndex goes beyond the number of elements in the heap, that is it&#39;s greater than endIndex, we return -1, the element has no left child, otherwise we return the leftChildIndex.<br /><br />The next helper method is, you guessed it, getRightChildIndex. It takes the index of the current element as an input argument as well as the endIndex the last element within the array. We compute the right child by calculating 2 multiplied by index plus 2. If we find that the rightChildIndex is beyond the last element in this heap, we return -1.<br /><br />Otherwise, we return the rightChildIndex. Another helper method that we need for the heap sort is a utility to perform the swap operation. Swap takes as an input argument the array that represents our heap and two index values index1 and index2 and it swaps the element present at index1 with the element present at index2.<br /><br />The next utility method which we&#39;ll write code for is percolateDown. Now percolateDown is the equivalent of the siftDown operation that we worked with earlier in both the max heap as well as the min heap. percolateDown takes an element at a current position and moves the element down the heap structure till the right position for that element has been found. Now percolateDown takes in three input arguments here. The first is the array representation of the heap int array. The second is the index of the current element index.<br /><br />And finally, the third input argument gives us the endIndex the index of the last element which is part of the heap. We then access the index positions of the children of the current node leftChildIndex and rightChildIndex. This percolateDown method is invoked in the first phase of the heap sort when we perform the heapify operation on the original array. Because we know that we are working with a max heap, this percolateDown operation is the same code as the code for sift down in a max heap. We have a larger index variable that I have initialized to minus 1, this will hold the index value of the child, which has the larger element.<br /><br />Our first if check on line 56 is to see whether the current element has two children. If leftChildIndex is not equal to -1 and rightChildIndex is not equal to -1, we know the current element has two children. We need to find the larger child. We compare the element on the leftChildIndex with the element on the rightChildIndex and see whether it&#39;s greater. If it&#39;s greater, the larger index is the leftChildIndex, if not, the larger index is the rightChildIndex. If we enter the else block starting at line 60, that means the current element does not have two children.<br /><br />We&#39;ll check to see whether it has a left child. If leftChildIndex is not equal to -1, the larger index is the leftChildIndex. On line 63, the check is for whether the current element has a right child. If rightChildIndex is not equal to -1, larger index is equal to rightChildIndex. On line 75, we&#39;ll print out the larger child of the current element and we&#39;ll check whether this larger child has a value greater than the value of the current element. In that case, the current element needs to be percolated down. We perform a swap operation, where we swap the current element with its larger child and we call percolateDown on the larger child to further move the element down to the right position, if needed. <br /><br />With all of the helper methods set up, we are now ready to write code for the heapify operation in heap sort. This is what converts an ordinary array into a heap and we then use this heap to sort the elements in the array. The heapify operation takes as an input argument the array, which we&#39;re going to convert to a heap and the endIndex.<br /><br />The endIndex, remember, tells us how many of the elements in the array belong to the heap, the remaining elements are part of the sorted result. We start this heapify process with the last element in the heap which is present at endIndex. We invoke getParentIndex to get the parent of the last element in the heap and the parent index will be stored in the index variable.<br /><br />We&#39;ll print out the element which is the child as well as the parent. So long as the parent index is greater than or equal to zero that is, it is a valid parent, that is the element that we are currently processing. We will percolate down that element to the right position in the heap by invoking percolateDown, this we do on line 97. Once the last element has been moved to the right position in the heap, we decrement index by 1 using index--, we go to the second to last element and percolate down that element to the right position in the heap. And we continue this till the entire array has been heapified.<br /><br />Before we move on to using this heapify operation within heap sort, Let&#39;s see how heapify works standalone. I&#39;ve instantiated an array here, which contains elements in any random order. This is the array that we&#39;ll finally sort but first we need to convert this array to a heap format. This we do by invoking heapify on this array, we&#39;ll first convert it to a max heap and the end index when we start the heapify process, is array.length - 1. Let&#39;s run this code, and the print statements that we&#39;ve put in will give us insight into how this heapify process works. Here&#39;s the original array at the very top of the Console window.<br /><br />We start off with the last element in the array, that is the element 14, and we compute the parent of this element. The parent is the element at index 4, the element is 10. Now what we&#39;re trying to see is whether the heap property is satisfied for the parent and the two children of this parent. So the parent is the element 10, the two children of this parent are the elements 17 and 14. This means that we need to percolate down 10 in this max heap.<br /><br />The larger child of this parent is the element 17. We perform a swap operation and notice now 17 after the swap, is at index position four and 10 is the second to last element in the list, and 14 is the last element in the list. At this point, the last two elements in the array are in the right position with respect to its parent. If you see the list at the very top of the Console window you have 17 and its two children are 10 and 14.<br /><br />The next element to be processed will be 1 which is at the very end of the list, the third last element. One&#39;s parent is at element 2, which is at index position 3. We need to percolate down 2 because 2 is smaller than its larger child that is the element 5. This process continues till the entire list has been converted to a max heap.<br /><br />And if you see, the final structure of this array is that of a max heap. You can see that 56 is at index zero that is the largest element in our heap. Its children are 17 and 12. The node 17 has children 5 and 14, 12 has children 9 and 4. The heap property that is the max heap property has been satisfied for this array. It&#39;s now essentially a max heap.</div>
</div>
<div>
<h2 id="1c6ebbd8-9bb5-4541-822d-3a344a349257">
Implementing Sort
</h2>
<div>[Video description begins] <em>Topic title: Implementing Sort. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />Now that we&#39;ve written code for and tested the heapify operation, which converts an unsorted array of elements into a maximum heap, we are now ready to perform heapsort using the heap that we&#39;ve just created. Here is the code on screen for our heapsort operation.<br /><br />[Video description begins] <em>The screen displays an Eclipse IDE window, where a Main.java tab is open. This tab shows various lines of code.</em> [Video description ends]<br /><br />You will find that once we have all of the other operations in place, heapsort is pretty straightforward. Here our heapsort function takes as an input argument the array that needs to be heap sorted. The input to heapsort is essentially an unsorted array of elements. The first thing to do within heapsort is to create a heap out of this unsorted array. And that we can do using the operation for which we&#39;ve just written code, that is the heapify operation.<br /><br />We&#39;ll invoke heapify on the entire array. The endIndex is array.length -1. I then have a dotted line separator separating all of the print statements from the original heapify operation, we can ignore those for now. Next we have a while loop which at each iteration will get the highest priority element, that is the maximum element from our heap. And place it at the end of the same array within which we have the heap.<br /><br />We&#39;ll then shrink the size of the heap by one, such that the elements at the end of the array make up our sorted list. And the elements in the first part of our array continue to be part of our max heap. The max heap keeps shrinking by one element at a time in each iteration. When we start this process, the endIndex of the heap, that is the last element in the heap, it is basically the entire array. endIndex, I initialize to array.length -1. Now so long as endIndex is greater than 0, that is there are still elements present in our max heap, I&#39;m going to run this while loop.<br /><br />Each iteration I&#39;m going to print out the element, which is the last element of the heap and the entire array as well. This is the System.out.println on line 113. The next step is to basically access the largest element in our max heap at index 0 and swap it with the last element in the heap. This is the swap operation on line 118. This essentially moves the largest element to the very end of our array. And after we&#39;ve performed the swap operation, we&#39;ll print out the array representation once again. Now the last element is a part of our sorted list, it&#39;s no longer part of the max heap.<br /><br />So we decrement endIndex by 1, endIndex--. But now the element at index 0 is probably not in the right position. It needs to be percolated down till the right position for it can be found. We invoke percolateDown starting at index 0, we ensure that we pass an endIndex. This is what will make sure that the last element which is a part of our sorted list is not considered to be part of the heap. And that&#39;s all there is to the heapsort operation.<br /><br />We continue this process so long as endIndex is greater than 0. We&#39;re now ready to test out this code for heapsort. Here is my original array which is completely unsorted. I&#39;m going to print out the original array and then print out the sorted array at the end. On line 133, I&#39;m going to go ahead and invoke heapsort to sort this array in the ascending order. I&#39;m going to run this code to perform heapsort and let&#39;s see what the results look like.<br /><br />Now initially, all of these Console output statements that you see here are for the process of heapify. We&#39;ve already seen how heapify acts on our unsorted list. Once you see the dotted line, you know the heapify portion of the heapsort operation is now complete. The end of the heap is the element 6 and the entire array which is now a max heap is represented here on screen. In the very first line of our Console output, you can see that 56 is the largest element in our heap. 56 at index 0 is also the root node of the heap.<br /><br />The first step in the heapsort process after heapification is to remove the highest priority element and move it to the very end. The highest priority element is 56, which I now moved to the end. After the swap operation, you can see that the element 56 is the last element in the array. The element 6 which was originally at the end, is now at index 0. Now 6 is no longer in the right position, we need to invoke the percolateDown operation to move 6 to the right position. The larger child of 6 is 17, so we swap 6 with 17.<br /><br />Notice at the bottom after the swap, 6 is now at index 1. We continue to further percolate down 6, the larger child of 6 is now 14. We swap 6 with 14 and we further percolate down 6. This continues till 6 reaches the correct position for it. If you see now at the top of your screen, the element 6 is in the second to last position, it&#39;s actually the last element in the heap. Remember, element 56 is no longer part of the heap. If you notice now the end of the heap is still element 6. And the largest element is 17, which we now plan to move to the end.<br /><br />After the swap operation, 17 is now the second to last element. Now this process continues, we keep removing the maximum element. Moving it to the end and percolating down elements till the list is finally sorted. The other Console output statements will help you understand every step in the heapsort process. I&#39;ll leave it to you to figure these out and read them through. At the very end, notice that we have a completely sorted array. Element 1 is at the beginning of the array and 56 is at the very end.</div>
</div>
<div>
<h2 id="d603605e-0bf4-44a0-a323-ea758d319543">
Course Summary
</h2>
<div>[Video description begins] <em>Topic title: Course Summary</em> [Video description ends]<br /><br />In this course, we studied a very interesting data structure based on binary trees. The binary heap data structure. The binary heap is a special tree which satisfies the heap property and the shape property. We saw how the binary heap can be implemented using an array representation, thanks to the fact that there exists a mathematical relationship between the parent node index values, and child node index values in a binary heap. This fact makes the binary heap a great choice of data structure to implement the priority queue.<br /><br />We understood and implemented both the minimum heap and the maximum heap using an underlying array implementation, and wrote code for performing a range of heap operations. We rounded off this course by using the max heap to perform heap sort, another sorting technique, which performs sorting with roughly O(n) log n complexity. With this we are ready to move on and study yet another interesting data structure. The graph made up of vertices and edges which connect these vertices.</div>
</div>
</body>
</html>
