<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Advanced Data Structures & Algorithms in Java: Getting Started with Graphs Transcript">
<title>Advanced Data Structures & Algorithms in Java: Getting Started with Graphs Transcript</title>
</head>
<body>
<h1>Advanced Data Structures & Algorithms in Java: Getting Started with Graphs</h1>
<p><p>Graph data structures have numerous real-world applications. Recognizing what these applications are and how best to work with graphs in your day-to-day is a must-have skill for any Software Engineer.</p>
<p>In this course, you&#39;ll identify what is meant by a graph. You&#39;ll examine the typical, real-life applications of graphs and explore how they can be represented in programming languages.</p>
<p>You&#39;ll move on to define different types of graphs, such as directed and undirected graphs, connected graphs, trees, and weighted and unweighted graphs.</p>
<p>Next, you&#39;ll explore how to write code and perform operations on graphs. Finally, you&#39;ll implement graph representations in code using the adjacency matrix representation, the adjacency list, and adjacency set representation.</p></p>
<div>
<h2>Table of Contents</h2>
<ol><li><a href="#0aa1f763-5e86-4289-9e95-c61e6fddb5b2">Course Overview</a></li>
<li><a href="#964b7ac9-ed13-4516-b989-ac4e19d7c7e1">Introducing Graphs</a></li>
<li><a href="#db83c970-9d74-496e-a785-8b825c4da7dc">Directed and Undirected Graphs</a></li>
<li><a href="#eb522ba8-d61a-4323-8155-6d07cf2e8e01">Graphs and Trees</a></li>
<li><a href="#8147a6dd-374b-423a-804c-7ed003b7d6f6">Weighted Graphs</a></li>
<li><a href="#acb868b6-7761-4fa5-a433-da161e6d4fbc">Adjacency Matrix </a></li>
<li><a href="#d5ca0751-505f-4014-a95f-e5e20941b92c">Adjacency List </a></li>
<li><a href="#b5147d61-0259-4971-9e0c-ad87ead444fb">Adjacency Set </a></li>
<li><a href="#a72bef04-0a7c-4b8d-b403-9cc0837ddbd1">Representing Graphs Using an Adjacency Matrix</a></li>
<li><a href="#f8f69b19-815c-4118-8014-03f84dac32c2">Adjacency Matrix Graph: Operations</a></li>
<li><a href="#e764b8e3-ecdf-4848-968c-4f9e8a601df7">Adjacency Matrix Graph: Directed and Undirected</a></li>
<li><a href="#bf52a293-8ba8-481f-99f5-9b7b99d3b32c">Adjacency Matrix Graph: Weighted Graphs</a></li>
<li><a href="#8ae50013-169b-4d1c-91aa-64221a8a2ce3">Representing Graphs Using an Adjacency List</a></li>
<li><a href="#1dd38615-448f-4063-a246-00c0274e5b81">Adjacency List Graph: Weighted Graphs</a></li>
<li><a href="#ffb962ca-f34a-4392-8e5f-ced9484d8288">Representing Graphs Using an Adjacency Set</a></li>
<li><a href="#b9eb7e10-e694-40dc-b417-3953cc18ca61">Graph Traversal</a></li>
<li><a href="#7c468f4e-42b2-435e-ae5a-939720730ac6">Breadth-first Traversal</a></li>
<li><a href="#3d507544-aa15-4f72-939f-09486c1825ad">Depth-first Traversal</a></li>
<li><a href="#74c980f5-3dde-40e1-ad17-25decbe20c6f">Course Summary</a></li>
</ol></div>
<div>
<h2 id="0aa1f763-5e86-4289-9e95-c61e6fddb5b2">
Course Overview
</h2>
<div>[Video description begins] <em>Topic title: Course Overview</em> [Video description ends]
<p>Hi, and welcome to this course Getting Started with Graphs in Java. My name is Janani Ravi and I will be your instructor for this course. <br /><br />[Video description begins] <em>Your host for this session is Janani Ravi. She is a Software engineer an big data expert.</em> [Video description ends] <br /><br />A little about myself first. I did my master&#39;s from Stanford University and have worked at various companies, including Google and Microsoft. I presently work for Loonycorn, a studio for high quality video content. The study of data structures and algorithms involves the study of concepts that are the foundation of writing correct, clean, and robust programs. The knowledge of basic data structures, their characteristics, and the algorithms that go hand in hand with these data structures are important tools in a software engineer&#39;s toolkit. Having the right tools for the job can make the job a lot easier. Being trained in the proper use of the tools is essential to be effective.</p>
<p>Data structures and algorithms allow you to write performant code, which minimizes the use of scarce resources and helps ensure that your code is not just correct, but also fast. In this course, we&#39;ll explore and understand a data structure that finds many uses in the real world. This is the graph data structure. We&#39;ll first study different types of graphs such as directed and undirected graphs, connected graphs, trees, weighted and unweighted graphs. We&#39;ll also see applications in our everyday life that involve the use of graphs. We&#39;ll round out this course by representing graphs in code using a number of different techniques such as the adjacency matrix representation, the adjacency list and set representations. We&#39;ll understand the factors that you&#39;ll need to take into account while choosing the right representation for your graph and the trade-offs that this involves.</p></div>
</div>
<div>
<h2 id="964b7ac9-ed13-4516-b989-ac4e19d7c7e1">
Introducing Graphs
</h2>
<div>[Video description begins] <em>Topic title: Introducing Graphs. Your host for this session is Janani Ravi.</em> [Video description ends]
<p>In this course we&#39;ll study the graph data structure. We&#39;ll understand the common applications of graphs, and we&#39;ll see how graphs can be represented. In your programming language, what exactly is a graph? Well, because of the use of social networks these days, a graph is a common data structure that people are familiar with. A graph can be thought of as a data structure that is used to represent relationships between entities. The primary function of a graph is to model relationships. The entities in your graph can be anything, it all depends on what you&#39;re trying to represent. In the real world, graphs find applications in a varieties of ways.</p>
<p>And entities can be any real world object, either actual physical objects or abstract ones. The relationships that you express using a graph can be arbitrarily complicated. And there are a variety of different kinds of relationships that you can express. Every graph is made up of two basic components. We have the vertex of a graph, also referred to as a node of a graph. We&#39;ll use the term node and vertex interchangeably in this course. The vertex of a graph is used to represent entities.</p>
<p>The second component in a graph is the edge. The edge of a graph is what is used to connect vertices together. The edge of the graph is what you use to express relationships. In any graph, you use vertices or nodes to model entities, and you use edges which connect nodes. These are used to model relationships. It&#39;s possible for both vertices and edges to have additional attributes that are used to describe the entities and the relationships.</p>
<p>But for the most part, when we study graphs as a data structure, we won&#39;t really concern ourselves with the attributes for entities or relationships. We&#39;ll only focus on the graph data structure itself and algorithms that work with graphs. Let&#39;s consider some real world applications of graphs. Let&#39;s say the entities that you&#39;re looking to model are people, people in the real world. The edge might represent professional relationships that exist between people. People work together, they&#39;re colleagues, there is a boss-subordinate relationship, you might have worked together with someone in the past. Edges in a professional graph represent a professional relationship. Or you could have the edges in the graph where the vertices are people represent a personal relationship. This is an example of a social graph. Two people can be friends, two people can be related to one another, and so on.</p>
<p>If we were to discuss social media sites, your professional graph would be represented on LinkedIn and your social graph might be on Facebook or Instagram. The entities in your graph represented using vertices might be locations. The edges in your graph would then be the ways that different locations are connected. This is exactly what a map does. An edge might be a way to get from one location to another such as roads, railways and air travel. Another way to think about edges on a map is that every edge represents a means of transport, such as a bus, car, taxis, trains, and so on.</p>
<p>Let&#39;s suppose that the entity that we are trying to model in our graph is an old fashioned phone, which is physically connected. The edge in such a graph would be the phone network, a physical network that carries voice from one instrument to another. Another example before we move on, the entities that you represent in a graph might be computers, desktop computers or handheld devices. The edge refers to connectivity between devices, and that is the internet, a way to send information or data from one computer to another. Today however, this connectivity can be established wirelessly as well, so information can be routed wirelessly or over wires.</p></div>
</div>
<div>
<h2 id="db83c970-9d74-496e-a785-8b825c4da7dc">
Directed and Undirected Graphs
</h2>
<div>[Video description begins] <em>Topic title: Directed and Undirected Graphs. Your host for this session is Janani Ravi.</em> [Video description ends]
<p>We know that graphs can be used to model relationships between entities. But what exactly is a graph? We know that graphs are made up of two component. We have a set of vertices and edges which connect different vertices. A graph can be very simple or it can be arbitrarily complicated. It all depends on what it is that you want to model. You can have a single vertex be a valid graph as well. Or you can have a graph with just two vertices and a single edge connecting these two vertices. Here on screen, I&#39;ve represented one of the simplest possible graphs that you could have. You can see A and B here. These represent vertices or nodes in this graph. A set of vertices is usually represented using V.</p>
<p>This connection line that I have drawn between these two vertices is an edge. This edge implies that there is some kind of relationship between a vertex A and vertex B. Now this relationship can be anything. It&#39;s possible that node A here is the source node and node B is some kind of destination. And you have an edge between source and destination. Observe that there is an arrow here on this edge. You can draw an edge between the two vertices of a graph with or without an arrow. When there is an arrow between vertex A and vertex B, this means that the relationship between the two vertices is directed. This edge is a directed edge, and it makes sense when you&#39;re traveling, you&#39;ll use a map to get from your source to the destination. There is a directionality to that relationship.</p>
<p>An edge between two vertices on a graph with an arrow on it in one direction is a directed edge. This indicates that there is some kind of directionality in the relationship between the nodes. It&#39;s possible to categorize our graphs into two types. We have undirected graphs, where the edges have no arrows, here the relationship flows in both directions. Or you can have directed graphs, where you have an arrow from one node to another. These are directed graphs indicating that the relationship flows in one direction. Undirected edges in a graph represent two-way relationships, and directed edges represent one-way relationships.</p>
<p>If the vertices in your graph represent locations, then undirected graphs might indicate roads that can be traveled in both ways, two-way roads. Directed edges, on the other hand, might represent one-way roads, roads in which you can travel in just one direction. If the vertices in your graph represent people, undirected edges might represent friendships. I am his friend and he is mine. If the vertices in your graph represent people, directed edges might represent professional relationships. He is my manager, I report to him.</p></div>
</div>
<div>
<h2 id="eb522ba8-d61a-4323-8155-6d07cf2e8e01">
Graphs and Trees
</h2>
<div>[Video description begins] <em>Topic title: Graphs and Trees. Your host for this session is Janani Ravi.</em> [Video description ends]
<p>In this video, we&#39;ll discuss the different kinds of graphs, and we&#39;ll see how the tree data structure is just a specialized graph. Here is an example of an undirected graph. This graph is undirected because all of the connections between the vertices of this graph are undirected. There are no arrows here, all relationships flow both ways. Nodes in a graph that are directly connected to one another are said to be adjacent nodes. A and B are adjacent nodes, A and C are adjacent nodes as well. Any node B is adjacent to node A if there is a way to get from node A to node B. In an undirected graph, if there is an edge connecting two nodes, those two nodes are adjacent.</p>
<p>Another term that we&#39;ll use while working with graphs is the in-degree. The number of edges incident on a particular vertex is referred to as the in-degree of that vertex. For any vertex, the number of edges that flow into that vertex is the in-degree. In an undirected graph, all edges flow in both directions, so you just find the number of edges incident on a vertex. D here has an in-degree 3, and A has an in-degree of 2, two edges are incident on vertex A. You can see in this graph here that there is a way to get from node B to node C.</p>
<p>So if you&#39;re standing on node B, you can get to node C by traversing node A. This series of edges connecting the source and the destination is referred to as a path. In an undirected graph, if there is a path from node B to node C, that implies a path exist from node C to node B, since the edges flow both ways. Observe here that we have a cycle in this graph. Starting from node D, it&#39;s possible to go to node E then node F, and then back to D, these three edges form a cycle. There is a second cycle in this graph as well, node D, C, and E form another cycle. If you wanted to get rid of all of the cycles in this graph, that would involve removing a few connecting edges.</p>
<p>I&#39;ve gotten rid of the edge between C and D, and D and F. The resulting graph with the edges removed contains no cycle. This is an acyclic graph, a graph with no cycle. Because the edges of this graph are undirected, it&#39;s actually an undirected acyclic graph. In this undirected acyclic graph, observe that every node is connected to every other node via a series of edges. So starting from one node, it&#39;s possible to get to all other nodes that exist in this graph. Such a graph is called a connected graph.</p>
<p>Now if you look very closely at this connected graph that is also acyclic, that is it contains no cycles, that is in essence, a tree. And the tree data structure is something that we are familiar with. In order to visualize this graph as a tree, we just need to reorient this graph such that one node is the root node. Here I&#39;ve picked E to be the root node, you can clearly see that this graph is a tree. We&#39;ve understood how undirected graphs work, let&#39;s look at a directed graph. All edges in a directed graph are directed edges. If you look at the node A, it is connected to C, but C is not connected to A.</p>
<p>So, C is adjacent to A, but A is not adjacent to C. This graph here contains no cycles at all. This is a directed acyclic graph. Directed acyclic graphs find many uses in the real world, such as drawing up course schedules. Nodes are the courses that you need to take, edges represent which courses are prereqs for others. Directed acyclic graphs can also be used to specify dependencies between tasks. Tasks which are dependent on others can only be performed after the dependent tasks are complete.</p>
<p>Now you can have a graph where it&#39;s not possible to get from one node to all other nodes in that graph. What you see here on screen is also a graph. Nodes A, B, and C are connected to one another, but nodes D, E, and F are not connected to nodes A, B, and C, this is an unconnected graph. Also note that every individual portion of this unconnected graph has no cycles, so both of these portions, both of these graphs are trees. So what you have here is a forest of disjoint trees, disjoint because they are not connected with one another.</p></div>
</div>
<div>
<h2 id="8147a6dd-374b-423a-804c-7ed003b7d6f6">
Weighted Graphs
</h2>
<div>[Video description begins] <em>Topic title: Weighted Graphs. Your host for this session is Janani Ravi.</em> [Video description ends]
<p>All of the graph examples that we&#39;ve seen so far are unweighted graphs. It&#39;s also possible for a graph to be weighted. So what is a weighted graph? A weighted graph has a weight or a number associated with every edge in the graph. Now these weights are generally positive, but it&#39;s also okay for these weights to be negative. The weight associated with each edge represents some kind of value associated with that relationship. Let&#39;s go back to looking at the simplest possible graph. We have two nodes here connected using a directed edge, and this edge has a weight of 2. The number representing the weight is generally placed close to the edge.</p>
<p>The vertices in a graph represent entities and the edges are used to model relationships. This is something that we have studied earlier. The weights associated with each relationship represent additional information that we have about that relationship. For example, if we were to consider A and B to be two locations on a map, then the edge connecting A to B would be a way to get from the source to the destination. Now the weight associated with the edge could represent traffic conditions, the time taken to go from A to B, or the weight could represent the distance from A to B. When you specify a weight with every edge in a graph, that is a weighted graph.</p>
<p>This is an example of a weighted graph observe that every edge is associated with a number. Now that we&#39;ve understood how graphs are useful and how they work, let&#39;s talk about what is it that you need to represent a graph in a programming language. The first thing is you need a way to model a vertex. And this vertex might hold some information. It should have a way to contain some data. In your graph representation, you also need a way to model edges. Either directed edges or undirected edges.</p>
<p>There are three common representations of a graph. The first of these is the adjacency matrix representation, where the vertices in your graph form the rows and columns of the matrix. The second is the adjacency list representation where you model every vertex and specify what vertices are adjacent to each vertex. And the last representation is the adjacency set representation. Here, for each vertex, you model the adjacent vertices using a set rather than a list.</p></div>
</div>
<div>
<h2 id="acb868b6-7761-4fa5-a433-da161e6d4fbc">
Adjacency Matrix 
</h2>
<div>[Video description begins] <em>Topic title: Adjacency Matrix. Your host for this session is Janani Ravi.</em> [Video description ends]
<p>In this video, we&#39;ll see how a graph can be represented using an adjacency matrix. We already know that there are three kinds of data structures that we can use to represent a graph. The adjacency matrix, that adjacency list, and the adjacency set. We&#39;ll start our graph representation of using the adjacency matrix. This is just a matrix with rows and columns. A matrix, as you know from computer science and maybe mathematics, is just a table. The row labels and the column labels in this matrix represent the vertices in your graph. This implies that the adjacency matrix is a square matrix, number of rows equal to number of columns equal to number of vertices.</p>
<p>Every cell in the adjacency matrix represents the relationship between vertices, that is the edge that connects two vertices. Here on screen you see a directed graph. This is the directed graph that I am going to represent using the adjacency matrix representation. You first need to set up a matrix that is a table with rows and columns. Observe that this is a square matrix with number of rows equal to number of columns equal to number of vertices. There are a total of five vertices in this graph. Observe that every row and every column corresponds to a vertex. The first row and first column represents the vertex A, the second row and second column, the vertex B, the fifth row and fifth column, the vertex E, and so on. The cells within this matrix will represent the connection that exist between the vertices of your graph. Now there is no node that is connected to itself. We don&#39;t have a path from A leading back to A, B leading back to B, and so on.</p>
<p>So the main diagonal here, we fill in with all 0s. In order to fill in the other rows, we need to consider one vertex at a time. We&#39;ll start by considering the vertex A. Looking at the graph, you need to see which nodes the vertex A is connected to. A is connected to exactly one node, B, using a directed edge. So we fill in a value of 1 in the first row and the second column, A to B. The vertex A is not connected to any other node, the remaining entries in the first row are 0. We can now move on to considering the second node, B. Take a look at what nodes B is directly connected to, and fill in 1s for those cells. B is connected to both C as well as D, the entries corresponding to those cells are 1, the remaining entries are 0. B is not connected directly to any other node. Moving on to node C, C is directly connected only to node E. So in the row C column E, we have a 1, the remaining entries are 0. In order to fix this we need to use a visited list to keep track of nodes that we&#39;ve already traversed or visited.</p>
<p>And finally we have node E here. E has no outward edge to any other node. It&#39;s not connected directly to any other node. We fill in that row with all 0s. This gives us the adjacency matrix representation for a directed graph, where every edge is a directed edge. But what if the same graph was an undirected graph? There are no arrows on the edges, if you observe. For an undirected graph, let&#39;s consider each node in turn, starting with the node A. Now we already had a connection from A to B, as you can see by the 1 in our adjacency matrix entry. But now a connection exists from B to A as well. We need to add in another 1 with source B and destination A.</p>
<p>Observe that this new entry is at a mirrored location across the main diagonal. For an undirected graph, for each of the original directed edges, we fill in a 1 in the mirror location as well. The mirror is across in diagonal. Observe that I&#39;m taking every edge in turn, And filling in an additional 1 to represent an undirected edge. From depth-first traversal let&#39;s move on to breadth-first traversal. In breadth-first traversal, we start at some node in the graph and we go level-wise from that first node. We&#39;ll add all of the non-visited child nodes of the node that we are currently traversing to a queue. We&#39;ll then dequeue them and perform breadth-first traversal. So for each edge, we need two entries in the adjacency matrix.</p>
<p>And this is how, by tweaking the adjacency matrix that we use to represent a directed graph, we set up the adjacency matrix to represent the undirected graph. Here is another tweak for you. What if our graph was weighted? What if every edge was associated with a weight? How would we then use the adjacency matrix to represent this weighted graph? This is an example here of a weighted undirected graph. The solution here is pretty straightforward. Instead of using a 1 to mark an edge between two vertices, we&#39;ll simply enter the edge weight in each matrix cell. For example, here is an edge between the nodes A and B with a weight of 2.</p>
<p>We have an entry of 2 in row B column A and column B row A. Here is another undirected edge between nodes B and C. We have an entry of 1, that is the weight of this edge, in row C column B, and column C row B. In this manner we can cycle through every edge in this graph. Here is the edge between B and D. Make sure you enter the weight of this edge in the right matrix cells. Let&#39;s go to the next edge here. This is the edge between C and E. I enter the weight of 2 in the right places. Moving on, here is the connection between nodes C and D, I enter 7 in the right matrix cells. One more edge to represent, the edge between D and E with a weight of 4. I enter 4 in the right matrix cells. And here is our weighted undirected graph, expressed as an adjacency matrix. From here, it&#39;s very easy to see how a weighted directed graph can be represented in an adjacency matrix. And I leave that to you as an exercise.</p></div>
</div>
<div>
<h2 id="d5ca0751-505f-4014-a95f-e5e20941b92c">
Adjacency List 
</h2>
<div>[Video description begins] <em>Topic title: Adjacency List. Your host for this session is Janani Ravi.</em> [Video description ends]
<p>From the adjacency matrix, let&#39;s move on to another graph representation. There are three common representations of a graph. The first of these is the adjacency matrix representation, where the vertices in your graph form the rows and columns of the matrix. The second is the adjacency list representation where you model every vertex and specify what vertices are adjacent to each vertex. And the last representation is the adjacency set representation.</p>
<p>Here for each vertex, you model the adjacent vertices using a set rather than a list and that is the adjacency list representation. In the adjacency list representation, every vertex is represented using a node. This node may contain data. It&#39;ll also contain some pointers or references. When I say every vertex is a node, this means that each vertex is represented using a node object or a vertex object. Every vertex object in our graph representation will contain a reference to a linked list. This is the list which contains all of the nodes that are adjacent to the current vertex.</p>
<p>For example, if you have an edge connecting the vertex V to the vertex U, then the vertex U will be present in V&#39;s linked list. This is how you know that one node is adjacent to another. Let&#39;s look at how you can represent a graph using an adjacency list visually. Here is the graph that we are going to represent and you can see that this graph has five nodes. I have five vertex objects that I have created here. Each vertex object corresponds to a vertex in our graph. Now let&#39;s go ahead and look at all of the edges that exist in our graph and set up our adjacency list. There is an edge from node A to node B. So the list corresponding to vertex A will have the vertex B in it. Node B is adjacent to A. Let&#39;s move on to node B. Node B is connected to both nodes C and D. So the list corresponding to the vertex B has both C and D in it. Moving on, let&#39;s go to node C.</p>
<p>Node C is directly connected only to node E. So the list corresponding to node C has only the node E in it. Going on to node D. Node D has two outward edges to node C and node E. The list corresponding to the vertex D has both nodes C and E within it. And finally, when we head over to node E, we can see that E has no outward connections. The list corresponding to node E is completely empty. The adjacency list representation of a graph can also be used to represent undirected graphs. Here is the same graph except that all edges have no arrows, all edges are undirected. Let&#39;s use the adjacency list representation to represent this graph. We&#39;ll consider each of the nodes in turn once again. Node A is connected to node B. Moving on to node B. B is connected directly to nodes A, C, and D.</p>
<p>So A, C, and D are all three present in the list associated with B. Now if you look at node C, node C is connected to node B, D, and E. B, D, and E are present in the list associated with C. Moving on to node D. D is connected to three other nodes B, C, and E. B, C, and E are present in the list associated with D. And finally we have node E that is connected to two other vertices, C and D. Both C and D are present in the list associated with E. And thus, the adjacency list can be used to represent undirected graphs as well. Now as far as graph representations go, the adjacency list representation has several drawbacks and it&#39;s not used often. Adjacency lists tend to be poor representations of graphs.</p>
<p>And an important reason for this is that the same graph can be represented in many ways. The order of vertices in the adjacency lists matter. The same graph can have many representation just by changing the order of the adjacent vertices. And this is not a great thing. It makes it hard for us to compare graphs. Also, there are certain operations on graphs that can get fairly tricky. For example, if you want to delete a node from a graph, this involves looking through all of the adjacency lists for every node to see if that node is present. And we&#39;ll have to remove this node from all lists.</p></div>
</div>
<div>
<h2 id="b5147d61-0259-4971-9e0c-ad87ead444fb">
Adjacency Set 
</h2>
<div>[Video description begins] <em>Topic title: Adjacency Set. Your host for this session is Janani Ravi.</em> [Video description ends]
<p>Better alternative to the adjacency list representation which overcomes some, but not all drawbacks of the adjacency list, is the adjacency set representation. The adjacency set representation simply replaces the adjacency list with, you guessed it, the adjacency set. So the adjacency set is very similar to the adjacency list representation, but instead of a linked list to maintain a list of adjacent vertices, we&#39;ll use a set. So associated with each vertex object, we&#39;ll have a set of adjacent nodes, not a list.</p>
<p>This is the only difference between the adjacency list and the adjacency set. But this difference is important. The main advantage here is that the same graph will not be represented in different ways. A set is a set, and the elements in two sets can be compared to see whether they&#39;re the same. The ordering of the elements in a set do not matter. Now that we&#39;ve understood the different graph representations, let&#39;s compare and contrast them so we understand the strengths and weaknesses of each representation.</p>
<p>Let&#39;s take the adjacency matrix first. This works well when the graph is well connected, that is we have many nodes which are connected using many edges. So a well connected graph with a large number of nodes and a large number of edges, the adjacency matrix is what you would choose. On the other hand, if the graph that you&#39;re working with is fairly sparse, that is, there are just a few nodes in your graph and just a few edges connecting these nodes, an adjacency list or an adjacency set representation might be better. The adjacency set is always better than the adjacency list. Why is it that an adjacency matrix is preferred only for densely connected graphs? Well, the adjacency matrix takes up a lot of space. If you have a graph with V vertices, the order of space required is V square.</p>
<p>This additional space is totally worth it if you have a densely connected graph. For a sparsely connected graph, you might want to be a little more space efficient. With an adjacency list or an adjacency set, you only use up space for connections that actually exist in your graph. You don&#39;t need to allocate space for connections that do not exist. Now let&#39;s put all of this into a table. For each kind of graph representation, let&#39;s compare them in terms of space used, how long it takes to figure out whether an edge is present between two nodes, and how long it takes to iterate over edges on a vertex.</p>
<p>Here I assume V is equal to the number of vertices present in my graph, E equal to number of edges. Now as far as space is concerned, the adjacency matrix requires space that is order of V square. The number of rows equal to the number of vertices, number of columns equal to number of vertices, that is V square. For both the adjacency list as well as the adjacency set representation, the space required is E &#43; V. The time complexity to figure out whether an edge is present between two nodes, in the case of an adjacency matrix, is basically O(1), constant time complexity.</p>
<p>In the case of an adjacency list, it is the degree of V, that is, the number of edges incident on a particular node V. That is the degree of V. In the case of an adjacency set, well, this is directly dependent on the performance of the set and that&#39;s typically log of the degree of V, log of the number of edges incident on a particular vertex V. And finally, the running time of the algorithm required to iterate over all of the edges incident on a particular vertex in the adjacency matrix&#39;s case is V. You basically have to iterate over all vertices in your graph to find the edges that are incident on one particular vertex. In the case of the adjacency list and the adjacency set, the time complexity is equal to the degree of V, that is the number of edges incident on a particular vertex.</p></div>
</div>
<div>
<h2 id="a72bef04-0a7c-4b8d-b403-9cc0837ddbd1">
Representing Graphs Using an Adjacency Matrix
</h2>
<div>[Video description begins] <em>Topic title: Representing Graphs Using an Adjacency Matrix. Your host for this session is Janani Ravi.</em> [Video description ends] <br /><br />[Video description begins] <em>An Eclipse IDE interface displays. It is divided into three sections. The left pane is titled as: Package. It contains a folder titled: DataStructuresInJava. To the right is the editor pane. It displays the code of &#34;Graph.java&#34; file. Towards the bottom is the Console.</em> [Video description ends]
<p>In this demo, we&#39;ll see how we can represent a graph data structure using the adjacency matrix representation. The adjacency matrix representation sets up a matrix with number of rows, and number of columns equal to the number of nodes in the graph. Now, before we set up the adjacency matrix representation, I&#39;m going to set up an interface for the graph data structure that will specify the common operations that you can perform on graphs. This is my public graph interface, in the file Graph.java. <br /><br />[Video description begins] <em>Line 3 reads as: public interface Graph {.</em> [Video description ends] <br /><br />Set up the import statements that we&#39;ll need within this interface, we need Java util list. <br /><br />[Video description begins] <em>She enters the following line of code in line 3, that reads as: import java.util.List;.</em> [Video description ends] <br /><br />The next step is to set up the methods that all of our graph representations will implement. Whether they are adjacency matrix representations, or adjacency set, or list representations. For each graph representation, we need to be able to add an edge that connects two vertices, v1 and v2. That is the method here in this interface.<br /><br />[Video description begins] <em>Line 7 reads as: void addEdge(int v1, int v2);.</em> [Video description ends] <br /><br />Observe that the edges here I&#39;ve assumed to be unweighted edges, that our all edges will have a default weight of 1. The next method that all graphs need to implement is one, to getAdjacentVertices. We pass in an input vertex, and it&#39;ll return a list of integer values representing adjacent vertices. <br /><br />[Video description begins] <em>Line 9 reads as: List&lt;Integer&gt; getAdjacentVertices(int v);.</em> [Video description ends] <br /><br />Then we have getNumVertices that&#39;ll give us the total number of vertices in this graph. <br /><br />[Video description begins] <em>Line 11 reads as: int getNumVertices();.</em> [Video description ends] <br /><br />getIndegree will take as an input argument a vertex, and will get you the number of edges that go inwards, or point into that vertex.<br /><br />[Video description begins] <em>Line 13 reads as: int getIndegree(int v);.</em> [Video description ends] <br /><br />And finally, we have a helper method displayGraph that will simply print out a representation of the graph to screen. <br /><br />[Video description begins] <em>Line 15 reads as: void displayGraph();.</em> [Video description ends] <br /><br />Now that we have the graph interface, we are ready to write a concrete implementation of this interface. Go to the package, right-click, select New &amp; Class. <br /><br />[Video description begins] <em>A &#34;New Java Class&#34; wizard displays. It contains the following fields, including: Source folder, Package, Name, and Modifiers. The &#34;Cancel&#34; and &#34;Finish&#34; buttons display at the bottom of the wizard.</em> [Video description ends] <br /><br />Our first representation of the graph will be the adjacency matrix representation. Name this file AdjacencyMatrixGraph, and go ahead and create it. We&#39;ll need a number of different libraries here. Set up the import statements for ArrayList, Collections, and List. <br /><br />[Video description begins] <em>Line 3 reads as: import java.util.ArrayList;. Line 4 reads as: import java.util.Collections;. Line 5 reads as: import java.util.List;</em> [Video description ends]</p>
<p>Now, this adjacencyMatrix graph implements the graph interface that we set up earlier. So go ahead and add an implements graph.<br /><br />[Video description begins] <em>Line 7 reads as: public class AdjacencyMatrixGraph implements Graph {.</em> [Video description ends] <br /><br />The graph interface has many methods that need to be implemented. And we&#39;ll do this one by one. First, let&#39;s set up the private member variable adjacencyMatrix, which is a two dimensional array.<br /><br />[Video description begins] <em>Line 9 reads as: private int[][] adjacencyMatrix;.</em> [Video description ends] <br /><br />This is a two dimensional array that will represent the interconnections between all of the nodes in our graph. I also have a number variable numVertices tracking the number of vertices that we have in our graph. This is initialized to 0.<br /><br />[Video description begins] <em>Line 11 reads as: private int numVertices &#61; 0;.</em> [Video description ends] <br /><br />Here is the constructor for my AdjacencyMatrixGraph. The only input argument that we specify here is the number of vertices that we have in the graph. We assign this to this.numVertices. <br /><br />[Video description begins] <em>Line 13 reads as: public AdjacencyMatrixGraph(int numVertices) {. Line 15 reads as: this.numVertices &#61; numVertices;.</em> [Video description ends] <br /><br />We then use this number of vertices information to instantiate the adjacencyMatrix. <br /><br />[Video description begins] <em>Line 17 reads as: this.adjacencyMatrix &#61; new int[numVertices] [numVertices];.</em> [Video description ends] <br /><br />This is a new two dimensional integer matrix, where each dimension has a numVertices elements. Number of rows equal to number of columns both equal to number of vertices in the graph. We haven&#39;t specified the edges connecting the different vertices yet. So I&#39;m going to run a nested for loop, one with variable i, and another with variable j, to initialize all elements of this adjacency matrix to be equal to 0, indicating no connection. So for int i &#61; 0, i &lt; numVertices within that int j &#61; 0, j &lt; numVertices, set adjacencyMatrix[i][j] &#61; 0. <br /><br />[Video description begins] <em>Line 19 reads as: for (int i &#61;0; i&lt; numVertices; i&#43;&#43;) {. Line 21 reads as: for (int j &#61;0; j&lt; numVertices; j&#43;&#43;) {.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 22 reads as: adjacencyMatrix[i][j] &#61; 0;. Line 23 reads as: }.</em> [Video description ends] <br /><br />Next, let&#39;s start implementing some of the methods of the graph interface. We&#39;ll start with addEdge. addEdge will add a directed edge of weight 1 from vertex v1 to v2. Now, this first implementation of the graph using adjacencyMatrix representation is going to represent just directed, unweighted graph. We&#39;ll assume that all edges point in a certain direction. They are directed edges, and all edge weights are equal to 1. Let&#39;s take a look at the implementation of addEdge for a directed, unweighted graph.<br /><br />[Video description begins] <em>Line 28 reads as: public void addEdge(int v1, int v2) {.</em> [Video description ends] <br /><br />We pass in two vertices, represented using integers v1 and v2. The first if condition here is a sanity check to see whether the vertex numbers are in range. <br /><br />[Video description begins] <em>Line 30 reads as: if (v1 &gt;&#61; numVertices || v2 &gt;&#61; numVertices || v1 &lt; 0 || v2 &lt; 0) {.</em> [Video description ends] <br /><br />If the value of either v1 or v2 is greater than or equal to numVertices or less than 0, we know the vertices are out of range. We&#39;ll throw an IllegalArgumentException saying vertex number is not valid. [Video description begins] <em>Line 32 reads as: throw new IllegalArgumentException(&#34;Vertex number is not valid&#34;);.</em> [Video description ends] <br /><br />Otherwise, to add an edge, all we need to do is to set the entry for element v1, v2 in the adjacencyMatrix to be equal to 1.<br /><br />[Video description begins] <em>Line 35 reads as: adjacencyMatrix[v1][v2] &#61; 1;.</em> [Video description ends] <br /><br />This is what we do on line 35. Setting this element to 1 is the equivalent of adding an unweighted directed edge from v1 to v2. To indicate that there is an edge from v1 to v2, the cell at row v1 and column v2 will have its value set to 1. The next method that we&#39;ll implement from the graph interface is the get adjacent vertices. It takes as an input argument the vertex for which we want adjacent vertices. <br /><br />[Video description begins] <em>Line 39 reads as: public List&lt;Integer&gt; getAdjacentVertices(int v) {.</em> [Video description ends]<br /><br />The first if condition is to check whether the vertex number is valid. If v &lt; 0 or &gt;&#61; numVertices, we throw IllegalArgumentException. This is an invalid vertex. <br /><br />[Video description begins] <em>Line 30 reads as: if (v &lt; 0 || v &gt;&#61; numVertices) {. Line 41 reads as: throw new IllegalArgumentException(&#34;Vertex number is not valid&#34;);.</em> [Video description ends] <br /><br />Otherwise, we instantiate a new ArrayList that&#39;ll hold the adjacent vertices of the current vertex specified by number v.<br /><br />[Video description begins] <em>Line 44 reads as: List&lt;Integer&gt; adjacentVerticesList &#61; new ArrayList&lt;&gt;();.</em> [Video description ends] <br /><br />The way we find adjacent vertices is to iterate over all rows of the adjacencyMatrix. So we run a for loop starting at 0, so long as i &lt; numVertices, and we check if the entry in the adjacencyMatrix[v][i], is not equal to 0. <br /><br />[Video description begins] <em>Line 46 reads as: for (int i &#61;0; i&lt; numVertices; i&#43;&#43;) {.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 48 reads as: if (adjacencyMatrix[v][i] !&#61; 0);.</em> [Video description ends]<br /><br />If the entry in this cell is not equal to 0, we know that the vertex i is adjacent to the vertex v. There is an edge from v to i. We go ahead and add i to the adjacentVerticesList. <br /><br />[Video description begins] <em>Line 50 reads as: adjacentVerticesList.add(i);.</em> [Video description ends]<br /><br />Once all adjacent vertices have been populated on line 54, we&#39;ll simply sort the adjacentVerticesList, so that the adjacent vertices are returned in sorted order. <br /><br />[Video description begins] <em>Line 54 reads as: Collections.sort(adjacentVerticesList);.</em> [Video description ends] <br /><br />This is completely optional. You don&#39;t really need to perform this operation if you don&#39;t want to. Sorting the adjacent vertices will increase the running time of this particular method. So you might want to think before you add this in. But for our simple graph, this is fine. We&#39;ll then return the adjacentVerticesList.<br /><br />[Video description begins] <em>Line 56 reads as: return adjacentVerticesList;.</em> [Video description ends]<br /><br />The next method that I&#39;ll implement from the graph interface is the getIndegree method. This takes as an input argument a vertex number, and we&#39;ll calculate the indegree of this vertex. That is the number of edges pointing into this vertex.<br /><br />[Video description begins] <em>Line 60 reads as: public int getIndegree(int v) {.</em> [Video description ends]<br /><br />I&#39;ll first check whether this vertex number is valid. It it&#39;s &lt; 0, or &gt;&#61; to numVertices, we&#39;ll throw an IllegalArgumentException. Saying vertex number is not valid. We&#39;ll then initialize indegree to be equal to 0. That is our assumption to start off with.<br /><br />[Video description begins] <em>Line 66 reads as: int indegree &#61; 0;.</em> [Video description ends] <br /><br />Once that&#39;s done, we&#39;ll run a for loop through all the vertices in this graph from i &#61; 0, so long as i &lt; numVertices. We&#39;ll then check if there are any inward edges pointing into the current vertex. If adjacencyMatrix[i][v] is not equal to 0, that is an inward pointing edge. <br /><br />[Video description begins] <em>Line 70 reads as: if (adjacencyMatrix[i][v] !&#61; 0) {.</em> [Video description ends] <br /><br />In order to get the inward pointing edges, we have to look at all cells in the column v. If there is a 1 there, that means there is an inward pointing edge. We increment indegree for every inward pointing edge, and we finally return the value computed.<br /><br />[Video description begins] <em>Line 71 reads as: indegree&#43;&#43;;. Line 75 reads as: return indegree;.</em> [Video description ends]<br /><br />The next method that we&#39;ll override is getNumVertices(). <br /><br />[Video description begins] <em>Line 79 reads as: public int getNumVertices(){.</em> [Video description ends]<br /><br />This is pretty straightforward, since we have a numVertices member variable, and we simply return the value in that variable. <br /><br />[Video description begins] <em>Line 80 reads as: return numVertices;.</em> [Video description ends] <br /><br />Now, we have one last method in the graph interface, and that is display graph. <br /><br />[Video description begins] <em>Line 84 reads as: public void displayGraph() {.</em> [Video description ends]</p>
<p>This method doesn&#39;t really perform any operation on the graph. It simply prints out a representation of the graph for the purposes of debugging. We&#39;ll print out that this is an Adjacency Matrix representation, and we&#39;ll print out the entire adjacencyMatrix in the form of rows and columns. That is what the first nested for loops do. The code from line 88 to line 95 will print out the adjacencyMatrix in matrix form. Then we have another nested for loop here at the bottom. For each of the nodes in this graph, this nested for loop will print out all of the nodes that are adjacent to each node. This is the code from line 99 to line 110.</p></div>
</div>
<div>
<h2 id="f8f69b19-815c-4118-8014-03f84dac32c2">
Adjacency Matrix Graph: Operations
</h2>
<div>[Video description begins] <em>Topic title: Adjacency Matrix Graph: Operations. Your host for this session is Janani Ravi.</em> [Video description ends] <br /><br />[Video description begins] <em>The Eclipse IDE interface displays. The Main.java file is currently active in the editor pane.</em> [Video description ends]
<p>We are now ready to head over to main.java and start testing out our adjacency matrix representation of a graph. The first thing that I&#39;ll do is instantiate a graph with eight vertices. Observe that the data type of my graph variable is the graph interface, but the graph representation I set to be the adjacency matrix representation. <br /><br />[Video description begins] <em>Line 7 reads as: Graph graph &#61; new AdjacencyMatrixGraph(8);.</em> [Video description ends] <br /><br />I instantiate a new adjacency matrix graph. Then I go ahead and add in a bunch of edges. Remember, this adjacency matrix at this point in time only represents unweighted directed graphs.Â <br /><br />[Video description begins] <em>She highlights the lines of code from line 9 to line 21.</em> [Video description ends] <br /><br />You can see the edges that we have here, node 1 has an edge to 0 to 5, node 3 has an edge to 4, and so on. <br /><br />[Video description begins] <em>Line 9 reads as: graph.addEdge(1, 0);. Line 10 reads as: graph.addEdge(1, 2);. Line 11 reads as: graph.addEdge(1, 5);.</em> [Video description ends] <br /><br />And at the end I call graph.displayGraph in order to display the representation of this graph. <br /><br />[Video description begins] <em>Line 13 reads as: graph.addEdge(3, 4);.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 23 reads as: graph.displayGraph();.</em> [Video description ends]</p>
<p>Go ahead and run this code and let&#39;s take a look at the graph that we&#39;ve just created. Here is the adjacency matrix representation. The first row here corresponds to vertex 0. There are no outgoing edges from vertex 0, you can see that the first row contains all 0s. The second row in this adjacency matrix corresponds to vertex 1. Vertex 1 has three outgoing edges to vertex 0, 2, and 5. And you can see 1s are assigned to those matrix cells. Display graph also prints out for each vertex, all of the adjacent matrices. <br /><br />You can see that the vertex 0 has no outgoing edges, so no adjacent vertices. Vertex 2 has three outgoing edges to vertex 3, 4, and 7. This is what we had set up in our code as well. We can now test out some of the other graph operations that we had set up. Let&#39;s test out the Indegree operation. For each of the nodes 1, 3, and 5, I&#39;m going to call graph.getIndegree to see the indegree of that node. <br /><br />[Video description begins] <em>She highlights a section of code in line 23, that reads as: graph.getIndegree(1));.</em> [Video description ends] <br /><br />When you run this code, you&#39;ll see that node 1 has an indegree of 0. If you look at the edges that we added to our graph, there is no edge which has destination node 1. So no inward bound edges for node 1. The indegree of node 3 is 2. If you look at the graph structure, you can see that there are two nodes leading into node 3. The addEdge calls on line 17 and 21 are both edges leading into 3.<br /><br />[Video description begins] <em>Line 17 reads as: graph.addEdge(2, 3);. Line 21 reads as: graph.addEdge(6, 3);.</em> [Video description ends]<br /><br />And indegree of 5 is 1, there&#39;s only one edge that leads to 5. We can now test this graph out further. For the graph that we have set up, I want to find vertices adjacent to node 1, 2, 5, and 7 and I invoke graph.getAdjacentVertices for each of these nodes. <br /><br />[Video description begins] <em>She replaces the lines of code from line 23 to 27 and adds new lines of code from line 23 to 29. She highlights a section of code in line 23, that reads as: graph.getAdjacentVertices(1));.</em> [Video description ends] <br /><br />Let&#39;s run this code and see what the results look like. Adjacent vertices are those which are connected by an edge from the current vertex. So vertices adjacent to 1 are 0, 2, and 5, and if you look at our graph construction, you can see that there exist edges from node 1 to 0, 2 and, 5. Next we look at vertices adjacent to 2. If you look at code on lines 15 through 17, you can see that there is an edge from node 2 to nodes 7, 4, and 3, and those are the adjacent vertices.<br /><br />[Video description begins] <em>Line 15 reads as: graph.addEdge(2, 7);. Line 16 reads as: graph.addEdge(2, 4);.</em> [Video description ends] <br /><br />Vertex 5 is adjacent to vertex 6. There is an edge from 5 to 6 as you can see based on the code on line 19. And finally, there are no vertices adjacent to 7.<br /><br />[Video description begins] <em>Line 19 reads as: graph.addEdge(5, 6);.</em> [Video description ends]</p></div>
</div>
<div>
<h2 id="e764b8e3-ecdf-4848-968c-4f9e8a601df7">
Adjacency Matrix Graph: Directed and Undirected
</h2>
<div>[Video description begins] <em>Topic title: Adjacency Matrix Graph: Directed and Undirected. Your host for this session is Janani Ravi.</em> [Video description ends] <br /><br />[Video description begins] <em>The Eclipse IDE interface displays. The Graph.java file is currently active in the editor pane.</em> [Video description ends]
<p>Now, let&#39;s improve our graph interface and graph implementation just a little bit. We&#39;ll now have this graph support both undirected and directed graphs. For this, we need to add in an additional enum here called GraphType. This enum has two values, directed and undirected. And we&#39;ll use this enum to specify the kind of graph that we want to build up.Â <br /><br />[Video description begins] <em>Line 7 reads as: enum GraphType{. Line 9 reads as: DIRECTED,. Line 11 reads as: UNDIRECTED. Line 12 reads as: }.</em> [Video description ends] <br /><br />Now, with this change in the interface, we need to change our adjacency matrix representation as well.<br /><br />[Video description begins] <em>She switches to the AdjacencyMatrixGraph.java file in the editor pane.</em> [Video description ends] <br /><br />The main changes will be in the constructor of this adjacency matrix graph and in the addEdge method. So go ahead, and let&#39;s change the code. The constructor now takes in two input arguments, numVertices as it did before, and an additional graphType. We assign numVertices to the numVertices member variable. <br /><br />[Video description begins] <em>Line 15 reads as: public AdjacencyMatrixGraph(int numVertices, GraphType graphType) {.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 17 reads as: this.numVertices &#61; numVertices;.</em> [Video description ends] <br /><br />And we have a new member variable called graphType to hold the type of graph that we want to represent, undirected or directed. The rest of the code in the constructor remains the same. <br /><br />[Video description begins] <em>Line 18 reads as: this.graphType &#61; graphType;.</em> [Video description ends] <br /><br />We instantiate the adjacency matrix with numVertices, rows, and columns, and set all of the cell values to be equal to 0 using nested for loops. <br /><br />[Video description begins] <em>Line 20 reads as: this.adjacencyMatrix &#61; new int[numVertices] [numVertices];.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 22 reads as: for (int i &#61;0; i&lt; numVertices; i&#43;&#43;) {. Line 24 reads as: for (int j &#61;0; j&lt; numVertices; j&#43;&#43;) {. Line 25 reads as: adjacencyMatrix[i][j] &#61; 0;. Line 26 reads as: }. Line 27 reads as: }.</em> [Video description ends] <br /><br />The next change will be in the addEdge method. addEdge continues to take in two input arguments, v1 and v2.<br /><br />[Video description begins] <em>Line 31 reads as: public void addEdge(int v1, int v2) {.</em> [Video description ends] <br /><br />This is a change in the implementation based on whether we have a directed or an undirected graph, we&#39;ll set different cell values. We&#39;ll first perform the simple check to see if v1 and v2 are valid vertices. <br /><br />[Video description begins] <em>Line 33 reads as: if (v1 &gt;&#61; numVertices || v2 &gt;&#61; numVertices || v1 &lt; 0 || v2 &lt; 0) {. Line 35 reads as: throw new IllegalArgumentException(&#34;Vertex number is not valid&#34;);.</em> [Video description ends]<br /><br />If the current graphType is equal to undirected, when we add an edge from v1 to v2, we&#39;ll also add an edge from v2 to v1. <br /><br />[Video description begins] <em>Line 38 reads as: if (graphType &#61;&#61; GraphType.UNDIRECTED) {.</em> [Video description ends] <br /><br />So if GraphType is equal to undirected adjacency matrix of v2, v1 is set to 1. And in either case, whether it&#39;s a directed or an undirected graph, we always set the cell v1, v2 to be equal to 1. <br /><br />[Video description begins] <em>Line 39 reads as: adjacencyMatrix[v2][v1] &#61; 1;.</em> [Video description ends]<br /><br />This we do on line 42. The extra bit of code here is on lines 38 to 40. <br /><br />[Video description begins] <em>Line 42 reads as: adjacencyMatrix[v1][v2] &#61; 1;.</em> [Video description ends]<br /><br />If the graph type is undirected, we always add an edge from v2 to v1 in addition to v1 to v2. And this is all the change that we need to make in order to have our adjacency matrix graph representation, support both directed as well as undirected graphs.</p>
<p>Now, that we&#39;ve made the changes, we can head over to main.java and instantiate a new graph and test it out. Now, when we instantiate a graph, we need to explicitly specify whether it&#39;s directed or undirected. Here is the same graph that we had earlier. That time it was an implicitly directed graph. Here, I&#39;ve explicitly specified that it&#39;s a directed graph on line 7. <br /><br />[Video description begins] <em>Line 7 reads as: Graph graph &#61; new AdjacencyMatrixGraph(8, Graph.GraphType.DIRECTED);.</em> [Video description ends] <br /><br />The remaining lines of code here I add the edges between the vertices in my graph and then display the graph that I have constructed. Let&#39;s run this code and take a look. Here is the adjacency matrix representation of the graph, we are familiar with this. <br /><br />[Video description begins] <em>She highlights the lines of code from line 9 to line 21. Line 23 reads as: graph.displayGraph();.</em> [Video description ends] <br /><br />And if you scroll down, you&#39;ll find for every vertex all of the adjacent vertices. For example, here, the code on line 13 explicitly adds an edge from node 3 to node 4. <br /><br />[Video description begins] <em>Line 13 reads as: graph.addEdge(3, 4);.</em> [Video description ends] <br /><br />So you can see in the console output that there is an edge from 3 to 4. Vertex 4 is adjacent to vertex 3. I&#39;m now going to make one little change here to this graph. This is currently a directed graph, I&#39;m going to change this graph to be an undirected graph. I&#39;m going to keep all of the other operations the same. <br /><br />[Video description begins] <em>Line 7 reads as: Graph graph &#61; new AdjacencyMatrixGraph(8, Graph.GraphType.UNDIRECTED);.</em> [Video description ends] <br /><br />I&#39;m going to add all of the same edges, except that now these edges are going to be added to an undirected graph. If you run this code now, you&#39;ll find that the structure of the graph looks very different. Observe that the first row of the adjacency matrix corresponding to vertex 0 has an entry now. There is an edge from vertex 0 to vertex 1. How did this edge get there? Remember, that on line 9, we&#39;ve added an edge from vertex 1 to 0. Because this is an undirected graph, an edge was automatically added from vertex 0 to 1. If you scroll down below and take a look at the vertices adjacent to each vertex in our graph, you will see that there are many more entries now. <br /><br />[Video description begins] <em>Line 9 reads as: graph.addEdge(1, 0);.</em> [Video description ends]<br /><br />Let&#39;s consider the vertex 4. Earlier 4 had no adjacent vertices, but now it has 2, both the nodes 2 and 3 are adjacent to 4. That&#39;s because when we added an edge from 3 to 4, an edge was automatically added from 4 to 3, this is on line 13. And when we added an edge from 2 to 4 on line 16, an edge was automatically added from 4 to 2. <br /><br />[Video description begins] <em>Line 16 reads as: graph.addEdge(2, 4);.</em> [Video description ends] <br /><br />Let&#39;s perform some other operations and see how they work for this undirected graph. Let&#39;s start off with getIndegree. We&#39;ll display the indegrees of nodes 1, 3 and 5 here.<br /><br />[Video description begins] <em>Line 23 reads as: System.out.println(&#34; \nIndegree of 1:&#34; &#43; graph.getIndegree(1));. In the similar way, code for value 3 and 5 is written.</em> [Video description ends] <br /><br />When you run this code once again, you&#39;ll see a difference. Earlier the indegree of node 1 was 0, but now it&#39;s 3. That&#39;s because for every outgoing edge that we added from 1, which we did on lines 9 through 11 in our code, an incoming edge was added as well giving us an indegree of 3. <br /><br />[Video description begins] <em>Line 10 reads as: graph.addEdge(1, 2);. Line 11 reads as: graph.addEdge(1, 5);.</em> [Video description ends]</p>
<p>Consider the vertex 5, the Indegree of 5 is 2, earlier in a directed graph it was 1. That&#39;s because we have an outgoing edge from 1 to 5. That gives us 1 edge that is directed into 5. This is on line 11 and observe on line 19, we have an edge from 5 to 6, which will add a reverse edge from 6 to 5 as well. This gives us indegree of 5 equal to 2. Let&#39;s move on to testing another operation on this undirected graph. We&#39;ll get the adjacent vertices for nodes 1, 2, 6 and 7 using graph.getAdjacentVertices. Let&#39;s run this code and see what the result looks like. <br /><br />[Video description begins] <em>She removes the lines of code from line 23 to 27 and adds new lines of code from line 23 to 29. Line 23 reads as: System.out.println(&#34; \nVertices adjacent to 1:&#34; &#43; graph.getAdjacentVertices(1));. In the similar way, code for value 2, 6 and 7 is written.</em> [Video description ends] <br /><br />For vertex 1, we have adjacent vertices 0, 2, and 5. No change here between an undirected and directed graph. Let&#39;s take a look at vertex 2, adjacent vertices are 1, 3, 4, 7. The code on lines 15, 16, and 17 have added outgoing edges from vertex 2 to 7, 4, and 3. And the code on line 10 where we add an outgoing edge from vertex 1 to 2 adds a reverse edge as well from 2 to 1. And this is why 1 is a vertex that is adjacent to 2. Notice that 2 is adjacent to 7. When we add an edge from node 2 to 7, on line 15 an edge is added from 7 to 2 as well.</p></div>
</div>
<div>
<h2 id="bf52a293-8ba8-481f-99f5-9b7b99d3b32c">
Adjacency Matrix Graph: Weighted Graphs
</h2>
<div>[Video description begins] <em>Topic title: Adjacency Matrix Graph: Weighted Graphs. Your host for this session is Janani Ravi.</em> [Video description ends] <br /><br />[Video description begins] <em>The Eclipse IDE interface displays. The Graph.java file is currently active in the editor pane.</em> [Video description ends]
<p>Our graph interface and our adjacency matrix representation so far does not support weighted graphs where we have weights associated with edges, let&#39;s fix that. We have the one method here in the graph interface to add an edge between nodes v1 and v2. <br /><br />[Video description begins] <em>Line 14 reads as: void addEdge(int v1, int v2);.</em> [Video description ends]<br /><br />I&#39;m going to put in an additional method, addEdge, which takes in the weight of the edge as well. <br /><br />[Video description begins] <em>Line 18 reads as: void addEdge(int v1, int v2, int weight);.</em> [Video description ends] <br /><br />This additional method also called addEdge takes as input arguments v1, v2 and the weight of the edge. For an undirected graph, we make the assumption here that the weight in both directions is the same. With this change in the graph interface, we need to change our adjacency matrix representation as well to account for this new addEdge method. In order to not rewrite the same code twice, I have rewritten the original addEdge method as well, which only takes input arguments v1 and v2 with no weight. The addEdge implementation on line 31 for unweighted graphs simply invokes addEdge with a weight of 1. I&#39;ve moved all of the logic for addEdge to the addEdge which takes in v1, v2, and a integer weight corresponding to the edge. <br /><br />[Video description begins] <em>Line 31 reads as: void addEdge(int v1, int v2) {. Line 32 reads as: addEdge(v1, v2, 1);. Line 33 reads as: }.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 36 reads as: void addEdge(int v1, int v2, int weight) {.</em> [Video description ends] <br /><br />The first if statement here is basically a check to see whether the input vertices are valid. If they&#39;re not valid, we throw illegal argument exception. <br /><br />[Video description begins] <em>Line 38 reads as: if (v1 &gt;&#61; numVertices || v2 &gt;&#61; numVertices || v1 &lt; 0 || v2 &lt; 0) {. Line 40 reads as: throw new IllegalArgumentException(&#34;Vertex number is not valid&#34;);. Line 41 reads as: }.</em> [Video description ends] <br /><br />The only change here that accounts for the weight of the edge is what value we assign to the cell corresponding to the edge from v1 to v2. Observe that on line 43, we assign the weight to the adjacencyMatrix cell. <br /><br />[Video description begins] <em>Line 43 reads as: adjacencyMatrix[v1][v2] &#61; weight;.</em> [Video description ends] <br /><br />This indicates that we have a weighted edge with a weight value equal to weight from v1 to v2. If this is an undirected graph, we&#39;ll add an edge from v2 to v1 as well and this reverse edge has the same weight.<br /><br />[Video description begins] <em>Line 45 reads as: if (graphType &#61;&#61; GraphType.UNDIRECTED) {. Line 46 reads as: adjacencyMatrix[v2][v1] &#61; weight;. Line 47 reads as: }.</em> [Video description ends] <br /><br />This is the code on line 46. This is really the only change that you need to make in the adjacency matrix graph representation. We are now ready to head over to main.java and test out a weighted graph. I&#39;ve instantiated a new adjacency matrix graph here with eight nodes, this is an undirected graph.<br /><br />[Video description begins] <em>Line 7 reads as: Graph graph &#61; new AdjacencyMatrixGraph(8, Graph.GraphType.UNDIRECTED);.</em> [Video description ends] <br /><br />I&#39;ve then invoke the addEdge method and for each pair of edges I&#39;ve specified a weight. For example, I have an edge from node 1 to node 0 with a weight of 2. I have an edge from node 1 to node 2 with a weight of 1. I have a few addEdge invocations with no weight specified.<br /><br />[Video description begins] <em>Line 9 reads as: graph.addEdge(1, 0, 2);. Line 10 reads as: graph.addEdge(1, 2, 1);. Line 11 reads as: graph.addEdge(1, 5, 3);.</em> [Video description ends] <br /><br />The weight for those edges is assumed to be 1. <br /><br />[Video description begins] <em>Line 13 reads as: graph.addEdge(3, 4);. Line 15 reads as: graph.addEdge(2, 7);. Line 16 reads as: graph.addEdge(2, 4);.</em> [Video description ends]<br /><br />Undirected edges between 3 and 4, 2 and 7, 2 and 4, all have weights equal to 1. Let&#39;s go ahead, display this graph, and see what this graph looks like. Notice that the adjacency matrix representation now contains cell entries that have values other than 1. In this undirected graph in the first row here, corresponding to vertex 0, there is an edge from 0 to 1. This edge has weight 2 and the entry in that row corresponding to this edge is 2. The rest of the code remains the same here, there is no change to the adjacent vertices for individual nodes in this graph. Adding weights to edges does not change which node is adjacent to which other node. If you change this graph type, so that it&#39;s no longer an undirected graph, instead it is a directed graph, things will change a little bit. The edges that exist in our matrix will be different.<br /><br />[Video description begins] <em>Line 7 reads as: Graph graph &#61; new AdjacencyMatrixGraph(8, Graph.GraphType.DIRECTED);.</em> [Video description ends] <br /><br />Now, there is no longer an edge from node 0 to node 1, but there does exist an edge of weight 2 from node 1 to node 0. Changing to a directed graph also changes which nodes are adjacent to a particular node. For example, node 7 now has no adjacent vertices because there is no outgoing edge from node 7 to any other node.</p></div>
</div>
<div>
<h2 id="8ae50013-169b-4d1c-91aa-64221a8a2ce3">
Representing Graphs Using an Adjacency List
</h2>
<div>[Video description begins] <em>Topic title: Representing Graphs Using an Adjacency List. Your host for this session is Janani Ravi.</em> [Video description ends] <br /><br />[Video description begins] <em>The Eclipse IDE interface displays. The Graph.java file is currently active in the editor pane.</em> [Video description ends]
<p>Using the same graph interface that we&#39;ve worked with earlier, we&#39;ll now implement the graph data structure as an adjacencyList. Notice we have the GraphType enum here supporting both DIRECTED and UNDIRECTED graphs.<br /><br />[Video description begins] <em>Line 7 reads as: enum GraphType{. Line 9 reads as: DIRECTED,. Line 11 reads as: UNDIRECTED. Line 12 reads as: }.</em> [Video description ends] <br /><br />And to start off with, in order to keep things simple, I&#39;m only going to consider unweighted graphs. Graphs where all of the edges have the same weight equal to one. So I have just one addEdge method here which takes in two vertices, v1 and v2.<br /><br />[Video description begins] <em>Line 14 reads as: void addEdge(int v1, int v2);.</em> [Video description ends]<br /><br />In order to represent a graph in the form of an adjacencyList, we need to set up a new class. This is a class called Vertex.java, and this vertex is what we&#39;ll use to represent a vertex or a node in our graph data structure. Here is the public class vertex. Set up the import statements needed by this vertex class, java.util.ArrayList and java.util.List. <br /><br />[Video description begins] <em>Line 3 reads as: import java.util.ArrayList;. Line 4 reads as: import java.util.List;.</em> [Video description ends] <br /><br />This vertex class is a fairly simple class and this is what we&#39;ll use to represent one node or one vertex in our graph data structure.<br /><br />[Video description begins] <em>Line 6 reads as: public class Vertex {.</em> [Video description ends]</p>
<p>Every vertex is identified using a unique vertex number, which is a private member variable of this class. <br /><br />[Video description begins] <em>Line 8 reads as: private int vertexNumber;.</em> [Video description ends] <br /><br />And the IDs of all vertices adjacent to the current vertex is stored in a list the adjacencyList. <br /><br />[Video description begins] <em>Line 10 reads as: private List&lt;Integer&gt; adjacencyList &#61; new ArrayList&lt;&gt;();.</em> [Video description ends] <br /><br />This is what makes the representation of this graph an adjacencyList representation, the fact that we are using an adjacencyList to store the list of adjacent elements. The adjacencyList is initially empty. When we instantiate a new vertex, we only specify the unique number associated with that vertex.<br /><br />[Video description begins] <em>Line 12 reads as: public Vertex(int vertexNumber) {. Line 13 reads as: this.vertexNumber &#61; vertexNumber;. Line 14 reads as: }.</em> [Video description ends] <br /><br />We can access this vertex number using getVertexNumber. If you want to add a new edge to this vertex, you&#39;ll invoke the addEdge method and specify the vertexNumber of the destination node or vertex.<br /><br />[Video description begins] <em>Line 20 reads as: public void addEdge(int vertexNumber) {.</em> [Video description ends] <br /><br />And this under the hood will simply add to the adjacencyList of the current vertex.<br /><br />[Video description begins] <em>Line 21 reads as: adjacencyList.add(vertexNumber);.</em> [Video description ends]<br /><br />If you want a list of all of the AdjacentVertices you&#39;ll invoke, getAdjacentVertices within which we&#39;ll simply return the adjacencyList.<br /><br />[Video description begins] <em>Line 24 reads as: public List&lt;Integer&gt; getAdjacentVertices() {. Line 25 reads as: return adjacencyList;.</em> [Video description ends]<br /><br />With the vertex node setup, we are now ready to create a new class for the adjacencyList representation of our graph. Create a new class called AdjacencyListGraph. First we&#39;ll set up the import statements needed within this class, java.util.ArrayList and java.util.List. And we&#39;ll also have this AdjacencyListGraph implement the Graph interface.<br /><br />[Video description begins] <em>Line 6 reads as: public class AdjacencyListGraph implements Graph {.</em> [Video description ends] <br /><br />Every graph representation that we create has to support all of the methods in the graph interface. Next up, let&#39;s set up the member variables and the constructor for this AdjacencyListGraph. Notice that we have a member variable called vertexList, which is a list of vertex objects. This is what we&#39;ll use to represent each vertex in this graph.<br /><br />[Video description begins] <em>Line 8 reads as: private List&lt;Vertex&gt; vertexList &#61; new ArrayList&lt;&gt;();.</em> [Video description ends] <br /><br />Remember, each vertex has a reference to all of the adjacentVertices. We have the numVertices variable initialized to 0, and the graph type by default is set to DIRECTED.<br /><br />[Video description begins] <em>Line 10 reads as: private int numVertices &#61; 0;. Line 12 reads as: private GraphType graphType &#61; GraphType.DIRECTED;.</em> [Video description ends] <br /><br />Take a look at the constructor of this AdjacencyListGraph, we pass in numVertices as an input argument and the GraphType.<br /><br />[Video description begins] <em>Line 14 reads as: public AdjacencyListGraph(int numVertices, GraphType graphType) {.</em> [Video description ends] <br /><br />numVertices we assign to the member variable. <br /><br />[Video description begins] <em>Line 15 reads as: this.numVertices &#61; numVertices;.</em> [Video description ends] <br /><br />We iterate over the number of vertices and add to the vertexList a new Vertex object for each of the Vertices that we&#39;ve specified.<br /><br />[Video description begins] <em>Line 17 reads as: for (int i &#61;0; i&lt; numVertices; i&#43;&#43;) {. Line 18 reads as: vertexList.add(new Vertex(i));. Line 19 reads as: }.</em> [Video description ends]</p>
<p>At this point, this graph contains no edges, we&#39;ve only set up the vertices. The first method that we&#39;ll implement here is the addEdge method, it takes in 2 vertex numbers, v1 and v2.<br /><br />[Video description begins] <em>Line 25 reads as: public void addEdge(int v1, int v2) {.</em> [Video description ends] <br /><br />First, we perform an if condition to check whether v1 and v2 are valid vertices. If they are valid, the edge can be added.<br /><br />[Video description begins] <em>Line 27 reads as: if (v1 &gt;&#61; numVertices || v1 &lt; 0 || v2 &gt;&#61; numVertices|| v2 &lt; 0) {. Line 28 reads as: throw new IllegalArgumentException(&#34;Vertex number is not valid:&#34; &#43; v1 &#43; &#34;, &#34; &#43; v2);. Line 29 reads as: }.</em> [Video description ends] <br /><br />In order to add an edge from v1 to v2, we&#39;ll access the vertex object corresponding with v1 using vertexList.get v1 and then add v2 as an edge to this vertex.<br /><br />[Video description begins] <em>Line 31 reads as: vertexList.get(v1).addEdge(v2);.</em> [Video description ends] <br /><br />If this happens to be an UNDIRECTED graph, we&#39;ll add an edge from v2 to v1 as well. We&#39;ll access the vertexList, get the vertex object associated with v2, and add an edge to v1.<br /><br />[Video description begins] <em>Line 33 reads as: if (graphType &#61;&#61; GraphType.UNDIRECTED) {. Line 34 reads as: vertexList.get(v2).addEdge(v1);. Line 35 reads as: }.</em> [Video description ends] <br /><br />Accessing the AdjacentVertices is a very simple operation in the adjacencyList representation. <br /><br />[Video description begins] <em>Line 39 reads as: public List&lt;Integer&gt; getAdjacentVertices(int v) {.</em> [Video description ends] <br /><br />We check that the vertex passed in is a valid one. And if it is, we access the vertex object associated with v and call getAdjacentVertices on the vertex object.<br /><br />[Video description begins] <em>Line 41 reads as: if (v &gt;&#61; numVertices || v &lt; 0) {. Line 42 reads as: throw new IllegalArgumentException(&#34;Vertex number is not valid:&#34; &#43; v);. Line 43 reads as: }. Line 45 reads as: return vertexList.get(v).getAdjacentVertices();.</em> [Video description ends] <br /><br />That will simply return the adjacencyList associated with that vertex. The next method that we&#39;ll implement from the graph interface is the getIndegree. <br /><br />[Video description begins] <em>Line 49 reads as: public int getIndegree(int v) {.</em> [Video description ends]</p>
<p>Now this method is a little more tricky because we only have a one-way mapping from a vertex to its adjacent nodes. And we need to figure out the reverse mapping. Initialize the indegree to be equal to 0, and then iterate over every vertex object in our vertexList. <br /><br />[Video description begins] <em>Line 51 reads as: int indegree &#61; 0;.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 53 reads as: for (Vertex vertex : vertexList) {.</em> [Video description ends] <br /><br />If we find that for a particular vertex object, its list of AdjacentVertices contains the current vertex v, then there is an incoming edge from that vertex to the current vertex v. We increment indegree by one indegree&#43;&#43;. <br /><br />[Video description begins] <em>Line 55 reads as: if (vertex.getAdjacentVertices().contains(v)) {. Line 57 reads as: indegree&#43;&#43;;.</em> [Video description ends] <br /><br />Once we&#39;ve checked all nodes of the graph for incoming edges to this current node, we return the value stored indegree. <br /><br />[Video description begins] <em>Line 60 reads as: return indegree;.</em> [Video description ends]<br /><br />And here are two more methods from the graph interface to implement. getNumVertices which simply returns the value in the numVertices variable, and displayGraph which iterates over every vertex in the vertexList and prints out the adjacentVertices. <br /><br />[Video description begins] <em>Line 64 reads as: public int getNumVertices() {. Line 65 reads as: return numVertices;. Line 66 reads as: }.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 69 reads as: public void displayGraph() {. Line 72 reads as: for (Vertex vertex : vertexList) {. Line 74 reads as: List&lt;Integer&gt; adjacentVertices &#61; vertex.getAdjacentVertices();. Line 76 reads as: System.out.println( &#34; Edges from &#34; &#43;vertex.getVertexNumber() &#43; &#34; to : &#34; &#43; adjacentVertices);.</em> [Video description ends]<br /><br />This is the adjacencyList representation. Having written the code for the adjacencyList graph, let&#39;s get ready to test it out. Here I am in Main.java and I have instantiated an AdjacencyListGraph with 8 nodes. This is a directed graph. I then use the addEdge method to specify the edges that make up my graph. <br /><br />[Video description begins] <em>Line 7 reads as: Graph graph &#61; new AdjacencyListGraph(8, Graph.GraphType.DIRECTED);.</em> [Video description ends] <br /><br />All of these are unweighted edges. We haven&#39;t gone to the weighted representation yet.<br /><br />[Video description begins] <em>She highlights the lines of code from line 9 to line 21.</em> [Video description ends] <br /><br />Run this code and let&#39;s take a look at what this graph looks like. Here&#39;s the Adjacency List. There are no vertices adjacent to node 0, vertices 0, 2 and 5 are adjacent to node 1. You can see that we have addEdge statements which set these up, the code on lines nine through 11. <br /><br />[Video description begins] <em>Line 9 reads as: graph.addEdge(1, 0);. Line 10 reads as: graph.addEdge(1, 2);. Line 11 reads as: graph.addEdge(1, 5);.</em> [Video description ends] <br /><br />Node 6 is adjacent to node 5, there is an edge from 5 to 6, as specified on line 19.<br /><br />[Video description begins] <em>Line 19 reads as: graph.addEdge(5, 6);.</em> [Video description ends] <br /><br />DIRECTED graph seemed to work fine. Let&#39;s change this DIRECTED graph to be an UNDIRECTED graph and see how our adjacencyList representation works. <br /><br />[Video description begins] <em>Line 7 reads as: Graph graph &#61; new AdjacencyListGraph(8, Graph.GraphType.UNDIRECTED);.</em> [Video description ends] <br /><br />Run this code and you can immediately see that the number of adjacent edges seem to have shot up. Every edge now is a bi-directional edge. Notice that there is an edge from 0 to 1 which we haven&#39;t explicitly specified. But when we add an edge from 1 to 0 on line 9, the edge in the opposite direction is automatically added. Another example here is the edge from node 7 to 2. 2 is adjacent to 7, this is because we&#39;ve added an edge on line 15 from 2 to 7.<br /><br />[Video description begins] <em>Line 15 reads as: graph.addEdge(2, 7);.</em> [Video description ends]<br /><br />And in an undirected graph, this means that the edge from 7 to 2 is automatically added. So far, things look good. Let&#39;s quickly test some of the other operations for an adjacencyList representation of a graph. We&#39;ll work with an undirected graph, and we&#39;ll test out the getIndegree function to make sure that it works correctly. We&#39;ll get the indegrees of nodes 1, 3 and 5, run this code and let&#39;s take a look at the result here. <br /><br />[Video description begins] <em>Line 23 reads as: System.out.println(&#34; \nIndegree of 1:&#34; &#43; graph.getIndegree(1 ));. In the similar way, code for 3 and 5 is written.</em> [Video description ends]<br /><br />The Indegree of node 1 is equal to 3. Now we have specified edges from node 1 to 0, 2 and 5 and edges in the reverse direction have automatically been added. So the indegree of 1 is 3, that is correct. One more check here, the indegree of node 3 is also 3. We have an edge on line 13 from 3 to 4, which means an edge in the reverse direction exists.<br /><br />[Video description begins] <em>Line 13 reads as: graph.addEdge(3, 4);.</em> [Video description ends] <br /><br />We have an edge from 2 going into 3, this we specified on line 17. And we have a third edge from 6 going into 3.<br /><br />[Video description begins] <em>Line 17 reads as: graph.addEdge(2, 3);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 21 reads as: graph.addEdge(6, 3);.</em> [Video description ends] <br /><br />So Indegree of 3 is 3, that is correct. One last test before we move on to weighted graphs. Let&#39;s see how getAdjacentVertices work. We&#39;ll calculate AdjacentVertices for nodes 1, 2, 6 and 7. <br /><br />[Video description begins] <em>She removes the lines of code from line 23 to 27 and adds new lines of code from line 23 to 29. Line 23 reads as: System.out.println(&#34; \nVertices adjacent to 1:&#34; &#43; graph.getAdjacentVertices(1 ));. In the similar way, code for 2, 6 and 7 is written.</em> [Video description ends]<br /><br />Let&#39;s work with one of these vertices here. Vertices adjacent to 2 are 1, 7, 4, 3. Now we can see on lines 15 through 17, we&#39;ve explicitly added 7, 4 and 3 as adjacent vertices by specifying an edge from 2 to these nodes. On line 10, we&#39;ve specified an edge from vertex 1 to 2, which means the reverse edge has been added as well, which is why 1 is adjacent to 2.</p></div>
</div>
<div>
<h2 id="1dd38615-448f-4063-a246-00c0274e5b81">
Adjacency List Graph: Weighted Graphs
</h2>
<div>[Video description begins] <em>Topic title: Adjacency List Graph: Weighted Graphs. Your host for this session is Janani Ravi.</em> [Video description ends] <br /><br />[Video description begins] <em>The screen displays an Eclipse IDE window. The context pane currently displays the Graph class. It contains multiple lines of code.</em> [Video description ends]
<p>In this demo, we&#39;ll change our graph interface to accept weighted edges and we&#39;ll update the adjacency list implementation as well. So we&#39;ll go ahead and add in a new method here, addEdge, which takes as input arguments v1, v2 and the weight of the edge. <br /><br />[Video description begins] <em>She highlights the code in line 18 which reads as: void addEdge(int 1, int v2, int weight);.</em> [Video description ends] <br /><br />Once we&#39;ve made this change, we&#39;ll also update our adjacency list representation to support weighted edges.<br /><br />[Video description begins] <em>She highlights the code in line 20 which reads as: List&lt;Vertex&gt; getAdjacentVertices(int v);.</em> [Video description ends] <br /><br />The first change will be in Vertex.java.<br /><br />[Video description begins] <em>The Vertex class displays in the context pane. It contains multiple lines of code.</em> [Video description ends]<br /><br />Vertex.java earlier represented all of the vertices in our graph and the adjacent nodes for each vertex.</p>
<p>Now every vertex we&#39;ll associate, not only with a unique vertex number, but also a weight, the weight of the edge that leads into this vertex.<br /><br />[Video description begins] <em>Line 8 reads as: private int vertexNumber;. Line 9 reads as private int weight;.</em> [Video description ends]</p>
<p>I&#39;ve added in an additional member variable weight associated with each vertex object.</p>
<p>Notice that we have updated how the adjacency list is specified as well. Rather than just being a list of adjacent vertex integers, it is a list of actual vertex objects. This change is needed because now every vertex, every adjacent vertex, also will have the weight associated with that edge.<br /><br />[Video description begins] <em>Line 11 reads as: private List&lt;Vertex&gt; adjacencyList &#61; new ArrayList&lt;&gt;();.</em> [Video description ends]</p>
<p>The constructor for the vertex has to be updated as well. <br /><br />[Video description begins] <em>She highlights the code from line 13 to line 17. Line 13 reads as: public Vertex(int vertexNumber, int weight) {. Line 15 reads as: this.vertexNumber &#61; vertexNumber;. Line 16 reads as: this.weight &#61; weight;. Line 17 reads as: }.</em> [Video description ends]<br /><br />It takes as an input argument the vertex number, your unique ID associated with the vertex, as well as the weight of the edge connecting to this vertex from an adjacent vertex. The vertex class has getters for both the vertex number as well as the weight of the edge connecting to this vertex.<br /><br />[Video description begins] <em>She highlights the code from line 19 to line 25. Line 19 reads as: public int getVertexNumber() {. Line 20 reads as: return vertexNumber;. Line 21 reads as: }. Line 23 reads as: public int getWeight() {. Line 24 reads as: return weight;. Line 25 reads as: }.</em> [Video description ends] <br /><br />The vertex object also exposes an addEdge method which we&#39;ll use to add adjacent nodes to this particular vertex. addEdge takes in the vertex number of the adjacent node, as well as the weight of the edge connecting this node with the adjacent node.</p>
<p>When we add the node to the adjacency list, we&#39;ll instantiate a new vertex object with this vertex number and weight. We won&#39;t be working only with vertex numbers.<br /><br />[Video description begins] <em>She highlights the code in lines 27, 28, and 29. Line 27 reads as: public void addEdge(int vertexNumber, int weight) {. Line 28 reads as: adjacencyList.add(new Vertex(vertexNumber, weight));. Line 29 reads as: }.</em> [Video description ends]<br /><br />getAdjacentVertices now returns a list of vertex objects. <br /><br />[Video description begins] <em>She highlights the code in lines 31, 32, and 33. Line 31 reads as: public List&lt;Vertex&gt; getAdjacentVertices(){. Line 32 reads: return adjacencyList;. Line 33 reads as: }.</em> [Video description ends]<br /><br />And finally, for the purposes of debugging, I have a two string representation of the vertex, which prints out the vertex number and the weight of the edge connecting this vertex object. <br /><br />[Video description begins] <em>She highlights the code in lines 35 and 36. Line 35 reads as: public String toString() {. Line 36 reads: return &#34;Vertex: &#34; &#43; vertexNumber &#43; &#34;weight: &#34; &#43; weight;.</em> [Video description ends] <br /><br />It&#39;s pretty clear that the vertex object now plays a completely different role here in this adjacency list representation of our graph. Each edge to a vertex will have a separate vertex object specifying the destination vertex number and the weight of that edge. So these vertex objects now no longer represent vertices, instead they represent edges. So another possible name for this object could have just been edge.</p>
<p>Now it&#39;s time for us to head over to our AdjacencyListGraph.java and update the code so that it now accepts weighted edges.<br /><br />[Video description begins] <em>The AdjacencyListGraph class displays in the context pane. It contains multiple lines of code.</em> [Video description ends]<br /><br />The member variables for the AdjacencyListGraph remain the same.<br /><br />[Video description begins] <em>She highlights the code in line 8 which reads as: private List&lt;Vertex&gt; vertexList &#61; new ArrayList&lt;&gt;();.</em> [Video description ends] <br /><br />I have a vertex list containing all of the vertices in this graph, numVertices &#61; 0, and the graph type is directed by default. <br /><br />[Video description begins] <em>She highlights the code in lines 10 and 12. Line 10 reads as: private int numVertices &#61; 0;. Line 12 reads as: private GraphType graphType &#61; GraphType.DIRECTED;.</em> [Video description ends] <br /><br />The constructor is also mostly the same, there is a change here in how we initialize the vertex list. <br /><br />[Video description begins] <em>She highlights multiple lines of code from line 14 to line 22.</em> [Video description ends] <br /><br />Observe the code on line 18. We add a new vertex object to represent the vertices with an edge weight of 0. <br /><br />[Video description begins] <em>Line 18 reads as: vertexList.add(new Vertex(i, 0));.</em> [Video description ends] <br /><br />Â So I have two uses for the vertex objects here. When they are used to represent the vertices in our graph, the edge weight is set to 0. When they are used to represent edges in our graph, we&#39;ll have a positive value for the edge weight.</p>
<p>We&#39;ve also updated the implementation of addEdge.<br /><br />[Video description begins] <em>She highlights the code in line 25 which reads as: public void addEdge(int 1, int v2){.</em> [Video description ends] <br /><br />The addEdge method, which does not take in weight as an input argument, simply invokes the addEdge method which accepts a weight as an input argument.<br /><br />[Video description begins] <em>She highlights the code in line 27 which reads as: addEdge(v1, v2, 1);.</em> [Video description ends] <br /><br />This is on line 27. In the addEdge method that accepts a weight as an input argument, the code should be familiar. [Video description begins] <em>She highlights multiple lines of code from line 30 to line 42.</em> [Video description ends] We always add an edge from v1 to v2. [Video description begins] <em>She highlights the code in line 37 which reads as: vertexList.get(v1).addEdge(v2, weight);.</em> [Video description ends] So vertexList.get v1 and addEdge v2 and specify the weight of the edge as well.</p>
<p>If the graph is an undirected graph, we add an edge in the reverse direction as well, from v2 to v1. This edge has the same weight that is our implicit assumption here. <br /><br />[Video description begins] <em>She highlights the code in lines 39, 40, and 41. Line 39 reads as: if (graphType &#61;&#61; GraphType.UNDIRECTED) {. Line 40 reads as: vertexList.get(v2).addEdge(v1, weight);. Line 41 reads as:}.</em> [Video description ends] <br /><br />The code for getAdjacentVertices remains the same, there is no change there. <br /><br />[Video description begins] <em>Line 45 reads as: public List&lt;Vertex&gt; getAdjacentVertices(int v){.</em> [Video description ends] <br /><br />There is a little bit of change in the code that we have to calculate the indegree of a node. <br /><br />[Video description begins] <em>She highlights multiple lines of code from line 54 to line 72.</em> [Video description ends] <br /><br />For any node v, start off with an indegree of 0, this part is the same.<br /><br />[Video description begins] <em>She highlights the code in line 57 that reads: int indegree &#61; 0;.</em> [Video description ends] <br /><br />We then iterate over all vertices in the vertex list and get the list of adjacent vertices. <br /><br />[Video description begins] <em>She highlights the code in lines 59 and 61. Line 59 reads as: for (Vertex vertex : vertexList) {. Line 61 reads as: List&lt;Vertex&gt; AdjacentVerticesList &#61; vertex.getAdjacentVertices();.</em> [Video description ends]</p>
<p>We then run another for loop over every adjacent vertex, and get the vertex number and compare that with the current vertex V. <br /><br />[Video description begins] <em>She highlights the code in line 62 that reads: for (Vertex adjacentVertex : adjacentVerticesList) {.</em> [Video description ends]<br /><br />Â [Video description begins] <em>She highlights the code in line 64 that reads: if (adjacentVertex.getVertexNumber() &#61;&#61; v) {.</em> [Video description ends] <br /><br />If there is a match, we increment indegree by 1 using indegree&#43;&#43;.<br /><br />[Video description begins] <em>She highlights the code in line 65 that reads: indegree&#43;&#43;;.</em> [Video description ends] <br /><br />The difference here is because the adjacent vertices are vertex objects and we need to explicitly compare with the vertex numbers. And finally, the last method in the graph interface, displayGraph, the code for this in this implementation remains the same. <br /><br />[Video description begins] <em>She highlights multiple lines of code from line 79 to line 91.</em> [Video description ends]</p>
<p>Let&#39;s go ahead head over to Main.java and test out this adjacency list representation for weighted graphs.<br /><br />[Video description begins] <em>Line 7 reads as: Graph graph &#61; new AdjacencyListGraph(8, Graph.GraphType.UNDIRECTED);.</em> [Video description ends]<br /><br />Here&#39;s my AdjacencyListGraph, with 8 nodes, it&#39;s an undirected graph. I&#39;ve added edges in here, I&#39;ve assumed that all edges have weight 1. Let&#39;s just run this code and make sure that our updated implementation for weighted graphs works correctly with unweighted graphs as well. <br /><br />[Video description begins] <em>She highlights multiple lines of code from line 9 to line 21. Line 9 reads as: graph.addEdge(1, 0);. The following lines follow the similar code style.</em> [Video description ends] <br /><br />Go ahead and run this code, and let&#39;s take a look at this graph. If you look at the representation of this graph, you can see that every adjacent node is associated with a weight.</p>
<p>And the weights of all edges here is equal to 1. That&#39;s because this is an unweighted graph. I&#39;m now going to update the code that I have here to explicitly associate a weight with every edge. You can see that I&#39;ve invoked the addEdge method. As an example, you can look at the edge that I&#39;ve added from node 1 to node 0, the edge weight is 2.<br /><br />[Video description begins] <em>She highlights multiple lines of code from line 9 to line 21. Line 9 reads as: graph.addEdge(1, 0, 2);. Line 10 reads as: graph.addEdge(1, 2, 1);. Line 11 reads as: graph.addEdge(1, 5, 3);.</em> [Video description ends]<br /><br />There are other addEdge invocations here where I haven&#39;t specified an edge weight, there the edge weight is assumed to be 1.<br /><br />[Video description begins] <em>She highlights multiple lines of code from line 13 to line 16. Line 13 reads as: graph.addEdge(3, 4);. Line 15 reads as: graph.addEdge(2, 7);. Line 16 reads as: graph.addEdge(2, 4);.</em> [Video description ends] <br /><br />Let&#39;s go ahead and display this graph and see whether our adjacency list representation manages to capture the information in this graph. Now our code on line 9 added an edge from 1 to 0 with a weight of 2.</p>
<p>Because this is an undirected graph, observe in the console window that there is an edge from 0 to node 1 with a weight of 2. This is the edge in the reverse direction. Another example, our code on line 17 added an edge from node 2 to 3 with a weight of 5. <br /><br />[Video description begins] <em>Line 17 reads as: graph.addEdge(2,3, 5);.</em> [Video description ends] <br /><br />If you look at edges from node 2, you can see that vertex 3 is present as an adjacent node, and the weight associated with vertex 3 and this edge is 5. We can see that undirected graphs with weighted edges seem to work fine. Let&#39;s change this GraphType to be DIRECTED and see what the results look like.<br /><br />[Video description begins] <em>Line 7 reads as: Graph graph &#61; new AdjacencyListGraph(8, Graph.GraphType.DIRECTED);.</em> [Video description ends]</p>
<p>Go ahead and run this code. If we consider this graph to be directed, you can see that there are no vertices adjacent to node 0. There are three vertices adjacent to node 1, having weights 2, 1, and 3.</p>
<p>There is one last operation that we&#39;ll test here before we move on from the adjacency list representation. I&#39;ll go back to an undirected weighted graph, and let&#39;s test out the code for getIndegree. We made changes to this code, it&#39;s important that we see that the graph works fine. We&#39;ll calculate the indegree of nodes 1, 3 and 5, and print these out to screen. <br /><br />[Video description begins] <em>She highlights multiple lines of code from line 23 to line 27. Line 23 reads as: System.out.println(&#34;\nIndegree of 1: &#34; &#43; graph.getIndegree(1));. Line 25 reads as: System.out.println(&#34;\nIndegree of 3: &#34; &#43; graph.getIndegree(3));. Line 27 reads as: System.out.println(&#34;\nIndegree of 5: &#34; &#43; graph.getIndegree(5));.</em> [Video description ends]</p>
<p>Go ahead and run this code, and the results look just fine. The indegree for node 1 is 3, we have 3 outgoing edges that we&#39;ve explicitly added from node 1, this is the code on lines 9, 10 and 11. Each of these edges have weights. Because this is an undirected graph, edges in the reverse direction have been added as well, giving us node 1 with an indegree of 3.</p></div>
</div>
<div>
<h2 id="ffb962ca-f34a-4392-8e5f-ced9484d8288">
Representing Graphs Using an Adjacency Set
</h2>
<div>[Video description begins] <em>Topic title: Representating Graphs Using an Adjacency Set. Your host for this session is Janani Ravi.</em> [Video description ends]<br /><br />We&#39;ve discussed earlier that adjacency lists are not really a preferred graph representation because with adjacency lists the same graph can have different representations based on the order of adjacent vertices in the adjacency list. A better way to represent the graph is to use the adjacency set representation. The only change that you have to make is to use a set to store adjacent vertices rather than a list. I&#39;ll quickly show you the changes here, we&#39;ll work with the same graph interface as before. One simplification, I no longer have the method to add weighted edges to this graph. So this is a graph representation only for unweighted graphs. I&#39;ll leave it to you as an exercise to figure out an adjacency set representation that works with weighted edges. It will be very similar to the adjacency list representation. Head over to Vertex.java and set up the import statements for the different libraries that we&#39;ll use. We&#39;ll use the ArrayList, the List interface, the HashSet, which we&#39;ll use to store the set of adjacent vertices, and the Set interface.<br /><br />[Video description begins] <em>A class labeled Vertex displays in the editor pane. She highlights the code in lines 3 to 6. Line 3 reads: import java.util.ArrayList;. Line 4 reads: import java.util.List;. Line 5 reads: import java.util.HashSet;. Line 6 reads: import java.util.Set;.</em> [Video description ends] <br /><br />You will find that the code within this vertex class hasn&#39;t changed much, every vertex is still associated with the vertexNumber. <br /><br />[Video description begins] <em>Line 10 reads as: private int vertexNumber;.</em> [Video description ends] <br /><br />The major change here is the adjacent vertices to this vertex is stored in an adjacencySet. Take a look at line 12 where we instantiated the adjacencySet. <br /><br />[Video description begins] <em>Line 12 reads as: private Set&lt;Integer&gt; adjacencySet&#61; new HashSet&lt;&gt;();.</em> [Video description ends] <br /><br />When we use the addEdge method to add an edge from the current vertex to a destination vertex, we&#39;ll add that vertex number to the adjacency set. This is the code on line 24.<br /><br />[Video description begins] <em>She highlights the code in lines 23 and 24. Line 23 reads as: public void addEdge(int vertexNumber) {. Line 24 reads as: adjacencySet.add(vertexNumber);.</em> [Video description ends] <br /><br />When we return the adjacent vertices to the current vertex, we do so in the form of a list. We simply convert the set to a list format and return that. <br /><br />[Video description begins] <em>She highlights the code in lines 27, 28 and 29. Line 27 reads as: public List&lt;Integer&gt; getAdjacentVertices(){. Line 28 reads: return new ArrayList &lt;&gt;(adjacencySet);. Line 29 reads as: }.</em> [Video description ends] <br /><br />We are now ready to create a new class to represent our graph using an adjacency set. The name of this class will be called AdjacenySetGraph. Once the class has been created, first set up the import statements that will be used within this class, this is the ArrayList and the List. <br /><br />[Video description begins] <em>A class labeled AdjacencySetGraph displays in the editor pane. She highlights the code in lines 3 and 4. Line 3 reads: import java.util.ArrayList;. Line 4 reads: import java.util.List;.</em> [Video description ends] <br /><br />Every graph representation implements the graph interface. So make sure the AdjacencySetGraph does as well.<br /><br />[Video description begins] <em>She highlights a section of the code in line 8 which reads as: public class AdjacencySetGraph implements Graph.</em> [Video description ends]<br /><br />Now I&#39;ve pasted in code in this class, which implements all of the methods of the graph interface. I won&#39;t go over this code in detail because we&#39;re already familiar with this code. The code in this class is exactly the same as the code in the AdjacencyListGraph.java, the adjacency list representation of the graph. The only change was in Vertex.java, where we changed the adjacent nodes to be stored in a set rather than a list. So now let&#39;s head over to Main.java and test out our AdjacencySetGraph, we&#39;ll do so fairly quickly. I&#39;ve instantiated an eight node AdjacencySetGraph, this is a directed graph.<br /><br />[Video description begins] <em>Line 7 reads as: Graph graph &#61; newAdjacencySetGraph (8, Graph.GraphType.DIRECTED);.</em> [Video description ends]<br /><br />I&#39;ve used addEdge to add the directed edges and then I&#39;ve invoked displayGraph. Run this code and let&#39;s take a look at the adjacency set representation. <br /><br />[Video description begins] <em>She highlights multiple lines of code from line 9 to line 21. Line 9 reads as: graph.addEdge(1, 0);. The following lines follow the similar code style. She also highlights the code in line 23 that reads: graph.displayGraph();.</em> [Video description ends]<br /><br />We&#39;ll check a few nodes at random. There is an edge from 5 to 6, that&#39;s what&#39;s been specified on line 19. There is an edge from 6 to 3, this I&#39;ve specified on line 21.<br /><br />[Video description begins] <em>Line 19 reads as: graph.addEdge(5, 6);.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 21 reads as: graph.addEdge(6, 3);.</em> [Video description ends] <br /><br />Things seem to look good so far. What if we were to change this graph so that its no longer a directed graph but instead is an undirected graph. <br /><br />[Video description begins] <em>Line 7 reads as: Graph graph &#61; newAdjacencySetGraph (8, Graph.GraphType.UNDIRECTED);.</em> [Video description ends] <br /><br />Make this change, run this code, and let&#39;s take a look at the resulting graph representation. Observe that nodes that are adjacent to node 6 are the nodes 3 and 5. If you look at our code, we&#39;ve explicitly added an edge from node 6 to 3, this is on line 21. And we&#39;ve added an edge from node 5 to 6, which means the edge in the opposite direction has been added as well, because this is an undirected graph. This is why nodes 3 and 5 are adjacent to 6. I&#39;ll leave it as an exercise for you to test out the other operations in this adjacency set representation such as getInDegree and getAdjacentVertices.</div>
</div>
<div>
<h2 id="b9eb7e10-e694-40dc-b417-3953cc18ca61">
Graph Traversal
</h2>
<div>[Video description begins] <em>Topic title: Graph Traversal. Your host for this session is Janani Ravi.</em> [Video description ends]
<p>In this video, we&#39;ll study how you can traverse all of the nodes in your graph. If you remember binary tree traversal from earlier in this learning path, you&#39;ll find that graph traversal is mostly the same. Now there are two techniques that you can use to traverse the nodes in the graph. The first is depth-first traversal, and the second is breadth-first traversal.</p>
<p>With depth-first traversal, you go deep before you go broad. With breadth-first traversal, you start traversing from a particular node and you radiate outwards, kind of in concentric circles. The basic idea behind both graph traversal algorithms are similar to the tree traversal algorithms. However, there is an additional wrinkle that you need to watch out for. In a tree there is just one path from the root node to a specific node in the tree. So as you traverse the nodes in a tree, once you encounter a node, you&#39;re not likely to encounter the same node once again.</p>
<p>In a graph there can exist multiple paths from one node to another. So between two nodes, you can have more than one path. Another thing that is different between tree traversal and graph traversal is the fact that a graph can have cycles. Remember, a tree is an acyclic graph. A graph with cycles can cause you to visit the same node more than once. This means you need to have a way to keep track of the nodes that you&#39;ve already visited.</p>
<p>Let&#39;s quickly summarize the difference between tree traversal and graph traversal. In a graph, multiple paths can lead from one node to another. Also, a graph can have cycles so the same node can be visited multiple times. This means that in order to avoid infinite looping in a graph where you go round and round in a cycle, you need to keep track of the nodes that you already visited using some kind of visited list. Let&#39;s consider an example here.</p>
<p>Here is an undirected graph with cycles. Let&#39;s perform depth-first traversal starting with the node 2. There is no clear root node we can perform traversal starting from any node. We start with the first child of node 2, let&#39;s say that is the node 1. We visit that node and we can&#39;t go any further. So we move on to the next child of node 2, which is the node 3. We visit node 3 and then we need to go deeper into the nodes that are connected to 3. Let&#39;s say the first connected node is node 5, we go ahead and visit 5 as well. We then need to go deeper, we go on and visit node 4. Given that this is depth-first traversal, we might say we need to explore other nodes connected to 4.</p>
<p>And we might end up visiting node 3 once again. Well, that shouldn&#39;t really be allowed because that will cause us to infinitely loop through this graph. Node 3 should not be visited again. In order to fix this we need to use a visited list to keep track of nodes that we&#39;ve already traversed or visited. A visited list is nothing fancy. It can be a simple Boolean array with an entry corresponding to each vertex in your graph. Initially, all nodes are unvisited.</p>
<p>You&#39;ll set visited equal to true for a particular node if the node has been seen. Once visited is equal to true, you won&#39;t process those nodes again. Going back to this graph, let&#39;s perform depth-first traversal once again, but this time we&#39;ll use a visited list. We start the traversal off on node 2. So we visited 2, we add this node to the visited list. From 2 we&#39;ll move on to node 1, and we&#39;ll visit this node. Once we&#39;ve visited this node, on goes 1 onto the visited list. There is nothing further to explore here, so we&#39;ll move on to node 3 and add 3 to the visited list. From 3, we&#39;ll go to node 5, add that to the visited list as well. From 5, we&#39;ll go deeper to node 4, and we&#39;ll add 4 to the visited list as well.</p>
<p>Now when we try to go deeper from node 4, we&#39;ll find that all adjacent nodes have already been visited. We&#39;ll stop the traversal. From depth-first traversal, let&#39;s move on to breadth-first traversal. In breadth-first traversal, we start at some node in the graph and we go level-wise from that first node. We&#39;ll add all of the non-visited child nodes of the node that we are currently traversing to a queue. We&#39;ll then dequeue them and perform breadth-first traversal. Just like in the case of the depth-first traversal that we saw earlier, we should use a visited list for breadth-first traversal as well.</p>
<p>This is what we&#39;ll use to keep track of nodes already visited. If visited is set to true, that means the node has been seen before. We won&#39;t process that node again. We&#39;ll start our breadth-first traversal from node 2. We&#39;ll visit this node and we&#39;ll add this node to our visited list as well. Now we&#39;ll go one level out and we&#39;ll visit node 1. Add that to the visited list. Let&#39;s now move on to the next node one level out, that is node 3 that is added to the visited list as well.</p>
<p>Moving on to the next node one level out from node 2, this is node 4, add that to the visited list. Now we&#39;ll move to node 5, that is one level further out from the node where we started processing. Add 5 to the visited list as well, and this completes our breadth-first traversal.</p></div>
</div>
<div>
<h2 id="7c468f4e-42b2-435e-ae5a-939720730ac6">
Breadth-first Traversal
</h2>
<div>[Video description begins] <em>Topic title: Breadth-first Traversal. Your host for this session is Janani Ravi.</em> [Video description ends] <br /><br />[Video description begins] <em>The screen displays an Eclipse IDE window. The Graph class displays in the main pane. It contains multiple lines of code.</em> [Video description ends]
<p>Now that we&#39;ve studied how graphs can be represented, let&#39;s see how we can perform different kinds of traversals on graphs. We&#39;ll work with the graph data structures that we have set up earlier. Here is the graph interface which supports both directed as well as undirected graphs with weighted edges as well as unweighted edges.<br /><br />[Video description begins] <em>She highlights multiple lines of code from line 7 to line 18.</em> [Video description ends] <br /><br />All of our graph traversal techniques will work with any graph representation but the simplest of all is the adjacency matrix representation. It&#39;s also the most intuitive, so that is the one that we&#39;ll choose to work with. Here&#39;s the adjacency matrix graph that implements the graph interface. The code in this class is exactly the same code that we&#39;ve worked with earlier.</p>
<p>There&#39;s nothing really new here. We know how this graph works. We&#39;ll keep our attention on graph traversal techniques. Head over to main.java, set up the import statements for the utilities that we&#39;ll need to perform breadth first traversal, a linked list, the list interface and the queue interface. And remember, the linked list implements the queue interface, and we&#39;ll need a queue for breadth first traversal. <br /><br />[Video description begins] <em>She highlights the code in lines 3 to 6. Line 3 reads: import java.util.LinkedList;. Line 4 reads: import java.util.List;. Line 5 reads: import java.util.Queue;.</em> [Video description ends]<br /><br />Now, we&#39;ve studied that breadth first traversal of a graph is very similar to the breadth first traversal of a binary tree, with an important difference. With a graph, you need to keep track of the nodes that you&#39;ve previously visited.</p>
<p>What I&#39;m going to do here is to show you how breadth first traversal works for a graph but I won&#39;t use a visited list to keep track of visited nodes. You&#39;ll find that we&#39;ll revisit nodes, again, even if they&#39;ve already been seen before, which is kind of wasteful, and doesn&#39;t really make sense. But it&#39;s important that you see that this happens, we&#39;ll then improve this code using a visited list.<br /><br />[Video description begins] <em>She highlights multiple lines of code from line 9 to line 26.</em> [Video description ends]<br /><br />Here, breadth first traversal takes as an input argument, the graph that we want to traverse and the vertex from which we should start our traversal, that is the current vertex.<br /><br />[Video description begins] <em>She highlights a section of the code on line 9 which reads as: breadthFirstTraversal(Graph graph, int currentVertex).</em> [Video description ends]<br /><br />A graph has no clear root node, you can start the traversal from any vertex. The first step is instantiate a queue.</p>
<p>This I do on line 11. I&#39;ve created a new linked list that we serve as my queue for breadth first traversal.<br /><br />[Video description begins] <em>Line 11 reads as: Queue&lt;Integer&gt; queue &#61; new LinkedList&lt;&gt;();.</em> [Video description ends] <br /><br />Whatever the current vertex is, from which I&#39;m going to start my traversal, I add to the queue on line 12, queue.add(currentVertex). <br /><br />[Video description begins] <em>Line 12 reads as: queue.add(currentVertex);.</em> [Video description ends] <br /><br />Next,we&#39;ll run a while loop that will run so long as the queue is not empty.<br /><br />[Video description begins] <em>Line 14 reads as: while (!queue.isEmpty()) {.</em> [Video description ends] <br /><br />In the first iteration, this queue will start off at the current vertex, we access the vertex using queue.remove. That&#39;ll give us the vertex at the head of the queue.<br /><br />[Video description begins] <em>Line 15 reads as: int vertex &#61; queue.remove();.</em> [Video description ends] <br /><br />Next, we process this vertex in breadth first traversal. Processing this vertex simply involves printing out the vertex number to screen.<br /><br />[Video description begins] <em>Line 17 reads as: System.out.print(vertex &#43; &#34;-&gt;&#34;);.</em> [Video description ends]</p>
<p>Once we&#39;ve processed the current vertex, we get all of the vertices that are adjacent to the current vertex using graph.getAdjacentVertices and store these in a list. We&#39;ll then run a for loop through every vertex in this list and append the vertex to the queue. <br /><br />[Video description begins] <em>She highlights the code in lines 21, 22 and 24. Line 21 reads: for (int v: list) {. Line 23 reads: queue.add(v);. Line 24 reads: }.</em> [Video description ends] <br /><br />Now graphs don&#39;t have any left child or right child, so we can process the adjacent vertices in any order. This is the iterative breadth first traversal because we haven&#39;t kept track of the visited nodes, certain nodes may be visited more than once. <br /><br />[Video description begins] <em>She highlights multiple lines of code from line 9 to line 26.</em> [Video description ends]<br /><br />If your graph has a cycle, then breadth first traversal can continue forever. So be aware of that. We&#39;re now ready to test out this breadth first traversal code.</p>
<p>I&#39;ll first instantiate an adjacency matrix graph representation. This is a graph that you are familiar with, eight nodes, it&#39;s a directed graph. <br /><br />[Video description begins] <em>Line 30 reads as: Graph graph &#61; newAdjacencyMatrixGraph (8, Graph.GraphType.DIRECTED);.</em> [Video description ends] <br /><br />Go ahead, add the edges to this graph and display the graph to screen. <br /><br />[Video description begins] <em>She highlights multiple lines of code from line 32 to line 46. Line 32 reads as: graph.addEdge(1, 0);. The following lines follow the similar code style. She also highlights the code in line 46 that reads: graph.displayGraph();.</em> [Video description ends] <br /><br />Run this code and make sure this graph looks as you would expect it to. Here is the adjacency matrix representation, it&#39;s an unweighted graph. And if you scroll down below, you&#39;ll see which nodes are adjacent to each of the vertices in our graph. Let&#39;s now perform a breadth first traversal. Starting at vertex with ID 1, invoke breadthFirstTraversal and run this code.<br /><br />[Video description begins] <em>Line 50 reads: breadthFirstTraversal(graph, 1);.</em> [Video description ends]<br /><br />And here is a traversal of all the nodes in this graph, in a breadth first manner.</p>
<p>The first thing that you will notice here in this breadth first traversal, is that because we don&#39;t have a visited list, there are some nodes that are visited more than once. Node 4 here has been visited three times, and node 3 has been visited twice.</p>
<p>We start our breadth first traversal at node 1, we visit node 1 and then enqueue all of the nodes adjacent to node 1. This will be nodes 0, 2 and 5. We then visit those nodes in order.</p>
<p>We visit 0 first, then 2, then 5. Node 0 has no adjacent nodes, node 2 has three adjacent nodes, 3, 4, 7, which will then be enqueued. Node 5 has one adjacent node, which is node 6. Notice that after visiting nodes 0 to 5, we visit node 3, 4 and 7. These are the node adjacent to node 2. We then visit node 6, which is adjacent to node 5. When visit node 3, we would have enqueued a node adjacent to it, which is node 4.</p>
<p>What ends up happening is we visit node 4 once again and just after we visit 6. We visit node 3 once again because it was adjacent to node 6, and we visit node 4 yet once again, because it is adjacent to node 3. Clearly, this breadth first traversal doesn&#39;t really work very well because we haven&#39;t kept track of the nodes that we visited. Let&#39;s fix this. Here is a rewritten version of breadth-first traversal where we keep track of visited nodes.</p>
<p>This breadth first traversal takes in three input arguments. The graph that we want to traverse, an array of boolean values, which we&#39;ll use as our visited list. The length of this array will be equal to the number of vertices that we have in our graph. And finally, the current vertex is the vertex where we start our breadth-first traversal. <br /><br />[Video description begins] <em>She highlights a section of the code in line 9 which reads as: breadthFirstTraversal(Graph graph, boolean[] visited, int currentVertex) {.</em> [Video description ends] <br /><br />Now the initial part of the code remains the same. We instantiate a new queue and add the current vertex to the queue and set up a while loop which runs so long as the queue is not empty.</p>
<p>We then access the first vertex using queue.remove.<br /><br />[Video description begins] <em>She highlights the code in lines 11, 12, 14, and 15.</em> [Video description ends] <br /><br />Before we actually process this node, we&#39;ll first check to see whether this node has already been visited and processed before. <br /><br />[Video description begins] <em>She highlights the code in lines 17 to 19. Line 17 reads: if (visited[vertex]) {. Line 18 reads: continue;. Line 19 reads: }.</em> [Video description ends] <br /><br />If it has been visited at vertex will be equal to true. If visited vertex, then we simply continue and move on to the next node to process. If execution reaches line 21, we know that this is a node that hasn&#39;t been encountered before, it hasn&#39;t been visited or processed.<br /><br />[Video description begins] <em>Line 21 reads as: System.out.print(vertex &#43; &#34;-&gt;&#34;);.</em> [Video description ends] <br /><br />We print the vertex out to screen, that is effectively processing the node.</p>
<p>And we set the visited value for this vertex to be equal to true.<br /><br />[Video description begins] <em>Line 22 reads as: visited[vertex] &#61; true;.</em> [Video description ends] <br /><br />The index vertex in the visited array will now be true. This we do as soon as we see and process a node. Once we do that, we get the vertices adjacent to the current vertex. <br /><br />[Video description begins] <em>Line 24 reads: List&lt;Integer&gt; list &#61; graph.getAdjacentVertices(vertex);.</em> [Video description ends]<br /><br />We iterate using a for loop over each adjacent vertex. And we&#39;ll only enqueue the vertex, if it hasn&#39;t been visited. <br /><br />[Video description begins] <em>She highlights multiple lines of code from line 26 to line 32. Line 26 reads as: for (int v : list) {. Line 28 reads: if (!visited[v]) {. Line 30 reads: queue.add(v);. Line 31 reads: }. Line 32 reads: }.</em> [Video description ends] <br /><br />If not visited, we then queue.add(v). Thus, by keeping track of visited nodes, we&#39;ll ensure that breadth first traversal only visits each node once. Let&#39;s go ahead and instantiate a graph, we&#39;ll use the same eight node graph that we&#39;ve seen before. <br /><br />[Video description begins] <em>Line 38 reads as: Graph graph &#61; newAdjacencyMatrixGraph (8, Graph.GraphType.DIRECTED);.</em> [Video description ends]</p>
<p>Here is the graph displayed, the adjacency matrix representation and the adjacent nodes for all vertices. We are now ready to perform a breadth first traversal. Now before we invoke breadthFirstTraversal, we need to set up a boolean array of visited nodes.<br /><br />[Video description begins] <em>Line 58 reads: boolean[] visited &#61; new boolean[graph.getNumVertices()];.</em> [Video description ends]<br /><br />The size of this array is equal to the number of vertices in our list. We&#39;ll perform breadth first traversal starting with node 1.<br /><br />[Video description begins] <em>Line 60 reads: breadthFirstTraversal(graph, visited, 1);.</em> [Video description ends]</p>
<p>Run this code, and notice that this time, every node in our graph is visited exactly once. We start our traversal off with node 1. We then go to nodes 0, 2 and 5, which are adjacent to 1. We then visit node 3, 4 and 7, all three nodes are adjacent to node 2. Now, the only node that is yet to be visited is node 6, and that is visited last.</p>
<p>Breadth first traversal and we visit each node just once. Let&#39;s try a breadth first reversal once again, but this time, we&#39;ll start from a different node. We&#39;ll start traversing from node 2.Â <br />[Video description begins] <em>Line 60 reads: breadthFirstTraversal(graph,visited, 2);.</em> [Video description ends] <br /><br />Now, this is a directed graph, and notice that we go from node 2 to 3, 4, 7, and just stop because there is no path from node 2 to all other nodes of this graph. Node 2 is adjacent to nodes 3, 4 and 7, 3 is adjacent to 4, and 4 is adjacent to nothing. 7 is adjacent to nothing.</p>
<p>Based on what you choose as your starting node, it may or may not be possible to traverse the entire graph. Now I&#39;m going to change the type of this graph. It was previously a directed graph. I&#39;m going to make it an undirected graph.<br /><br />[Video description begins] <em>Line 38 reads as: Graph graph &#61; newAdjacencyMatrixGraph (8, Graph.GraphType.UNDIRECTED);.</em> [Video description ends] <br /><br />Now, all nodes are connected in both directions. Go ahead and run this code. And let&#39;s perform breadth first traversal starting at node 2.<br /><br />[Video description begins] <em>She highlights the code in line 60.</em> [Video description ends]</p>
<p>Now, there exists a path from node 2 to every other node in this graph and breadth first traversal is able to cover all nodes.</p></div>
</div>
<div>
<h2 id="3d507544-aa15-4f72-939f-09486c1825ad">
Depth-first Traversal
</h2>
<div>[Video description begins] <em>Topic title: Depth-first Traversal. Your host for this session is Janani Ravi.</em> [Video description ends]
<p>We&#39;ve seen that graphs can be unconnected, you might have certain nodes from which no path exists to other nodes of the graph. If you want to be able to perform breadth first traversal for all nodes in a graph whether or not it&#39;s an unconnected or connected graph, you&#39;ll need to do things a little differently.</p>
<p>Here is a directed graph. <br /><br />[Video description begins] <em>Line 38 reads as: Graph graph &#61; newAdjacencyMatrixGraph (8, Graph.GraphType.DIRECTED);.</em> [Video description ends] <br /><br />And in this particular graph, from node 1, it&#39;s possible to reach all other nodes. <br /><br />[Video description begins] <em>She highlights multiple lines of code from line 40 to line 52. Line 40 reads as: graph.addEdge(1, 0);. The following lines follow the similar code style.</em> [Video description ends]<br /><br />But from node 2, it&#39;s not possible to reach all other nodes of this graph. If I were to perform breadth first traversal starting at any node, I want to ensure that all other nodes of my graph are covered. How do I do this?</p>
<p>That&#39;s exactly what we&#39;ll see now. The way I perform breadth first traversal now looks a little different. I have a visited nodes array just like before. But I iterate starting from vertex 0 through all of the vertices in the graph and perform breadth first traversal starting at each vertex in turn. <br /><br />[Video description begins] <em>Line 58 reads: boolean[] visited &#61; new boolean[graph.getNumVertices()];.</em> [Video description ends] <br /><br />[Video description begins] <em>She highlights the code in lines 60 and 61. Line 60 reads: for (int i &#61; 0; i&lt; graph.getNumVertices(); i&#43;&#43;) {. Line 61 reads: breadthFirstTraversal(graph, visited, i);.</em> [Video description ends] <br /><br />Thanks to my visited array, nodes that have been processed once won&#39;t be processed again. <br /><br />[Video description begins] <em>She highlights the code on line 58.</em> [Video description ends] <br /><br />But this way, I&#39;ll cover all nodes in the graph whether or not there is a connection from one node to the rest of the graph. Go ahead and run this code, you&#39;ll see that we start breadth first traversal from node 0, node 0 has no adjacent nodes.</p>
<p>We then move on to node 1 thanks to our for loop, and from node 1, it&#39;s possible to visit every other node in this graph. Thanks to our use of the visited array, this breadth first traversal will also work with graphs where there are cycles. Here is a graph into which I&#39;ve injected some cycles. Let&#39;s see what the cycle is. On line 44, I&#39;ve added an edge from node 3 to 4. On line 54, I have an edge from node 4 to 6. <br /><br />[Video description begins] <em>Line 44 reads: graph.addEdge(3, 4);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 54 reads: graph.addEdge(4, 6);.</em> [Video description ends] <br /><br />Then on line 55, from 6 to 7. And on line 56, from 7 back to 3. <br /><br />[Video description begins] <em>Line 55 reads: graph.addEdge(6, 7);. Line 56 reads: graph.addEdge(7, 3);.</em> [Video description ends] <br /><br />There is definitely a cycle here, nodes 3, 4, 6, 7, 3. You can confirm the cycle exists in this representation of this graph as well.</p>
<p>I&#39;m now going to perform breadth first search on this graph. I&#39;ll use the visited array and I&#39;ll perform breadth first starting at every node, so that even if this is an unconnected graph, breadthFirstTraversal will work.<br /><br />[Video description begins] <em>She highlights the code from lines 62 to 66. Line 62 reads: boolean[] visited &#61; new boolean[graph.getNumVertices()];. Line 64 reads: for (int i &#61; 0; i&lt; graph.getNumVertices(); i&#43;&#43;) {. Line 65 reads: breadthFirstTraversal(graph, visited, i);. Line 66 reads: }.</em> [Video description ends] <br /><br />Run the code for breadthFirstTraversal and you can see that even though we have cycles in our graph, every node is visited exactly once and breadthFirstTraversal completes after visiting all nodes. From breadth first traversal, we&#39;ll now perform depth first traversal. And depth first traversal starts finding nodes adjacent to the current node and goes as deep as possible till it finds a node with no adjacent nodes. Just like depthFirstTraversal of a binary tree, depthFirstTraversal of a graph can be performed using a stack data structure or recursion. <br /><br />[Video description begins] <em>She highlights multiple lines of code from line 7 to line 15.</em> [Video description ends]<br /><br />The recursive code is more compact and more intuitive in my opinion, so we&#39;ll go with the recursive code. Here&#39;s the method depthFirstTraversal.</p>
<p>This takes in two input arguments, the graph data structure that we want to traverse, and the vertex where we want to start the traversal process, that is the current vertex.<br /><br />[Video description begins] <em>She highlights a section of the code in line 7 which reads as: depthFirstTraversal(Graph graph, int currentVertex) .</em> [Video description ends] <br /><br />The first thing that we do here is find all vertices that are adjacent to the current vertex using graph.getAdjacentVertices. <br /><br />[Video description begins] <em>She highlights the code in line 8 which reads as: List&lt;Integer&gt; list &#61; graph.getAdjacentVertices(currentVertex);.</em> [Video description ends] <br /><br />Once we have the list of adjacent vertices, we&#39;ll run a for loop to iterate over every vertex in this list and we&#39;ll call depthFirstTraversal on each vertex.<br /><br />[Video description begins] <em>She highlights lines 10, 11, and 12. Line10 reads: for (int vertex: list) {. Line 11 reads: depthFirstTraversal(graph, vertex);. Line 12 reads: }.</em> [Video description ends] <br /><br />After we&#39;ve explored every vertex depth first, we&#39;ll process the current vertex. And processing basically is just printing out the current vertex to screen. <br /><br />[Video description begins] <em>Line 14 reads as: System.out.print(currentVertex &#43; &#34;-&gt;&#34;);.</em> [Video description ends]<br /><br />Notice that we haven&#39;t specified a visited nodes list to keep track of nodes that have already been processed. This means there&#39;ll be certain nodes that will be processed more than once.</p>
<p>We&#39;ll fix this in a bit. First, let&#39;s see how depth first traversal works. I&#39;m going to instantiate an eight node directed graph and I&#39;ve added edges to this graph as you can see here on screen. You can first display this graph to see what the connections look like. <br /><br />[Video description begins] <em>She highlights the code on lines 19 to 34. Line 19 reads: Graph graph &#61; newAdjacencyMatrixGraph (8, Graph.GraphType.DIRECTED);. Line 21 reads as: graph.addEdge(1, 0);. The following lines follow the similar code style.</em> [Video description ends] <br /><br />Then we&#39;ll use this graph to perform depth first traversal. I&#39;ll first perform depth first traversal on this graph starting at a node 1. Run this code, and let&#39;s see how nodes are visited.<br /><br />[Video description begins] <em>Line 40 reads: depthFirstTraversal(graph, 1);.</em> [Video description ends]</p>
<p>We start our traversal at node 1. We can see that 1 is adjacent to node 0 and node 0 is not connected to any other nodes. We&#39;ve gone deep enough. The first node that is processed is 0. From node 1, we go to node 2, from node 2 to node 4., node 4 has no outgoing edges, we then process node 4. This process continues till all nodes in this graph are covered. And because we haven&#39;t used a visited nodes list some of these nodes are processed multiple times. For example, the node 4 has been visited and processed three times. The node 3 is also visited and processed twice.</p>
<p>We know that it&#39;s important to keep track of visited nodes so that nodes are not processed more than once. We need the visited node list in order to work with graphs that have cycles, otherwise, our depth first traversal will run forever. Here is my fixed version of the depth first traversal, which keeps track of the nodes that we&#39;ve visited. The input arguments passed into this depth first traversal method is the graph itself, a boolean array of nodes that have been visited, the length of this boolean array is equal to the number of vertices in the graph.</p>
<p>And the current vertex, which is the vertex where we start off our depth first traversal. <br /><br />[Video description begins] <em>She highlights a section of the code in line 7 which reads as: depthFirstTraversal(Graph graph, boolean[] visited, int currentVertex).</em> [Video description ends]<br /><br />Since we perform depth first traversal recursively, we first need to specify the base case of our recursion. If we&#39;ve already visited the current vertex, we&#39;ve already explored this vertex, we simply return, that is the base case of our recursion.<br /><br />[Video description begins] <em>She highlights the code in lines 8 to 10. Line 8 reads: if (visited[currentVertex]) {. Line 9 reads: return;. Line 10 reads: }.</em> [Video description ends]<br /><br />If our execution reaches line 12, that means the current node hasn&#39;t been visited. We go ahead and set the visited flag for the current vertex to be equal to true. The rest of the code remains the same. <br /><br />[Video description begins] <em>Line 12 reads as: visited[currentVertex] &#61; true;.</em> [Video description ends]</p>
<p>We get the adjacent vertices, we iterate over each word text in the adjacent vertices list and call depthFirstTraversal starting from each of these vertices. We pass in the visited array in every step. <br /><br />[Video description begins] <em>She highlights the code in line 14 to 18. Line 14 reads: List&lt;Integer&gt; list &#61; graph.getAdjacentVertices(currentVertex);. Line 16 reads: for (int vertex: list) {. Line 17 reads: depthFirstTraversal(graph, visited, vertex);. Line 18 reads: }.</em> [Video description ends] <br /><br />And finally, when execution comes to line 20, we&#39;ll process the current node, which is simply printing out the current node. We are now ready to test this depth first traversal using the same graph that we&#39;ve worked with so far, this is a directed graph. <br /><br />[Video description begins] <em>Line 20 reads as: System.out.print(currentVertex &#43; &#34;-&gt;&#34;);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 25 reads: Graph graph &#61; newAdjacencyMatrixGraph (8, Graph.GraphType.DIRECTED);.</em> [Video description ends] <br /><br />You can display the graph if you want to, or you can just go ahead and perform depth first traversal, make sure you instantiate the visited boolean array first. <br /><br />[Video description begins] <em>Line 47 reads: depthFirstTraversal(graph, visited, 1);.</em> [Video description ends]</p>
<p>When you run this code, you&#39;ll see that this time around, we visit each node exactly once. Observe that there is a no node here which has been visited more than once. Now, instead of performing depth first traversal starting at vertex 1, I&#39;m going to perform depth first traversal starting at vertex 6.<br /><br />[Video description begins] <em>Line 47 reads: depthFirstTraversal(graph, visited, 6);.</em> [Video description ends]<br /><br />Let&#39;s see what this leads us to. Run this code and if you take a look at the depth first traversal results, you&#39;ll see that we have visited just three nodes out of eight in our graph, we started with 4, 3, and then 6. That&#39;s because in this directed graph, there is no path from node 6 to all nodes in this graph.</p>
<p>Node 6 leads us to node 3, and then to node 4, but not to other nodes. Well, if you want a depth first traversal to cover all nodes in your graph, even if your graph is an unconnected graph, you&#39;ll need to fix your code a little bit. Instead of starting depth first traversal from a particular node, we&#39;ll run a for loop that iterates over all nodes or vertices in our graph data structure, and performs depth first traversal starting from all of these nodes.<br /><br />[Video description begins] <em>She highlights the code in lines 47, 48, and 49. Line 47 reads: for (int i &#61; 0; i&lt; graph.getNumVertices(); i&#43;&#43;) {. Line 48 reads: depthFirstTraversal(graph, visited, i);. Line 49 reads: }.</em> [Video description ends]</p>
<p>This way even for an unconnected graph, all nodes will be covered. When you run this code, this time you&#39;ll see that every node in our graph data structure is visited at least once. Because we&#39;re using a visited array to keep track of nodes that we&#39;ve visited while performing depth first traversal, this will also work with graphs that have cycles. Observe that I&#39;ve changed my graph a little bit. I&#39;ve added additional edges.</p>
<p>There is a node here from 3 to 4, 4 to 6, from 6 back to 3, that is a cycle. Run this code, and let&#39;s see that depth first traversal works with nodes that have cycles as well. And as you can see, it indeed does.</p></div>
</div>
<div>
<h2 id="74c980f5-3dde-40e1-ad17-25decbe20c6f">
Course Summary
</h2>
<div>[Video description begins] <em>Topic title: Course Summary</em> [Video description ends]
<p>In this course, we studied a very interesting data structure which has a multitude of applications in the real world, this is the graph. Graphs are the data structures that are used in mapping applications, to model social networks, transportation networks, and all applications which involve entities and relationships between these entities. We explored a number of different graph types such as undirected and directed graphs, acyclic graphs, which are essentially trees, weighted graphs where weights are associated with each edge of the graph.</p>
<p>Once we understood all of the possible variations in a graph, we moved on to graph representations, and the trade-offs between the three ways in which graphs can be implemented in code. This included the adjacency matrix implementation, the adjacency list, and adjacency set implementations as well. We discussed that the adjacency matrix representation works well for densely connected graphs, while the list and set implementations are better suited for sparsely connected graphs.</p>
<p>We rounded this course off by constructing graphs using the three techniques that we studied and performing graph traversal using breadth-first and depth-first traversal. This course sets us up nicely for the next course in this learning path where we study and implement important graph algorithms.</p></div>
</div>
</body>
</html>
