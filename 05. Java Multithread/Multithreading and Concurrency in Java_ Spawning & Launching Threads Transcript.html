<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Multithreading and Concurrency in Java: Spawning & Launching Threads Transcript">
<title>Multithreading and Concurrency in Java: Spawning & Launching Threads Transcript</title>
</head>
<body>
<h1>Multithreading and Concurrency in Java: Spawning & Launching Threads</h1>
<p><p>This is a hands-on course which introduces you to the implementation of concurrency in a Java application. You will become familiar with setting up, configuring and launching multiple concurrent threads. You will implement the join() method to synchronize threads and will explore a variety of thread features including their states, transitions and how they can be interrupted. </p></p>
<div>
<h2>Table of Contents</h2>
<ol><li><a href="#c5d6e760-f163-48cd-9f02-57a8511c8580">Course Overview</a></li>
<li><a href="#ff09e305-a193-4e41-b03e-c433bb964efc">Implementing the Runnable Interface</a></li>
<li><a href="#4d948afc-bd81-4121-9ffe-8c8d9bbdf723">Extending the Thread Class</a></li>
<li><a href="#b62aab73-9ab2-433e-bfe8-e1d554edb67a">Running Two Concurrent Threads</a></li>
<li><a href="#3cde4742-fd19-451a-802c-acc842b80588">The join() Method</a></li>
<li><a href="#90696c4f-9817-4152-8dfb-a61f8f4117af">The States of a Java Thread</a></li>
<li><a href="#3b21ebc6-46fa-430a-805d-03d7100d3601">The isAlive() Method</a></li>
<li><a href="#a27bba87-a15e-4588-a53f-7f8a7adf1c30">Thread Priorities</a></li>
<li><a href="#4659a685-f685-4312-848d-f26f526f5a33">Daemons and Thread Groups</a></li>
<li><a href="#2e6b6e76-7768-4639-9ada-0773d4115b91">Coding a Web Page Downloader</a></li>
<li><a href="#450b7f6f-0da0-48ff-9058-7f5fe24a13c7">Downloading Pages with Multithreading</a></li>
<li><a href="#0b7acd15-68bb-435d-a0d6-27f7ad91380b">Interrupting Running Threads</a></li>
<li><a href="#e8e1cbef-4a70-42d7-ae4a-05176c77890d">Course Summary</a></li>
</ol></div>
<div>
<h2 id="c5d6e760-f163-48cd-9f02-57a8511c8580">
Course Overview
</h2>
<div>[Video description begins] <em>Topic title: Course Overview</em> [Video description ends] <br /><br />Hi and welcome to this course, An introduction to concurrent programming in Java. My name is Kishan Iyer and I will be your instructor for this course.<br /><br />[Video description begins] <em>Your host for this session is Kishan Iyer. He is a software engineer and big data expert.</em> [Video description ends] <br /><br />A little about myself first. I have a master&#39;s degree in Computer Science from Columbia University. And have previously worked in companies such as Deutsche Bank and Web MD in New York. I presently work for Loonycorn, a studio for high quality video content. Concurrent programming skills are among the most useful tools in the armory of any software engineer. The ability to run several tasks simultaneously, even if they&#39;re sub tasks created out of larger tasks, can greatly improve your program&#39;s performance. This can save your organization a lot of time or even deliver a better experience to your end users. <br /><br />And the Java programming language offers a variety of options when it comes to implementing concurrent programming through multithreading. This course serves as an introduction to hands-on concurrent programming in Java using threads. We start off by defining a task which can be executed within a thread using the runnable interface and the thread class. We then move on to running multiple concurrent threads. And then having one thread wait for another to finish its job using the join method. We then cover some of the properties of a Java thread and how they affect its behavior. These include the priority level of a thread, as well as its daemon status. <br /><br />Finally, we look into how the execution of a thread can be interrupted to stop or to change the course of its execution. By the end of this course, you will have a firm grasp of multithreading in Java. You will recognize the steps involved in spawning and managing threads. And the different phases a thread goes through in its life cycle. This sets you up nicely for courses covering more advanced topics, such as synchronization and multithreading data structures.</div>
</div>
<div>
<h2 id="ff09e305-a193-4e41-b03e-c433bb964efc">
Implementing the Runnable Interface
</h2>
<div>[Video description begins] <em>Topic title: Implementing the Runnable Interface. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />Welcome to the lab section of this learning path on concurrency in Java. I&#39;m about to set up a new project in the Eclipse IDE, which is my IDE of choice for Java development. You are, of course, free to use your own IDE. There will just be a few minor variations in how exactly we can run our code, but the code itself will remain exactly the same no matter which IDE you use. In any case, it is time to create a new project, which we will use throughout this learning path.<br /><br />[Video description begins] <em>The screen displays an Eclipse IDE window. In the left pane, various projects are present. In the main pane, there is space for entering lines of code. At the bottom, there is a Console tab for showing the output.</em> [Video description ends] <br /><br />Â And if you are on Eclipse, well, the way to do this is to first create a new project and then use the new project wizard in order to configure it.<br /><br />[Video description begins] <em>The host selects the Create a project option in the left pane.</em> [Video description ends] <br /><br />In my case, I&#39;m going to select this to be a new Java project.<br /><br />[Video description begins] <em>A new window labeled New Project opens.</em> [Video description ends] <br /><br />And then we&#39;ll move on to the next page in this wizard, and this is where we&#39;ll need to supply a lot of details for the project itself. <br /><br />[Video description begins] <em>The next page in the wizard labeled Create a Java Project opens.</em> [Video description ends]<br /><br />As for the project name, I&#39;m going to call this threading and concurrency. You can of course configure the location in which the source files will be saved. And then also set up the Java Runtime Environment. In my case, I&#39;m going to get this to run on Java 13. Keep in mind that if you are on a significantly different version of Java, there may be certain features which are different, or which at least behave differently. But in any case, let&#39;s choose to finish with the setup. At which point you will be prompted to enter the module name.<br /><br />[Video description begins] <em>The host clicks the Finish button in the New Java Project window. A pop-up window labeled New module-info java displays. It contains a field labeled Module name with the text threadingAndConcurrency entered within the field. Two buttons Don&#39;t Create and Create are present in the window.</em> [Video description ends]<br /><br />Now, this is IDE specific. And this is purely optional as well. In fact, I&#39;m going to choose not to create a module. And with that selection made, well, the project is now ready for us to use. I&#39;m just going to expand the threading and concurrency project from the package explorer pane. And a source folder is visible. Within that, I&#39;m going to go ahead and create a new class. <br /><br />And when we do that, we will be prompted to specify a package within which this class will be created. Let&#39;s just set this to com.skillsoft.concurrency. In fact, I&#39;ll use the same package for all of the classes we will create throughout this learning path. Then we specify class name. And I&#39;ll just set this to my thread and leave this as a public class. I call this class MyThread, because we will set it up such that each instance of this class can be executed in its own thread. <br /><br />So let us finish with this. And now that we have the MyThread class, well, in order to enable this execution within a thread, we need to implement the Runnable interface. <br /><br />[Video description begins] <em>A class labeled MyThread displays in the main pane. It contains auto-generated lines of code. The host highlights a section of the code on line 3 which reads: public class MyThread.</em> [Video description ends] <br /><br />[Video description begins] <em>He enters the following code in line 3: public class MyThread implements Runnable {.</em> [Video description ends] <br /><br />As an alternative, you could also get this class to extend the thread class. But that is something we will cover later on. You will observe, however, that there is an error in the code. And to get more details, let&#39;s just hover over the class name. And what we see is that any class which implements the Runnable interface needs to define the run method. When we create a new thread using a Runnable instance, what is defined within the run method is what gets executed. In fact, the first thing we will now do is to implement the run method. And this has the signature, public void run. <br /><br />[Video description begins] <em>He enters the following code in line 6: public void run() {.</em> [Video description ends] <br /><br />It accepts no arguments. And we also specify the override annotation to convey the fact that this is a method, which is being overridden from its base definition.<br /><br />[Video description begins] <em>He highlights the code on line 5 that reads: &#64;Override.</em> [Video description ends] <br /><br />In this demo, we start off with what is effectively the Hello World for threads in Java. So all we do within this run method is to print out a message to the console that this has been executed by a thread.<br /><br />[Video description begins] <em>He highlights the code on line 8 that reads: System.out.println(&#34;This has been executed by a thread&#34;);.</em> [Video description ends] <br /><br />And how exactly do we execute this? Well, the first step is for us to define a main method. <br /><br />[Video description begins] <em>He enters the following code in line 12: public static void main (String[] args) {.</em> [Video description ends] <br /><br />And then within that we initialize a thread. <br /><br />[Video description begins] <em>He enters the following code in line 14: Thread myThread &#61; new Thread(new MyThread());.</em> [Video description ends]<br /><br />Here we specify a variable called myThread whose type is Thread. And the Thread class is one which implements the Runnable interface itself. In order to initialize a thread, we need to call its constructor and optionally, we can pass along a Runnable instance. In this case, when we initialize a new thread, we pass along a new instance of MyThread.<br /><br />Since it does implement the Runnable interface, this instance of myThread can be executed within a thread. All right, so we have initialized an instance of the MyThread class. And we can now get it to run within a Java thread. So I&#39;m just going to save things down and go ahead and hit run. In the Eclipse IDE, this will have the effect of running the main method from the class which is currently up in your IDE if it does have a main method. So when I hit this, well, you observe that in the console that there is no output. <br /><br />But it is clear that an instance of myThread has been run and that execution was terminated. So what exactly have gone on here? The answer is that the main method has executed, and in fact, an instance of myThread was created. However, the code within the run method did not execute because to do that, we need to explicitly call the start method for a thread. <br /><br />[Video description begins] <em>He enters the following code in line 16: myThread.start();.</em> [Video description ends] <br /><br />So by invoking myThread.start, once again, let&#39;s save things down and then hit run. Well, this time, the code within our run method has been executed and the output is visible in the console. So we have now successfully executed our first Runnable instance. And soon enough, we will be initializing and then executing multiple threads in one go. Before we get to that however, let us get a better idea of what exactly we are working with here. So within the main method, I&#39;m going to print out whether the instance myThread, which we have created is an instance of Runnable. <br /><br />[Video description begins] <em>He enters the following lines of code in lines 18 and 19. Line 18 reads: System.out.println(&#34;Is myThread a Runnable? &#34;. Line 19 reads: &#43; (myThread instanceof Runnable));.</em> [Video description ends] <br /><br />That is whether the Runnable interface has been implemented. Furthermore, we will confirm whether it is indeed a Thread instance.<br /><br />[Video description begins] <em>He enters the following lines of code in lines 21 and 22. Line 21 reads: System.out.println(&#34;Is myThread a Thread?&#34;. Line 22 reads: &#43; (myThread instanceof Thread));.</em> [Video description ends] <br /><br />That is it is of type java.lang.thread. And finally, we&#39;ll make sure that it does indeed represent a Java object. <br /><br />[Video description begins] <em>He enters the following lines of code in lines 24 and 25. Line 24 reads: System.out.println(&#34;Is myThread an Object?&#34;. Line 25 reads: &#43; (myThread instanceof Object));.</em> [Video description ends] <br /><br />All right, we can go ahead and then save down the code and then run it. And the output gives us an answer of true in all three cases. This is because we have defined myThread to be of type thread of course. And the Thread class in Java implements the Runnable interface and extends java.lang.object. <br /><br />And now that we know how to define a Runnable instance and then execute it within a thread. In the next video, we will explore one more way of executing a task using a Java thread. Specifically by setting our class to extend the Thread class rather than implementing the Runnable interface.</div>
</div>
<div>
<h2 id="4d948afc-bd81-4121-9ffe-8c8d9bbdf723">
Extending the Thread Class
</h2>
<div>[Video description begins] <em>Topic title: Extending the Thread Class. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />Previously, we saw how we can get our class to implement the Runnable interface so that its instances can be executed in a thread. While the same can be achieved by extending the Thread class.<br /><br />[Video description begins] <em>The MyThread class displays on the screen. It contains various lines of code.</em> [Video description ends] <br /><br />Well, let&#39;s see how this is done. First of all, I&#39;m just going to clear out the entire contents of this class. And we now just have the class declaration, where of course, we implement the Runnable interface.<br /><br />[Video description begins] <em>He highlights a section of the code on line 3 that reads: public class MyThread implements Runnable.</em> [Video description ends] <br /><br />I&#39;m now going to change this so that the MyThread class extends the Java.lang.thread class. <br /><br />[Video description begins] <em>The code on line 3 now reads: public class MyThread extends Thread.</em> [Video description ends] <br /><br />The Thread class also implements the Runnable interface, so it is possible for us to run instances of MyThread as a thread. All right, so what exactly will we run within the thread? This is what is defined within the run method, and this is something once again which we override. <br /><br />[Video description begins] <em>He enters the following lines of code from line 5 to line 10. Line 5 reads: &#64;Overrride. Line 6 reads: public void run() {. Line 8 reads: System.out.println(&#34;Thread is in running state!!!&#34;);. Line 10 reads: }.</em> [Video description ends] <br /><br />This is conveyed by the override annotation. And just as before, the contents of our run function includes just a system.out statement. Moving on then to the main function definition. <br /><br />[Video description begins] <em>He enters multiple lines of code from line 12 to line 27.</em> [Video description ends] <br /><br />So this is similar to what we had before, where we create an instance, called MyThread, and its type is MyThread. <br /><br />[Video description begins] <em>He highlights the code on line 14 which reads: MyThread myThread &#61; new MyThread();.</em> [Video description ends]<br /><br />Furthermore, we don&#39;t need to create an instance of Java.lang.thread directly, since my thread does extend that class. And once this variable has been instantiated, we need to execute what is defined within the run method by calling myThread.start. <br /><br />[Video description begins] <em>He highlights the code on line 16 which reads: myThread.start();.</em> [Video description ends] <br /><br />And just as we did before, we check whether this instance MyThread is an instance of Runnable and instance of Thread, and it&#39;s also a Java.lang.object. <br /><br />[Video description begins] <em>He highlights the lines of code from line 18 to line 25.</em> [Video description ends] <br /><br />So let&#39;s just save things down once again, and hit run. And the output is similar to what we saw previously. The MyThread variable once again checks out on all these three fronts. It does implement Runnable, it is a Thread, and it&#39;s also an Object. And invoking the start method, did run what was defined within the run function. So while both of these options which we have seen, that is implementing the Runnable interface, or extending the Thread class will allow us to run instances of our own class within a thread, it is usually preferable to implement the Runnable interface. <br /><br />One reason for this is that by extending the Thread class, we prevent our class from inheriting from any other class since Java does not allow multiple inheritance. Now before we change back to implementing Runnable, I&#39;m just going to clear out the contents of the console. And then select everything we have defined here. Clear those out as well, and then remove this extends Thread. And once again, implement the Runnable interface. <br /><br />[Video description begins] <em>The code on line 3 reads: public class MyThread implements Runnable {.</em> [Video description ends] <br /><br />That is, we go back to having composition versus implementing inheritance. And within the code, once again we define a run method. <br /><br />[Video description begins] <em>He enters the following lines of code from line 5 to line 13. Line 5 reads: &#64;Overrride. Line 6 reads: public void run() {. Line 8 reads: for (int i &#61;1; i &lt; 5; i&#43;&#43;) {. Line 10 reads: System.out.println(&#34;i : &#34; &#43; i) ;. Line 12 reads:}. Line 13 reads: }.</em> [Video description ends] <br /><br />This time however, we have a for loop, where we iterate four times, and on each occasion print out the value of i to the console. Now to start with in the main method, we only define a single thread.<br /><br />[Video description begins] <em>He enters the following lines of code from line 15 to line 20. Line 15 reads: public static void main(String[] args){. Line 17 reads: Thread myThread &#61; new Thread(new MyThread());. Line 19 reads: myThread.start();. Line 20 reads: }.</em> [Video description ends] <br /><br />Once again, this is of type thread and it&#39;s set up with an instance of MyThread, and then we call the start method in order to start up the for loop. Once we&#39;ve saved things down, well, I&#39;m just going to use the keyboard in order to run this. And sure enough, within the console, we see four iterations of the for loop. This is all well and good, but over the course of this learning path, we will often want to slow down the execution of our threads to get a better idea of what&#39;s going on. <br /><br />Firstly though, I&#39;m going to clear out the console, head over to the for loop. And within that, we will introduce a pause of three seconds by invoking Thread.sleep. Whenever this is invoked, the current thread will effectively go to sleep.<br /><br />[Video description begins] <em>He enters the following code on line 10 which reads: Thread.sleep(3000);.</em> [Video description ends] <br /><br />That is it&#39;ll pause execution for the specified amount of time. The argument here of 3000 conveys that this will pause for 3000 milliseconds or three seconds. Keep in mind here that if we create multiple instances of MyThread, and then execute each of them on separate threads, well each of those threads will sleep for three seconds when they encounter this. Another detail you will have observed is that there is an error in the code. <br /><br />And by hovering over this in the IDE, we can see that it is an InterruptedException, which can be thrown by Thread.sleep, and we will need to handle this. When a thread goes off to sleep, it can be interrupted by another thread, and this is something we will cover later on in this learning path. But for now, let&#39;s see what happens if you were to just save things down and run this regardless of the errors. <br /><br />[Video description begins] <em>A pop-up window titled Errors in Workspace opens. It displays an error message. It contains a Cancel and a Proceed button.</em> [Video description ends] <br /><br />So in spite of the warning, I&#39;m just going to choose Proceed here. And sure enough, this raises an exception specifically due to an unresolved compilation problem. Before we fix it though, I&#39;m going to clear out this call to Thread.sleep, clear out the console, and then back into the for loop. We&#39;ll include the Thread.sleep call within a try and catch block. <br /><br />[Video description begins] <em>He enters the following lines of code from line 10 to line 12. Line 10 reads: try{. Line 11 reads: Thread.sleep(3000);. Line 12 reads: }.</em> [Video description ends] <br /><br />If an interrupted exception is thrown, we catch it, and then print out the contents of the exception to the console.Â <br /><br />[Video description begins] <em>He highlights the code on lines 13 and 14. Line 13 reads: catch (interruptedException e){. Line 14 reads: e.printStackTrace();.</em> [Video description ends] <br /><br />All right, with that, let&#39;s see what happens if we save things down and then run the code. Well, within a few seconds, the value of i as 1 is printed to the console, then 2 and 3 seconds later, i is equal to 3. And finally, i is equal to 4, and then the loop terminates. So we have now been introduced to the Thread.sleep method. This sets us up nicely for the next video, where we will run two concurrent instances of the MyThread class.</div>
</div>
<div>
<h2 id="b62aab73-9ab2-433e-bfe8-e1d554edb67a">
Running Two Concurrent Threads
</h2>
<div>[Video description begins] <em>Topic title: Running Two Concurrent Threads. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />Now that we&#39;re familiar with how we can execute runnable instances within threads, it&#39;s time to use that knowledge in order to run concurrent threads. <br /><br />[Video description begins] <em>The MyThread class displays on the screen. It contains multiple lines of code.</em> [Video description ends] <br /><br />Well, we already have a definition for a thread where it will execute a for loop on four occasions. In each run, it will sleep for three seconds, and then print out a number to the console. So how exactly can we run two concurrent threads which do precisely what we have defined? Well first of all, let us clear out the contents of the main function where we initialize and then kick off just a single thread. And instead, we initialize and kickoff two threads. <br /><br />[Video description begins] <em>He enters the following lines of code from line 24 to line 28. Line 24 reads: Thread firstThread &#61; new Thread(new MyThread());. Line 25 reads: Thread secondThread &#61; new Thread(new MyThread());. Line 27 reads firstThread.start();. Line 28 reads: secondThread.start();.</em> [Video description ends]<br /><br />So the definitions for the threads are precisely the same as what they were before. We instantiate them as new threads, each of which runs an instance of MyThread. And to kick them off, we invoke the start method. So when we save and run, two threads have been initialized and started. And in three seconds, well, we see that i is equal to 1 has been printed by both threads, then i is equal to 2, then 3, and then 4. <br /><br />Each of the print statements are separated by a gap of three seconds. So both of these threads did in fact run concurrently. And there is an important reason for this. You&#39;ll observe within the main function that when we call firstThread.start, the code does not wait for this thread to finish. But in fact, immediately executes the next line. So once firstThread has been started, secondThread also gets a start and only then do we see the output from each of those threads. So the thread executions here are in fact asynchronous. Well, before we delve more into this, let&#39;s test out one more feature of threads.<br /><br />[Video description begins] <em>He enters the following code in line 30: firstThread.start();.</em> [Video description ends]<br /><br />So what happens if you were to invoke the start method for the firstThread once again? Will it simply re-execute the run method and give us four additional statements in the console? Well, there&#39;s only one way to find out. So let&#39;s save things down and then hit run. And in fact, what we see is that an IllegalThreadStateException is thrown. This is because it is not legal to start a thread more than once. And if you&#39;d like the task to be executed once again, well, we will need to initialize another thread. <br /><br />Now I have paused this recording at this point in order to explain this exception, but in fact, the code continues to run. Because the firstThread and secondThread instances have been instantiated, and they have in fact been started as well. So the first invocation of start for each of the threads is applicable, but the second invocation for the firstThread, well, that is what is illegal. All right, so we know one more thing about threads in Java. So we can clear out the console now. And then we get rid of this line which raises the exception, and let&#39;s see what happens if we were to invoke firstThread.run.<br /><br />[Video description begins] <em>He deletes the existing code and enters the following code in line 30: firstThread.run();.</em> [Video description ends] <br /><br />Well, I can tell you now that this will in fact run successfully and no exception will be raised. This is because calling the start method will run the defined threads on separate new threads. While calling run will invoke the run method of the corresponding runnable instance in the current thread. That is the thread which executes the main method. This will all become clearer just a little later, but for now let&#39;s just save things down and run.<br /><br />And soon enough in the console, you will see that there are three different threads which print out the value of i and all of these run concurrently. So at this point, things have just gotten a little more complicated. It is important for us to know which thread has written which print statement to the console. So how exactly can we include the name or ID of a thread in the print statement? Well, let&#39;s first clear out the console, head over to the run method definition and over to this print statement, and then replace it with another one.<br /><br />[Video description begins] <em>He enters the following lines of code on lines 17 and 18. Line 17 reads: String threadName &#61; Thread.currentThread().getName();. Line 18 reads: System.out.println(threadName &#43; &#34;says: &#34; &#43; i);.</em> [Video description ends]<br /><br />First though, we initialize a variable called threadName and this is set to the name of the current thread. Which we get by invoking Thread.currentThread().getName();. In the previous run, we clearly had three different threads which executed the run method. <br /><br />[Video description begins] <em>He highlights the code from line 28 to line 31.</em> [Video description ends] <br /><br />And with this change, we will be able to view the thread names since we include this thread name in the print statement. Now you have an idea that each thread has a name, and this is something which we can configure on our own and we will explore that later on. But for now, let&#39;s see what the system-generated name is for each thread. So we save things down and then run and soon enough, we begin seeing the print statements in the console.<br /><br />So we clearly see here that there are three different threads, namely main, Thread-0 and Thread-1. When the JVM executes the main method, it in fact runs it on a separate thread called main. When we initialize our firstThread and then started it, well it ran on a thread called Thread-0. Similarly, the secondThread ran on Thread-1. But when we invoked firstThread.run, it in fact ran on the current thread. And since this was executed from main, that happened to be the main thread. Well, to make things a little clearer, let&#39;s just change the main function a little bit. Instead of invoking the start function for each of the threads, let&#39;s just invoke run. Which means that firstThread and secondThread will both run on the main thread.<br /><br />[Video description begins] <em>He enters the following code on lines 28 and 29. Line 28 reads: firstThread.run();. Line 29 reads: secondThread.run();.</em> [Video description ends]<br /><br />So, if both of these tasks run on the same thread, does it mean that concurrency will be achieved? Well, to find out, let&#39;s just save things down and then run this program. And then we see in the output that the values which are printed are in sequence, 1, 2, 3, 4 and then 1, 2, 3, 4 for the second time. So both of the tasks as defined by firstThread and secondThread have been executed on the same main thread. And since a thread can only execute one task at a time, these were executed in sequence rather than concurrently. <br /><br />All right, so we now have an idea of the main thread, and the fact that different threads are spawned when we execute the start method. Furthermore, we know that invoking Thread.currentThread().getName retrieves the name of the current thread. But it&#39;s time for us to set the name for the threads. First though, let&#39;s clear out the console. And then heading over to the main method. <br /><br />[Video description begins] <em>The host deletes the lines of code from lines 25 to 29 and then pastes in new lines of code.</em> [Video description ends]<br /><br />Well, this time when we initialize firstThread, you&#39;ll observe that we don&#39;t just pass along to it a runnable task. But the second argument is a string representing the thread name.<br /><br />[Video description begins] <em>He highlights the code on line 25 which reads: Thread firstThread &#61; new Thread(new MyThread(), &#34; 1st Thread&#34;);.</em> [Video description ends] <br /><br />So we give this a name of 1st Thread. As for the secondThread, well, the initialization is just the same as before where we simply pass along a runnable task. <br /><br />[Video description begins] <em>He highlights the code on line 26 which reads: Thread secondThread &#61; new Thread(new MyThread());.</em> [Video description ends] <br /><br />But we set the name afterwards by invoking secondThread.setName.<br /><br />[Video description begins] <em>He highlights the code on line 28 which reads: secondThread.setName(&#34;2nd Thread&#34;);.</em> [Video description ends] <br /><br />And sure enough, we call this 2nd Thread. Then we invoke the start method for each of them, so each of these will run on separate threads.<br /><br />[Video description begins] <em>He highlights the code on lines 30 and 31. Line 30 reads: firstThread.start();. Line 31 reads: secondThread.start();.</em> [Video description ends] <br /><br />To confirm though, let&#39;s save and then run. And after three seconds, we get the first line of output. Where each of the concurrent threads prints out the value of 1 for i, then 2, 3 and 4. Significantly though, the name which has been printed out for each of the threads are 1st Thread and 2nd Thread. So we now know how to retrieve and also set the names for the different threads running in our program. This will make it easier to identify which output has been generated by which thread further along in this learning path.</div>
</div>
<div>
<h2 id="3cde4742-fd19-451a-802c-acc842b80588">
The join() Method
</h2>
<div>[Video description begins] <em>Topic title: The join() Method. Your host for this session is Kishan Iyer.</em> [Video description ends]<br /><br />Now that we know how to execute threads concurrently in Java, let&#39;s take a closer look at the different states and phases in the life cycle of Java threads. So for this I am going to create a new Java class. And this is going to remain within the same threading and concurrency project. So within the same com.skillsoft.concurrency package, I&#39;ll just create a new class and this will be called ThreadLifeCycle.<br /><br />[Video description begins] <em>The ThreadLifeCycle class displays on the screen. It contains auto-generated lines of code.</em> [Video description ends] <br /><br />And once it has been created, I&#39;ll just go ahead and paste the contents of <br />the class and then walk you through each of the different blocks. <br /><br />[Video description begins] <em>He highlights the code on lines 3 and 5. Line 3 reads: public class ThreadLifeCycle {. Line 5 reads: }.</em> [Video description ends] <br /><br />First, we define an inner class called Walk. <br /><br />[Video description begins] <em>He highlights the code on line 5 which reads: public static class Walk implements Runnable{.</em> [Video description ends] <br /><br />So this is one which implements the runnable interface, which means that we can execute an instance of the Walk class in a separate thread. In fact, there will just be a single instance of Walk for the entire thread life cycle class since we have declared this to be a static class. So what exactly is the task which we define within Walk? <br /><br />[Video description begins] <em>He highlights the lines of code from line 7 to line 20. Line 7 reads: &#64;Override. Line 8 reads: public void run() {. Line 10 reads: for (int i &#61; 1; i &lt; 5; i&#43;&#43;) {. Line 12 reads: try {. Line 13 reads: Thread.sleep(3000);. Line 14 reads: }. Line 15 reads: catch (InterruptedException e){. Line 16 reads: e.printStackTrace();. Line 17 reads: }. Line 19 reads: System.out.println(&#34;I&#39;m walking...&#34;);. Line 20 reads: }.</em> [Video description ends] <br /><br />Well, just as before, we have a for loop which iterates four times, and in each iteration we sleep for 3 seconds and then we print out to the console that this thread is walking. So we will have one thread which executes this instance of Walk. But this won&#39;t be the only instance which we execute since we will define a second task, and this is called ChewGum. <br /><br />[Video description begins] <em>He highlights the code on line 24 which reads: public static class ChewGum implements Runnable{.</em> [Video description ends] <br /><br />You may have guessed that we will test whether we can walk and chew gum at the same time. So the ChewGum class does implement the Runnable interface once again. And the run method which we set within it is similar to what is there for the Walk class. Four iterations of a for loop with the sleep of 3 seconds in each, but at the end, we print out to the console that this thread is chewing gum.<br /><br />[Video description begins] <em>He highlights the code on line 38 which reads: System.out.println(&#34;I&#39;m chewing gum...&#34;);.</em> [Video description ends] <br /><br />Again, you will note that this is a static class, which means that there is just a single instance for the entire thread lifecycle. So with two tasks defined, let&#39;s go ahead and define the main method where we&#39;ll kick off each of those and we&#39;ll make sure that the first run concurrently. <br /><br />[Video description begins] <em>He enters the following lines of code from line 43 to line 51. Line 43 reads: public static void main(String[] args) {. Line 45 reads: Thread walkThread &#61; new Thread(new Walk());. Line 46 reads: Thread chewThread &#61; new Thread(new ChewGum());. Line 48 reads walkThread.start();. Line 49 reads: chewThread.start();.</em> [Video description ends] <br /><br />So we define a walkThread and a chewThread as threads. And we set these up with each of the runnable tasks in our class. And then we invoke the start methods for each of these. We already know that when the main thread invokes walkThread.start, then the Walk thread will be executed within a separate thread but main does not wait for it to return. <br /><br />But instead will invoke chewThread.start just moments after walkThread has begun execution, all right? Let&#39;s save things down and then hit Run, and as expected, in about three seconds, we will begin seeing the print messages. Keep in mind that I have just fast forwarded this recording just a little bit. But soon enough, all four iterations of each of the for loops have been completed and the two concurrent threads have finished executions. Now this is all well and good, but there may be occasions where you need synchronization between different threads. <br /><br />For instance, what if one thread executes a task and then generates an output which is required by another thread? Well, we can&#39;t really start the second thread before the first thread has completed, so we will need some way to effect a wait. That is, let&#39;s just say we want the main thread to wait after walkThread has been started and then before chewThread has begun.Â <br /><br />[Video description begins] <em>He highlights the code on lines 48 and 49.</em> [Video description ends] <br /><br />Well, to do that, I&#39;m going to replace these two calls to the start methods and then replace it with this code. <br /><br />[Video description begins] <em>He enters the following lines of code from line 48 till line 55. Line 48 reads: try {. Line 49 reads: walkthread.start();. Line 50 reads: walkThread.join();. Line 51 reads: chewThread.start();. Line 52 reads: }. Line 53 reads: catch (InterruptedException e) {. Line 54 reads: e.printStackTrace();. Line 55 reads:}.</em> [Video description ends] <br /><br />You&#39;ll observe that once again, we invoke walkThread.start, and then also chewThread.start, but between them we have a call to walkThread.join. It is the main thread which will invoke walkThread.join, and this effectively means that the main thread will wait for walkThread to finish before it moves further along in its own execution. That is, walkThread will finish before chewThread.start is invoked.<br /><br />Now when a thread calls the join method, it means that it is in a wait state and this means that it can be interrupted. So an interrupted exception can be raised, which is why the invocation of the join method needs to be within a try block. And if an interrupted exception does get raised, well, we simply catch it and then print out the entire exception over to the console. <br /><br />Now before we save things down, let&#39;s take stock of what exactly will happen. walkThread will start execution, and then main will wait for it to complete, and only then will it start up chewThread. Which means that the threads will not run concurrently. So let&#39;s go ahead and save and run. And sure enough, we see the output from the walkThread first and once that is finished, well, it is the chewThread which starts. So with this use of the join method we have successfully made sure that the main thread waits for the execution of a particular thread before it proceeds with its own execution. <br /><br />Now you can imagine that the total execution time for a thread is not always predictable. For example, if you use a thread to download some information or to perform some other I/O tasks, those could go on for a while. And you may want to specify an upper bound for which your thread waits for that task to be completed. Well, one way to do that is to pass along an argument to the join method.<br /><br />[Video description begins] <em>He changes the code on line 50, which now reads: walkThread.join(5000); </em>[Video description ends] <br /><br />Let&#39;s see how that works. And this time we pass along an argument of 5000 which means that the main thread will wait 5000 milliseconds or 5 seconds for the walkThread before it proceeds to calling start for the chewThread. We know, of course, that each of our threads will take at least 12 seconds to execute. Given the four iterations with a pause of 3 seconds in each, which means that the chewThread will effectively start just 5 seconds after the walkThread. So when we save and run, well, in about 3 seconds we will see an output from the walkThread. And about two seconds after that, the chewThread should have started up.<br /><br />However, we will see one more output from the walkThread and only then we see the first output from the chewThread since it does need to wait 3 seconds before its own print statement. And then, of course, we see alternating outputs from the Walk and Chew threads. Until finally, the walkThread concludes, and then there are two iterations of the chewThreads, and then everything stops. <br /><br />So we now know how the join method can effectively cause a thread to wait for the execution of another thread. This can either be unbounded when we call join without an argument, or we specify a timeout in milliseconds. In the next video, we will take a look at some of the states which a thread can go through during its lifecycle.</div>
</div>
<div>
<h2 id="90696c4f-9817-4152-8dfb-a61f8f4117af">
The States of a Java Thread
</h2>
<div>[Video description begins] <em>Topic title: The States of a Java Thread. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />We&#39;ll now begin to explore various stages in the lifecycle of a Java thread. In the program we started working with in the last video, we created two separate threads for two tasks, walking and chewing. And each of them wrote a line of text to the console from within a for loop.<br /><br />[Video description begins] <em>The ThreadLifeCycle class displays on the screen. The host highlights the code on lines 45 and 46.</em> [Video description ends]<br /><br />Let&#39;s head over to the for loop of the walk thread first, and the system.out.println statement can now be replaced with another one, which conveys a little more information. <br /><br />[Video description begins] <em>He highlights the code on line 19.</em> [Video description ends]Â  <br /><br />[Video description begins] <em>He enters the following code on line 19: System.out.println(&#34;I&#39;m walking...My state is&#34; &#43; Thread.currentThread().getState());.</em> [Video description ends]<br /><br />So we now print out the state of the thread, which is retrieved by accessing the current thread as Thread.currentThread. And then calling the getState method. To examine the state, we&#39;ll only be working with the Walk class. So for now, let&#39;s get rid of the chewGum class, and then also replace the main function with something new. And this is the modified main function we&#39;ll work with. <br /><br />[Video description begins] <em>He enters multiple lines of code from line 24 to line 42.</em> [Video description ends]<br /><br />We initialize an instance of the Walk class, and that of course is set to run in a thread. <br /><br />[Video description begins] <em>He highlights the code on line 26 which reads: Thread walkThread &#61; new Thread(new Walk());.</em> [Video description ends]<br /><br />And then we print out to the console, the state of the walkThread.<br /><br />[Video description begins] <em>He highlights the code on line 28 which reads: System.out.println(&#34;State of walkThread after init: &#34; &#43;walkThread.getState());.</em> [Video description ends] <br /><br />We do this by calling walkThread.getState. And this will return to us the state of that thread after it has been initialized, but before it has been started. And then we go ahead and start the thread inside the try block.<br /><br />[Video description begins] <em>He highlights the code on line 32 which reads: walkThread.start();.</em> [Video description ends]<br /><br />And once again, we print out the state of the thread right after it has started running, and see if this is any different from when the thread was first created.<br /><br />[Video description begins] <em>He highlights the code on line 33 which reads: System.out.println(&#34;State of walkThread after start: &#34; &#43;walkThread.getState());.</em> [Video description ends] <br /><br />At this point, the for loop inside the walkThread instance will get activated, and the state of the running thread will be accessible there as well. Then we invoke the join method from within the main method, so that the main thread waits for walkThread to finish.<br /><br />[Video description begins] <em>He highlights the code on line 35 which reads: walkThread.join();.</em> [Video description ends] <br /><br />And then we once again access the state of walkThread. <br /><br />[Video description begins] <em>He highlights the code on line 36 which reads: System.out.println(&#34;State of walkThread after join: &#34; &#43;walkThread.getState());.</em> [Video description ends] <br /><br />Of course, invoking the join function can throw an InterruptedException, which is why we have this code in a try block, and then a catch to handle their InterruptedException. <br /><br />[Video description begins] <em>He highlights the code on lines 39 to 41. Line 39 reads: catch (InterruptedException e){. Line 40 reads: e.printStackTrace();. Line 41 reads: }.</em> [Video description ends] <br /><br />All right, with this new code, we will get an idea of the different states of the WalkThread throughout its life cycle. All right, I&#39;m just going to save things down, and run, and the different print messages which we have defined get executed one by one. I&#39;m just going to fast forward this to the point where the program has run its course.<br /><br />And let&#39;s examine the output to understand some of the different states of the walkThread. So right after the walkThread has been initialized, but before it has been started, it is in a new state. And then right after walkThread.start is invoked, it transitions into the RUNNABLE state. This conveys that the thread is being executed within the Java Virtual Machine. In fact, the thread is in the same RUNNABLE state inside the for loop, where we clearly know that the thread is being executed. But once the walkThread has finished its task, well, that is when control returns to the main thread. <br /><br />And then we have the final invocation of the getState method for our thread where its state has transitioned to terminated. This of course, is the point at which the thread has completed its task, and has exited. All right, so we have now come across three of the different states in the life cycle of a Java thread. It&#39;s now time for us to add a little more complexity, and then explore the states of not just the walkThread, but also the main thread. So I&#39;m just going to replace all of the code in the main thread, and then paste in some new code. <br /><br />And let&#39;s take a look at what exactly is going on here. Once again, we initialize the walkThread, and then access it state which we expect will be new. <br /><br />[Video description begins] <em>He highlights the code on line 26 which reads: Thread walkThread &#61; new Thread(newWalk());.</em> [Video description ends] <br /><br />But then we also print out the state of the main thread. <br /><br />[Video description begins] <em>He highlights the code on line 30 which reads: System.out.println(&#34;State of main thread after walkThread init: &#34; &#43; Thread.currentThread().getState());.</em> [Video description ends] <br /><br />So this is accessible as Thread.currentThread.getState, since this particular line will be executed by main. And then we head over to the try block. After starting the walkThread, we again print out its state, and then also print out the state of the main thread at this point. <br /><br />[Video description begins] <em>He highlights the lines of code from line 33 to line 48.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the code on lines 34 and 35. Line 34 reads: walkThread.start();. Line 35 reads: System.out.println(&#34;State of walkThread after start: &#34; &#43;walkThread.getState());.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the code on line 36 which reads: System.out.println(&#34;State of main thread after walkThread start: &#34; &#43; Thread.currentThread().getState());.</em> [Video description ends]<br /><br />Now, the first iteration of the for loop for the walkThread will have been kicked off, and we send the main thread to sleep for one second.<br /><br />[Video description begins] <em>He highlights the code on line 38 which reads: Thread.sleep(1000);.</em> [Video description ends] <br /><br />And then invoke the walkThread.join function so that the main thread waits five seconds for walkThread to run.<br /><br />[Video description begins] <em>He highlights the code on line 39 which reads: walkThread.join(5000);.</em> [Video description ends]<br /><br />So I set this value to five seconds, so that at least one iteration of the for loop is complete. And we&#39;ll get to see the state of the walkThread while the join function have been invoked from the main thread. And sure enough, we need to print out walkThread.getState, and also the state of the main thread right after the join.<br /><br />[Video description begins] <em>He highlights the code on lines 41 and 42. Line 41 reads: System.out.println(&#34;State of walkThread afterjoin: &#34; &#43;walkThread.getState());. Line 42 reads: System.out.println(&#34;State of main thread after walkThread join: &#34; &#43; Thread.currentThread().getState());.</em> [Video description ends]<br /><br />Next, we put the main thread to sleep for 20 seconds.<br /><br />[Video description begins] <em>He highlights the code on line 45 which reads: Thread.sleep(20000);.</em> [Video description ends] <br /><br />This gives enough time for the walkThread to complete execution. And then after that we invoke walkThread.getState which we expect will be terminated. And also invoke getState for the main thread. <br /><br />[Video description begins] <em>He highlights the code on line 47 which reads: System.out.println(&#34;State of walkThread at the end: &#34; &#43; walkThread.getState());.</em> [Video description ends] [Video description begins] <em>He highlights the code on line 48 which reads: System.out.println(&#34;State of main thread at the end : &#34; &#43; Thread.currentThread().getState());.</em> [Video description ends] <br /><br />So in addition to the state of the main threads at various points, we also explore the state of the walkThread after we called join on it from the main. So let&#39;s save things down, and then run this. And soon enough all of the print statements get executed. I&#39;ll just fast forward with the recording at this point, so that we don&#39;t need to wait for the entire time. <br /><br />But let&#39;s examine the output once all the print statements are in. Sure enough, after the init, the walkThread is in the new state, and the main thread is RUNNABLE. This makes sense given that the print statement was issued from the main function, which means that it is the main thread which will have been in the JVM at that point. Right after we start the walkThread, we see that both walkThread and the main thread are RUNNABLE. And again, this is something which makes sense to us. And then there are two iterations of the for loop from inside the walkThread. <br /><br />Given that on each of those occasions, the walkThread is being executed in the JVM, sure enough, the state shows up as RUNNABLE. Keep in mind here that at least the second of these statements is after the point where walkThread.join was invoked from the main thread. But since the thread was running, its state shows up as runnable. It is after that where things get a little interesting. When we invoke the join function from the main thread, and then print out the state of walkThread from main, specifically on line 41 in my own code. <br /><br />This is where control has just returned to the main thread. And when we access the state of walkThread, it shows up as TIMED_WAITING. This is the state when a thread is waiting a specified amount of time for another thread to perform an action. And this is an effect of invoking the join method on the walkThread. Sure enough right after that, when we print out the state of the main thread, it is RUNNABLE. Then we put the main thread to sleep for 20 seconds. And then the walkThread completes the last two for loop iterations where its state is printed out as RUNNABLE. And after that, of course, the walkThread has run its course, and its state has transitioned to terminated. The state of the main thread, though, is still RUNNABLE.<br /><br />In fact, you will notice that all of the times where we printed out the state of the main thread, it has been RUNNABLE since each of those statements were invoked from the main function itself. So we now have an idea of some of the different states and transitions which are possible during the lifecycle of a Java thread. In the next video, we&#39;ll take a look at one more method which is available for threads to check whether they are currently alive.</div>
</div>
<div>
<h2 id="3b21ebc6-46fa-430a-805d-03d7100d3601">
The isAlive() Method
</h2>
<div>[Video description begins] <em>Topic title: The isAlive() Method. Your host for this session is Kishan Iyer.</em> [Video description ends]<br /><br />In the previous video, we explored a number of different states which a Java thread can go through during its life. However, each of those states was rather granular. And in many cases, you may need something a little more blunt than that. For instance, we may only wish to check whether a thread is currently terminated or if it is still alive. And for that there is the isAlive method for a Java thread. <br /><br />[Video description begins] <em>The ThreadLifeCycle class displays on the screen. It contains multiple lines of code.</em> [Video description ends] <br /><br />To explore its use, let&#39;s make a change to our code. First, I&#39;m just going to clear out the entire main function. And then before we paste in the new main, let&#39;s just make a minor change to this print statement inside the for loop of our walkThread. I&#39;m going to replace this with one which gives us the result of invoking the isAlive method of the current thread. <br /><br />[Video description begins] <em>He enters the following code on line 19: System.out.println(&#34;I&#39;m walking...My isAlive state is&#34; &#43; Thread.currentThread().isAlive());.</em> [Video description ends] <br /><br />And we&#39;ll then go ahead and paste the main function code as well.<br /><br />[Video description begins] <em>He highlights the code on line 27 which reads: Thread walkThread &#61; new Thread(new Walk());.</em> [Video description ends] <br /><br />So once we initialize walkThread, we invoke isAlive to check whether the thread is alive even before it has been started. But after it has been initialized.<br /><br />[Video description begins] <em>He highlights the code on line 29 which reads: System.out.println(&#34;isAlive state of walkThread after init: &#34; &#43;walkThread.isAlive());.</em> [Video description ends] <br /><br />Then once we have started walkThread, we once again check whether it is alive. <br /><br />[Video description begins] <em>He highlights the code on line 33 which reads: walkThread.start();.</em> [Video description ends] <br /><br />And at this point, we expect that it should be.<br /><br />[Video description begins] <em>He highlights the code on line 34 which reads: System.out.println(&#34;isAlive state of walkThread after start: &#34; &#43;walkThread.isAlive());.</em> [Video description ends] <br /><br />Following that, we call walkThread.join. <br /><br />[Video description begins] <em>He highlights the code on line 36 which reads: walkThread.join();.</em> [Video description ends] <br /><br />And don&#39;t supply an argument so that the control returns to the main function only after walkThread has completed its task. So, at this point we expect that the state of the walkThread will be terminated. And we&#39;ll take a look at whether it is still considered to be alive. <br /><br />[Video description begins] <em>He highlights the code on line 37 which reads: System.out.println(&#34;isAlive state of walkThread after join: &#34; &#43;walkThread.isAlive());.</em> [Video description ends] <br /><br />All right, we can now save things down and then run the code. And we observe that right after walkThread has been initialized, but before it has been started, it is considered not alive. It is however marked as alive after start has been invoked, and while it is running. And once the thread has finished running and returned control to the main thread, it is not considered alive anymore. So these effectively cover the liveness of a thread while it is in the new, runnable or terminated states. Now, let&#39;s add a little more complexity. After clearing out the console, I&#39;m just going to replace these two lines and then paste in this new code. <br /><br />[Video description begins] <em>He deletes the code on lines 36 and 37.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code on line 36 which reads: walkThread.join(5000);.</em> [Video description ends] <br /><br />Once again we invoke walkThread.join, but we make sure that control returns to the main thread before walkThread has terminated. And then check whether that thread is still considered alive at that point.<br /><br />[Video description begins] <em>He highlights a section of the code in line 37 which reads: walkThread.isAlive());.</em> [Video description ends] <br /><br />We know from the previous video that the state of the walkThread will be timed waiting at that point. Then, we put the main thread to sleep for ten seconds, which is enough time for the walkThread to complete execution. <br /><br />[Video description begins] <em>He highlights the code on line 39 which reads: Thread.sleep(10000);.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code on line 40 which reads: System.out.println(&#34;Alive state of walkThread at the end: &#34; &#43; walkThread.isAlive());.</em> [Video description ends] <br /><br />And once again, check whether it is alive. All right, so let&#39;s save and run once again. As usual, I&#39;m just going to fast forward in this recording until all of the print statements are in. And then let&#39;s analyze the output. Sure enough right after the init, the walkThread is considered not alive, but it does take on a life after it has been started. Then the first print statement from inside the for loop conveys that walkThread is very much alive at that point. <br /><br />And in fact, even after we invoke join from the main thread, and then control returns to main after five seconds. walkThread is still considered alive. So the state of timed waiting does correspond to alive status for a thread. And then the remaining print statements should no longer be a surprise for us. So the thread is considered alive while it is still running. And once the thread has terminated, the isAlive invocation returns false.</div>
</div>
<div>
<h2 id="a27bba87-a15e-4588-a53f-7f8a7adf1c30">
Thread Priorities
</h2>
<div>[Video description begins] <em>Topic title: Thread Priorities. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />So far in this course, we have come across a number of different methods which are available in Java&#39;s Thread class, allowing us not only to initialize threads, but also to keep an eye on details such as the thread state, the thread name, and so on. In this demo, we will look at some of the other methods which are available in the Thread class giving us a more all round view of the features of Java threads. <br /><br />So I&#39;m about to create a new Java source file for this. So I&#39;ll create this within the same com.skillsoft.concurrency package. And for this new class, I&#39;m going to give it a name of ThreadMethods. So once this is created, well just as before, I&#39;ll just go ahead and paste the code.<br /><br />[Video description begins] <em>The ThreadMethods class displays on the screen. It contains auto-generated lines of code.</em> [Video description ends] <br /><br />We will once again set up an inner class called walk, which implements the Runnable interface and also happens to be a static class, and its run method includes a for loop with four iterations. <br /><br />[Video description begins] <em>He highlights the code on line 5 which reads: public static class Walk implements Runnable {.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code on line10 which reads: for (int i &#61;1; i &lt; 5; i&#43;&#43;) {.</em> [Video description ends] <br /><br />Similarly, we have another class called ChewGum, which is also static and also has four iterations in a for loop. <br /><br />[Video description begins] <em>He highlights the code on line 24 which reads: public static class ChewGum implements Runnable{.</em> [Video description ends] <br /><br />And then we&#39;ll go ahead and paste in the main function code.<br /><br />[Video description begins] <em>He highlights the code on line 42 which reads: public static void main(String[] args) {.</em> [Video description ends] <br /><br />After we initialize both the walkThread and chewThreads out of the Walk and ChewGum instances, we will start them both up so that they will run concurrently. Â <br /><br />[Video description begins] <em>He highlights the code on lines 44 and 45. Line 44 reads: Thread walkThread &#61; new Thread(new Walk());. Line 45 reads: Thread chewThread &#61; new Thread(new ChewGum());.</em> [Video description ends]<br /><br />And while we walk and chew gum, we will invoke a number of different methods which are available for each of the threads. <br /><br />[Video description begins] <em>He highlights the code on lines 47 and 48. Line 47 reads walkThread.start();. Line 48 reads: chewThread.start();.</em> [Video description ends] <br /><br />Â [Video description begins] <em>He highlights the code on lines 50 to 63.</em> [Video description ends] <br /><br />First, we invoke getId for both walkThread and chewThread, and then also for the main thread. <br /><br />[Video description begins] <em>He highlights the code on lines 50 and 51. Line 50 reads: System.out.println(&#34;\nwalkThread&#39;s ID:&#34; &#43; walkThread.getID());. Line 51 reads: System.out.println(&#34;chewThread&#39;s ID:&#34; &#43; chewThread.getID());.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the code on line 52 which reads: System.out.println(&#34;main thread&#39;s ID:&#34; &#43; Thread.currentThread().getId());.</em> [Video description ends] <br /><br />The thread ID is something which is system generated. And this is another way to identify a thread beyond the thread name. In fact, we will also print out the names of each of the three threads, to give an idea of how this differs from the thread ID. Then we move along to the thread group. <br /><br />[Video description begins] <em>He highlights the code on lines 54, 55, and 56. Line 54 reads: System.out.println(&#34;\nwalkThread&#39;s name:&#34; &#43; walkThread.getName());. Line 55 reads: System.out.println(&#34;chewThread&#39;s name:&#34; &#43; chewThread.getName());. Line 56 reads: System.out.println(&#34;main thread&#39;s name:&#34; &#43; Thread.currentThread().getName());.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code on lines 58, 59, and 60. Line 58 reads: System.out.println(&#34;\nwalkThread&#39;s thread group:&#34; &#43; walkThread.getThreadGroup());. Line 59 reads: System.out.println(&#34;chewThread&#39;s thread group:&#34; &#43; chewThread.getThreadGroup());. Line 60 reads: System.out.println(&#34;main thread&#39;s thread group:&#34; &#43; Thread.currentThread().getThreadGroup());.</em> [Video description ends]<br /><br />A thread group can be defined as a collection or a set of threads. And this is a logical way for us to group certain threads together. There is by default, an initial thread group. And we can spawn additional thread groups from within that. And those in turn, can form thread groups of their own. We won&#39;t go too much into the details of this concept, but we will have some idea of what exactly makes up a thread group in Java. Scrolling further along, we will print out the priorities of each of the threads which we create.<br /><br />[Video description begins] <em>He highlights the code on lines 62, 63, and 64. Line 62 reads: System.out.println(&#34;\nwalkThread&#39;s priority:&#34; &#43; walkThread.getPriority());. Line 63 reads: System.out.println(&#34;chewThread&#39;s priority:&#34; &#43; chewThread.getpriority());. Line 64 reads: System.out.println(&#34;main thread&#39;s priority:&#34; &#43; Thread.currentThread().getPriority());.</em> [Video description ends] <br /><br />The priority of a thread comes into the picture when there is contention for a resource, and those with a higher priority will get preference over those with lower priority levels. Here, we print out the priorities for all the three threads without setting one explicitly, which will give us the default priority value. And then we have one more print statement, where we display the number of active threads in the current threads thread group. <br /><br />[Video description begins] <em>He highlights the code on line 66 which reads: System.out.println(&#34;#Active threads: &#34; &#43;Thread.activeCount());.</em> [Video description ends] <br /><br />So this is obtained by invoking Thread.activeCount. For this first run, there will just be a single thread group. And we will explore this a little further later on when we create additional thread groups. So this concludes the first iteration of the code for this demo. So, let&#39;s save things down and then run. And then, we will begin to see the outputs from the print statements from the main thread as well as the Walk and ChewGum threads. <br /><br />Once this is done, I&#39;m just going to scroll all the way to the top, and we&#39;ll go through each block of output one at a time. In the first block, we have the IDs of the three threads, which run concurrently. We observe that the ID of the main thread is 1. And in my case, the walk and chewThread IDs are 11 and 12. It is likely that you&#39;ll see the same ID of 1 for the main thread, but different numbers for the other threads. Keep in mind though that the thread ID is always a positive long number, and is unique for each thread. <br /><br />Furthermore, the thread ID remains unchanged during the lifetime of a Java thread. And then there are the default names which have been generated for the three threads. We know of course, that it is possible for us to set a name for new threads which we spawn. And a thread name need not be unique across all of the Java threads.<br /><br />And then when we scroll further along, we get the details of the thread group for each of the threads. In fact, all of these three threads belong to the same thread group, which has a name of main and has a max priority of 10. When we have a group of threads, it is possible for us to configure what the max priority value for its member threads should be. <br /><br />And the highest priority value for a Java thread is 10, which is the default max priority for a thread group. And speaking of priorities, we view that each of the three threads has a default priority level of 5. In fact, the range of priority levels for Java threads at the time of this recording is between 1 and 10, where 1 represents a low priority thread, and 10 is the highest priority which a thread can have. Moving along then to the number of active threads, as expected, there are three active threads in the thread group to which the main thread belongs. <br /><br />And in fact, this is significant because there are no further hidden threads that we don&#39;t know of. Scrolling further along in the output, we simply see the print statements from the concurrently executing, Walk and ChewGum threads. All right, let&#39;s clear out the console now, and we continue exploring some of the methods which are available for Java threads. First though, I&#39;ll just remove all of these different statements from the main and just leave the initializations of the two threads.<br /><br />[Video description begins] <em>He deletes multiple lines of code from line 50 to line 68. He then highlights the code on lines 44 and 45.</em> [Video description ends]<br /><br />And then following that, we will now explore the SetPriority methods for Java threads. <br /><br />[Video description begins] <em>He enters various lines of code. He then highlights the lines of code on lines 47 and 48. Line 47 reads: walkThread.setPriority(9);. Line 48 reads: chewThread.setPriority(2);.</em> [Video description ends] <br /><br />So we now set the priority level for the walkThread to 9 and then chewThread has a priority of 2. Now this is not really going to come into play. So this execution, since the priority is something to consider when there is contention for a resource. In this case though, we will simply print out the priorities by invoking getPriority for each of the threads to confirm that the priority levels have been altered successfully. <br /><br />[Video description begins] <em>He highlights the code on lines 50, 51, and 52. Line 50 reads: System.out.println(&#34;\nwalkThread&#39;s priority:&#34; &#43; walkThread.getPriority());. Line 51 reads: System.out.println(&#34;chewThread&#39;s priority:&#34; &#43; chewThread.getpriority());. Line 52 reads: System.out.println(&#34;main thread&#39;s priority:&#34; &#43; Thread.currentThread().getPriority());.</em> [Video description ends] <br /><br />So when we run this well, you can see from the output, that the walkThread priority has been set to 9 and chewThread has a priority of 2. The main thread&#39;s priority has remained at the default of 5. And sure enough, this has not affected the execution of these two threads since they continue to run concurrently. So with that, we are now come across a few of the different methods which are available for Java threads. And in the next video, we will explore how we can set up, and then assign individual threads to Java thread groups.</div>
</div>
<div>
<h2 id="4659a685-f685-4312-848d-f26f526f5a33">
Daemons and Thread Groups
</h2>
<div>[Video description begins] <em>Topic title: Daemons and Thread Groups. Your host for this session is Kishan Iyer.</em> [Video description ends]<br /><br />In this demo, we will start off by exploring the Daemon Status of Java Threads. Threads in Java can be categorized based on the daemon status as either user threads, which are the default types. And then daemon threads, which are meant to run in the background and typically have a lower priority. We will see exactly what that means now.<br /><br />[Video description begins] <em>The ThreadMethods class displays on the screen. It contains various lines of code.</em> [Video description ends] <br /><br />But first, let us replace this code in the main function. <br /><br />[Video description begins] <em>He deletes the lines of code from lines 47 to 57.</em> [Video description ends] <br /><br />And once this has been cleared out, after we initialize the walk and chewThreads, well we have some new code. <br /><br />[Video description begins] <em>He highlights the code on lines 44 and 45. Line 44 reads ThreadwalkThread &#61; new Thread(new Walk());. Line 45 reads: Thread chewThread&#61; new Thread (new ChewGum());.</em> [Video description ends] <br /><br />To start off, we invoke the setDaemon function of chewThread, and set this as a daemon thread. <br /><br />[Video description begins] <em>He highlights the code on line 47 which reads: chewThread.setDaemon(true);.</em> [Video description ends]<br /><br />By default, each thread is a user thread, which is going to be the state of the walk thread, and will also be the state of the main thread. Which we will see when we invoke the isDaemon function for all three threads. <br /><br />[Video description begins] <em>He highlights the code on lines 49, 50, and 51. Line 49 reads: System.out.println(&#34;\nwalkThread&#39;s daemon status:&#34; &#43; walkThread.isDaemon());. Line 50 reads: System.out.println(&#34;chewThread&#39;s daemon status:&#34; &#43; chewThread.isDaemon());. Line 51 reads: System.out.println(&#34;main thread&#39;s daemon status:&#34; &#43; Thread.currentThread().isDaemon());.</em> [Video description ends] <br /><br />And then of course, we will start off the threads. And see if the execution is affected by the daemon status. <br /><br />[Video description begins] <em>He highlights the code on lines 55 and 56. Line 55 reads walkThread.start();. Line 56 reads: chewThread.start();.</em> [Video description ends]<br /><br />So let&#39;s just Save and Run now. Sure enough, it is the daemon status for each of the threads which gets printed first. And then we see the outputs from each of the individual walk and chewThreads. Scrolling through the first few lines of output, we observed that the walk thread as well as the main thread, are not daemon threads by default. However, since we explicitly set chewThread as a daemon, it&#39;s daemon value is true.<br /><br />So what exactly does it mean if a thread is a daemon or not? When it comes to their executions, well, in this particular case, it doesn&#39;t look like it&#39;s daemon status has prevented the chewThread from executing completely. In reality though, this is purely a coincidence. The JVM was still running in order to execute the walkThread which is why it was also able to execute the chewThread which ran concurrently. <br /><br />Since the walkThread is a user thread and not a daemon, the JVM will wait for it. But it will not wait for the chewThread to complete, if that is the only one which is currently running. To demonstrate that, let&#39;s make a few more changes to our main function code. So clearing out the console here, let&#39;s change the way we start each of these threads. Instead of kicking them off virtually at the same time, we can now introduce a delay.<br /><br />[Video description begins] <em>He enters various lines of code from line 55 to line 62.</em> [Video description ends] <br /><br />So we start off walk thread first.<br /><br />[Video description begins] <em>He highlights the code on line 56 which reads: walkThread.start();.</em> [Video description ends] <br /><br />And then effectively wait five seconds before the main thread kicks off the chewThread. <br /><br />[Video description begins] <em>He highlights the code on lines 57 and 58. Line 57 reads walkThread.join(5000);. Line 58 reads: chewThread.start();.</em> [Video description ends] <br /><br />This will mean that the walkThread will finish about five seconds before the chewThread since their overall execution time is about the same. So the question now is, since chewThread is a daemon and walkThreat is not, will the JVM wait for the entire execution of the chewThread?<br /><br />Or will it quit once the walkThread has finished its own execution. The easy way to find out of course is to Save and Run. And once the daemon status has been printed out, we get the output from each of the threads. And let&#39;s scroll to the top and confirm that the walk and main threads are classified as user threads, but chewThread is a daemon. <br /><br />And then moving along to the print statements from each of the walk and chew threads. We observe here that the walk thread have gone through all four iterations in it&#39;s for loop but the chewThread has only gone through two of them. And this conveys the difference between user and daemon threads. The JVM has clearly waited for the walk thread to complete it&#39;s execution. <br /><br />And then of course, the main thread concluded as well, since it was not joined with the chew thread. After that, there were no user threads in the JVM, so it simply exited and just terminated the running chew thread. All right, so now that we have an idea of how daemon and user threads differ in Java, let&#39;s move along to the topic of Thread Groups. So to demonstrate this, let&#39;s just clear out the entire contents of this class and then paste in the new definition.Â <br /><br />[Video description begins] <em>He highlights the code on line 5 which reads: public static class Walk implements Runnable {.</em> [Video description ends] <br /><br />So we now have a slightly different Walk class, which includes a for loop which iterates four times just as before, including the sleep for three seconds. <br /><br />[Video description begins] <em>He highlights the code on line10 which reads: for (int i &#61;1; i &lt; 5; i&#43;&#43;) {.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the code on line13 which reads: Thread.sleep(3000);.</em> [Video description ends] <br /><br />However, in each iteration, we retrieve the name of the threadGroup of the current thread. <br /><br />[Video description begins] <em>He highlights the code on line18 which reads: String threadGroup &#61; Thread.currentThread().getThreadGroup().getName();.</em> [Video description ends] <br /><br />We do this by invoking Thread.currentThread().getThreadGroup().getName(). And then we also retrieve the number of active threads in the current thread group. <br /><br />[Video description begins] <em>He highlights the code on line19 which reads: int activeThreads &#61; Thread.activeCount();.</em> [Video description ends] <br /><br />We then print out these values in a print statement.<br /><br />[Video description begins] <em>He highlights the code on lines 21 and 22. Line 21reads System.out.println(. Line 22 reads: &#34;I&#39;m walking...&#34; &#43; &#34;My group&#34; &#43; threadGroup &#43; &#34; has an activeCount of&#34; &#43; activeThreads);.</em> [Video description ends] <br /><br />The idea here is for us to create multiple thread groups and then assign several threads to each of them. And this output will give us an idea of which ThreadGroup this current thread belongs to. Moving along then to the ChewGum class, this is very much similar to the Walk class. <br /><br />[Video description begins] <em>He highlights the code on line 28 which reads: public static class ChewGum implements Runnable {.</em> [Video description ends] <br /><br />So we have the for loop again, we retrieve the threadGroup and the number of active threads, and then print this out to the console. <br /><br />[Video description begins] <em>He highlights the code on line33 which reads: for (int i &#61;1; i &lt; 5; i&#43;&#43;) {.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code on lines 41 and 42. Line 41 reads: String threadGroup &#61; Thread.currentThread().getThreadGroup().getName();. Line42 reads: int activeThreads &#61; Thread.activeCount();.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the code on lines 44 and 45. Line 44 reads: System.out.println( &#34;I&#39;m chewing...&#34; &#43; &#34;My group&#34; &#43; threadGroup . Line 45 reads: &#43; &#34; has an activeCount of&#34; &#43; activeThreads);.</em> [Video description ends] <br /><br />And finally, we move along to the main function. We start off here by initializing two Thread Groups called group one and group two. For this we call the Thread Group constructor whose argument is a single string, conveying the name of the Thread Group.<br /><br />[Video description begins] <em>He highlights the code on lines 52 and 53. Line 52 reads: ThreadGroup groupOne &#61; new ThreadGroup(&#34;GroupOne&#34;);. Line 53 reads: ThreadGroup groupTwo &#61; new ThreadGroup(&#34;GroupTwo&#34;);.</em> [Video description ends] <br /><br />We follow this up by initializing three different threads, for instances of the walk class. <br /><br />[Video description begins] <em>He highlights the code on lines 55, 56, and 57. Line 55 reads: Thread walkThreadOne &#61; new Thread(groupOne, new Walk());. Line 56 reads: Thread walkThreadTwo &#61; new Thread(groupTwo, new Walk());. Line 57 reads: Thread walkThreadThree &#61; new Thread(groupTwo, new Walk());.</em> [Video description ends] <br /><br />You&#39;ll observe here that when we call the thread constructor, we pass along two arguments. The first is a Thread Group, and then we also pass along an instance of the walk class. The first walk thread is assigned to the groupOne Thread Group. But then the next two walkThreads are assigned to groupTwo. We then move along to two instances of chew threads. <br /><br />The first of these is assigned to groupOne and the second to groupTwo. In a more realistic setting, thread group assignments can be based on a larger task which needs to be carried out. But in this case, we simply wish to see how exactly this assignment can take place. And whether it has any bearing on the executions. So now that we have five different threads, we just invoke start for each of them. <br /><br />[Video description begins] <em>He highlights the code on lines 62 to 66. Line 62 reads: walkThreadOne.start();. Line 63 reads: walkThreadTwo.start();. Line 64 reads: walkThreadThree.start();. Line 65 reads: chewThreadOne.start();. Line 66 reads: chewThreadTwo.start();.</em> [Video description ends]<br /><br />So we will have five concurrent threads in addition to the main thread. Keep in mind here that the default main thread group will exist just as we saw before. And these two new thread groups which we spawned will in fact be children of the main group. We get an idea of how this works from the three print statements at the very end.<br /><br />[Video description begins] <em>He highlights the code on lines 68, 69, and 70. Line 68 reads: System.out.println(&#34;#Active threads for main:&#34; &#43; Thread.activeCount());. Line 69 reads: System.out.println(&#34;#Active threads for GroupOne:&#34; &#43; groupOne.activeCount());. Line 70 reads: System.out.println(&#34;#Active threads for GroupTwo:&#34; &#43; groupTwo.activeCount());.</em> [Video description ends] <br /><br />Where we retrieve the active number of threads for the main thread group, and then also for groupOne and groupTwo. So let&#39;s see exactly how this works by saving and then running. And soon enough the outputs are generated in the console and I&#39;ll just fastforward it to the points where all the print statements are in. And we just examine the output to see exactly what has taken place. We observe that the number of active threads for the main thread group is in fact 6. This is because thread.activeCount does not just return the number of active threads in the current thread group, but it also includes all of it&#39;s sub-thread groups or child thread groups. <br /><br />So this includes the main thread which is running directly in the main group, and also the five threads which belong to groupOne and groupTwo. GroupOne, as we expect, has 2 active threads, and groupTwo has 3. And then we get the outputs from the individual print statements within the 4 loops. <br /><br />So in each case, we do see the active thread count of 3 and 2 for each of the different groups. And let&#39;s scroll all the way down to the bottom, where we can confirm that the thread assignments to the groups are indeed what we expect. So we now know how to create groups of threads in Java. And furthermore, that thread groups can spawn child groups of their own.</div>
</div>
<div>
<h2 id="2e6b6e76-7768-4639-9ada-0773d4115b91">
Coding a Web Page Downloader
</h2>
<div>[Video description begins] <em>Topic title: Coding a Web Page Downloader. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />In some of the labs so far in this learning path, we have caught and then handled an interrupted exception. This is something which can be thrown if a thread happens to be waiting or sleeping. And we need to handle an interrupted exception when we invoke thread.sleep or join. We now explore the case of interrupting a live thread. As you can imagine, this may need to be performed if a thread happens to be working on a task, which is no longer necessary. <br /><br />So rather than have it go ahead with the execution and then consume resources, we can issue an interrupt, and get it to stop. Furthermore, an interrupt may also be necessary if a running thread needs to be prevented from making some modifications. For this demo though, I&#39;m going to create one more class in the com.skillsoft.concurrency package. <br /><br />And this will be called PageDownloader. What we will do in this demo is in fact a more realistic representation of how threads can be used in Java. That is, we will get them to download web pages from the Internet, and we will use multi-threading to enable several web pages to be downloaded concurrently, and thus help us save some time. So once we create this class, well, as always, let me just go ahead and paste the code for it. <br /><br />[Video description begins] <em>The PageDownloader class displays in the main pane. It contains auto-generated lines of code.</em> [Video description ends] <br /><br />let me just go ahead and paste the code for it. Starting off though, with a bunch of input statements, we will be downloading our web pages into files, and then save them on our file systems. <br /><br />[Video description begins] <em>He enters the following lines of code from line 3 to line 8. Line 3 reads: import java.io.BufferedReader;. Line 4 reads: import java.io.BufferedWriter;. Line 5 reads: import java.io.Filewriter;. Line 6 reads: import java.io.InputStream Reader;. Line 7 reads: import java.net.URL;. Line 8 reads: import java.util.Arrays;.</em> [Video description ends] <br /><br />downloading our web pages into files, and then save them on our file systems. For this, we will make use of the BufferedReader, the BufferedWriter, and FileWriter classes. And to enable the downloading of web pages from the Internet, we will need to make use of the InputStreamReader class along with java.net.URL. There are a total of 12 web pages which we will get this program to download.<br /><br />And those will be defined within an array, and to break them up into sub-arrays, we will make use of the java.util.Arrays class. So with the input statements ready, let&#39;s go ahead and make sure that this PageDownloader implements the runnable interface. <br /><br />[Video description begins] <em>He highlights the code on line 10 that reads: public class PageDownloader implements Runnable {.</em> [Video description ends] <br /><br />So that each instance of this class can be executed on separate threads. And this will allow us to download multiple pages concurrently. And then we can proceed and paste some other code. In the multi-threading examples which we have seen so far, each of the threads which we have spawned of the same class do exactly the same operations. In this case though, when we create an instance of the PageDownloader, we will pass along a urlsList. <br /><br />[Video description begins] <em>He highlights the code on line 12 that reads: String[] urlsList;.</em> [Video description ends] <br /><br />And each instance will have a separate list of URLs to download. The set of URLs, will be assigned to this urlsList variable, which is an array of strings.<br /><br />[Video description begins] <em>He highlights the code on line 15 that reads: this.urlsList &#61; urlsList;.</em> [Video description ends]<br /><br />And in fact, this is a variable which is initialized in the PageDownloader constructor. <br /><br />[Video description begins] <em>He also highlights the code on line 14 that reads: public PageDownloader(String[] urlsList) {.</em> [Video description ends] <br /><br />So what exactly is a PageDownloader to do with an array of URLs? Well, this is what is defined within the run method. So we start off by using a for loop to iterate over each of the individual URLs, within the URLsList. <br /><br />[Video description begins] <em>He highlights a section of the code on line 23 that reads: for(String urlString : urlsList).</em> [Video description ends] <br /><br />And we then download the web pages corresponding to those URLs, and save them in the file system. How exactly do we do this? Well, we first initialize a URL using the URL string, which represents an individual URL. <br /><br />[Video description begins] <em>He highlights the code on line 25 that reads: URL url &#61; new URL(urlString);.</em> [Video description ends] <br /><br />All of the URLs which I&#39;m going to use in this demo belong to the Skillsoft website. And each of them contains a skillsoft.com slash, followed by a local path. It is the substring after the last slash character, which we extract ,and then store as the file name variable. And then we also append the .html file extension to this.<br /><br />[Video description begins] <em>He highlights the code on line 26 that reads: String filename &#61; urlString.substring(urlString.lastIndexOf(&#34;/&#34;) &#43; 1).trim() &#43; &#34;.html&#34;;.</em> [Video description ends] <br /><br />So this is going to be the file name when we save down this web page in the local file system. So at this point, we have a URL object, and the file name, to which the web page at the URL will be saved to. And then it&#39;s time for us to initiate a download. To read from the web page, we use a combination of a BufferedReader, and an InputStreamReader. <br /><br />[Video description begins] <em>He highlights the code on line 27 that reads: BufferedReader reader &#61; new BufferedReader(new InputStreamReader(url.openStream()));.</em> [Video description ends] <br /><br />Since this is a course on multi-threading, I won&#39;t go into the specifics of this. But this operation here will allow us to read the contents of the web page at the given URL. And then we use the BufferedWriter in order to write its contents over to the local file. <br /><br />[Video description begins] <em>He highlights the code on line 28 that reads: BufferedWriter writer &#61; new BufferedWriter(new FileWriter(filename));.</em> [Video description ends] <br /><br />The BufferedWriter is first initialized with the local file name. And then following that, we read from the BufferedReader, and then write to the BufferedWriter. Once this is complete, well, we print out to the console that the page has been downloaded, and then we print out the file name. <br /><br />[Video description begins] <em>He highlights the code on line 34 that reads: System.out.println(&#34;Page downloaded to &#34; &#43; filename);.</em> [Video description ends] <br /><br />And following that, we close down the BufferedWriter, since there is no more writing to be performed. <br /><br />[Video description begins] <em>He highlights the code on line 36 that reads: writer.close();.</em> [Video description ends] <br /><br />So this entire iteration of the urlsList, as well as the download of the individual web pages, is placed within a try block. This of course, can result in a number of different exceptions being thrown. However, we just catch the generic exception, and then print out the exception over to the console. <br /><br />[Video description begins] <em>He highlights a section of the code on line 39 that reads: catch (Exception e ).</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code on line 40 that reads: e.printStackTrace();.</em> [Video description ends] <br /><br />In a more realistic setting, you may catch individual exceptions, and handle each of them differently. For the sake of this demo though, this is more than enough, so we move along then to the main function definition. We start off by defining an array of 12 different URLs, which need to be downloaded.<br /><br />[Video description begins] <em>He highlights the lines of code from line 48 to line 59.</em> [Video description ends] <br /><br />And in my case, I have referenced 12 different pages in the Skillsoft website. You are of course free to choose your own set of URLs for this particular demo. But keep in mind the logic which we have defined within the run method. For example, when we download the skillsoft homepage, which is the first of these URLs, the local file name will be home.html. Since we extract the home substring, which appears after the last slash character, and then use that in the downloaded file name. <br /><br />[Video description begins] <em>He highlights a section of the code on line 48. Line 48 reads: String[] urls &#61; new string[]{&#34;https://www.skillsoft.com/home&#34;,.</em> [Video description ends] <br /><br />So after we initialize the set of URLs, let&#39;s see what exactly we do to kick off the page downloader. We start off by performing a single threaded download.<br /><br />[Video description begins] <em>He highlights the code on line 62 which reads: Thread downloaderOne &#61; new Thread(new PageDownloader(.</em> [Video description ends] <br /><br />We initialize a thread called downloaderOne with an instance of PageDownloader. The argument which we pass along to its constructor is the set of URLs. And in fact we pass along the entire set by creating a copy of the URLs array.<br /><br />[Video description begins] <em>He highlights the code on line 63 which reads: Arrays.copyofRange(urls, 0, urls.length)));.</em> [Video description ends] <br /><br />We create this copy by invoking Arrays.copyOfRange, which we will in fact use just a little later, in order to create a subarray out of the URLs array. The first argument here is the array from which subarrays need to be created, and then the start and the end index of the subarray from the source array. In this case, the start index is 0, and the end index is the last position in the URL&#39;s array. So this downloaderOne is set to download each of the 12 URLs. And we will in fact be timing the entire download operation. For that, we initialize a start time variable by retrieving the current time from the system. <br /><br />[Video description begins] <em>He highlights the code on line 67 which reads: long startTime &#61; System.currentTimeMillis();.</em> [Video description ends] <br /><br />Then we invoke downloaderOne.start to kick off the download process.<br /><br />[Video description begins] <em>He highlights the code on line 68 which reads: downloaderOne.start();.</em> [Video description ends] <br /><br />We then make sure that the main thread waits for the download to take place entirely by calling downloaderOne.join, and then we calculate the endTime.<br /><br />[Video description begins] <em>He highlights the code on line 70 which reads: downloaderOne.join();.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the code on line 71 which reads: long endTime &#61; System.currentTimeMillis();.</em> [Video description ends] <br /><br />The total time for the download is a difference between the endTime and the startTime.<br /><br />[Video description begins] <em>He highlights the code on line 73 that reads: System.out.println(&#34;Total time taken: &#34; &#43; (endTime-startTime)/1000 &#43; &#34;s&#34;);.</em> [Video description ends] <br /><br />And since this is a value in milliseconds, we divide by 1,000 to get the time in seconds. Since we invoked the join method here, an InterruptedException can be thrown, which we catch, and then handle by simply printing out the exception to the console.<br /><br />[Video description begins] <em>He highlights the code on lines 75, 76, and 77. Line 75 reads: catch (InterruptedException e ){. Line 76 reads: e.printStackTrace();. Line 77 reads: }.</em> [Video description ends] <br /><br />So now that we have defined our PageDownloader, in the next video we will run this code and make sure that the pages are downloaded exactly as defined. And we will also cover how this download can be sped up by having two threads work on it.</div>
</div>
<div>
<h2 id="450b7f6f-0da0-48ff-9058-7f5fe24a13c7">
Downloading Pages with Multithreading
</h2>
<div>[Video description begins] <em>Topic title: Downloading Pages with Multithreading. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />In the previous video, we coded up this page downloader. And we&#39;re now set to run it as a single thread which downloads 12 different pages from the SkillSoft website. <br /><br />[Video description begins] <em>The PageDownloader class displays in the main pane. It contains multiple lines of code. The host highlights the code on line 62 and 63.</em> [Video description ends] <br /><br />So to do that, let&#39;s just save things down, and then run. And soon enough, we begin to see the System.out.println statements recorded in the console. You see that, at least on my machine, this download took a total of 34 seconds. But given I fast forwarded the recording, it seemed to take less time. What is more important, however, is whether the files were indeed downloaded to the file system. Since I&#39;m running this program out of Eclipse, this has been downloaded to the workspace for my Eclipse project. <br /><br />So I&#39;m just going to navigate over to that. I have now brought up this directory, which is the main workspace directory for the project. And upon opening it, well, we can see here that the 12 different pages have indeed been downloaded as HTML files. To make sure that these are valid HTML documents, I&#39;m just going to pick one of these at random and bring it up in a browser. Well, it looks like the download has taken place successfully, and that the SkillSoft page has been downloaded to the file system. So heading back to the IDE, we now know that this downloader does do its job. And when run in single-threaded mode, it&#39;s able to download all 12 URLs in about 34 seconds. The question now is, can we do better if we split this task among two separate but concurrent threads? <br /><br />Well, that is precisely what we&#39;ll now do. And we don&#39;t need to make any change to the run method for that. And we&#39;ll just modify this section of code inside the main function. [Video description begins] <em>He deletes the lines of code from lines 62 to 77.</em> [Video description ends] So instead of just initializing and then starting off one thread, well, this time we will split these 12 URLs to be downloaded by two different threads. And to make this happen, we just need to make a few minor tweaks to the code we had previously. So we initialize two different threads called downloaderOne and downloaderTwo.<br /><br />[Video description begins] <em>He highlights the code on lines 62 and 63. Line 62 reads: Thread downloaderOne &#61; new Thread(new PageDownloader(Arrays.copyofRange( urls,0 ,6)));. Line 63 reads: Thread downloaderTwo &#61; new Thread(new PageDownloader(Arrays.copyofRange(urls, 6, urls.length)));.</em> [Video description ends] <br /><br />Both of these are initialized with instances of PageDownloader. And the only difference between these two PageDownloader instances is that they work on a different set of URLs. That is, the array we initialize each of them with is different. In the case of the first PageDownloader, we pass along the URLs from locations zero through five in our URLs array. We do this by creating a new array out of that subarray by invoking arrays.copyOfRange. <br /><br />And we specify a lower bound of 0 and an upper bound of 6 when we specify the subarray. Keep in mind that the last element of the subarray is one less than the upper bound. So downloaderOne will work on the URLs at location zero through five of the URLs array. And downloaderTwo will work on the URLs starting at position six going all the way up to the end of the URLs array. Each of these PageDownloader instances will have six URLs to download. And then within the try block, we first calculate the start time, then kick off each of the downloader instances. <br /><br />[Video description begins] <em>He highlights the code on lines 67 which reads: long startTime &#61; System.currentTimeMillis();.</em> [Video description ends] <br /><br />And following these two start invocations, the two downloaders will be running concurrently. <br /><br />[Video description begins] <em>He highlights the code on lines 68 and 69. Line 68 reads: downloaderOne.start();. Line 69 reads: downloaderTwo.start();.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code on lines 71 and 72. Line 71 reads: downloaderOne.join();. Line 72 reads: downloaderTwo.join();.</em> [Video description ends]<br /><br />We then make sure that the main thread waits for those downloaders to finish their job. And then we calculate the end time and then print out the total time taken. <br /><br />[Video description begins] <em>He highlights the code on line 73 which reads: long endTime &#61; System.currentTimeMillis();.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the code on line 75 that reads: System.out.println(&#34;Total time taken: &#34; &#43; (endTime-startTime)/1000 &#43; &#34;s&#34;);.</em> [Video description ends] <br /><br />So we have now coded up two concurrent downloaders to download six web pages each. Well, we can now save things down and then run this program. And soon enough, we will see the pages getting downloaded one by one. And at least in my case, this total execution took just about 17 seconds. So in fact it&#39;s exactly half of the previous run where we ran in a single threaded mode.<br /><br />So this is a benefit of multi-threading in Java. If you can break up a task into a number of subtasks which can be executed concurrently, multi-threading can help us save a lot of time. Feel free to experiment a little more by breaking up this download process into four subtasks and run each of those concurrently. Where each thread downloads three web pages. And you are likely to see a significant drop in time, though it may not necessarily halve. We can scroll up in the console output, just to make sure that all of the 12 pages have been downloaded.<br /><br />And once we have that, let&#39;s make a little change to our downloader. And this is something which will enable it to be interrupted during the download process. Specifically, I&#39;m going to go all the way to the bottom of the run function definition. And right after we closed down the buffered writer, we make a call to Thread.sleep, where we sleep this thread for one second.<br /><br />[Video description begins] <em>He enters the following code on line 37: Thread.sleep(1000);.</em> [Video description ends] <br /><br />This is required for a thread to be interrupted. And we will see later on that it&#39;s not possible for us to interrupt a running thread. Of course, the introduction of this sleep will cause this thread to run just a little bit slower. Which we can confirm by once again running the program, and at least on my machine, the execution took a total of 22 seconds. So given that our downloader threads wait for one second at each iteration, it is possible for us to interrupt it. And we will explore exactly how this can be done in the next video.</div>
</div>
<div>
<h2 id="0b7acd15-68bb-435d-a0d6-27f7ad91380b">
Interrupting Running Threads
</h2>
<div>[Video description begins] <em>Topic title: Interrupting Running Threads. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />At the end of the previous video, we introduced this new line within the run method of our PageDownloader.<br /><br />[Video description begins] <em>The PageDownloader class displays in the main pane. It contains multiple lines of code. The host highlights the code on line 37.</em> [Video description ends] <br /><br />This is where we put the thread sleep for one second after each web page has been downloaded. And this will allow the download a thread to be interrupted. So how exactly can we perform this interrupt? Well, for that, let&#39;s head over to the main function, and inside the try block we just need to make a minor modification. Let&#39;s just clear out these lines. <br /><br />[Video description begins] <em>He deletes the code on lines 74 to 76.</em> [Video description ends] <br /><br />And then paste in this section of code. <br /><br />[Video description begins] <em>He enters the following lines of code. Line 74 reads Thread.sleep(10000);. Line 75 reads: downloaderOne.interrupt();. Line 76 reads: downloaderTwo.join();. Line 77 reads: long endTime &#61; System.currentTimeMillis();.</em> [Video description ends] <br /><br />What exactly do we do here? Well, after we start off the two downloaded threads, we get the main thread to pause, that is to sleep, for ten seconds. At least on my machine this is enough time for each of the downloaded threads to download some but not all of the web pages. In the last run, the downloaded threads took about 22 seconds to run. So I expect that half of the pages will be downloaded after 10 seconds. <br /><br />And this is when we interrupt the first thread. To do this, we invoke the method downloaderOne.interrupt. And this has the effect of setting the interrupt flag for downloaderOne. This interrupt flag will only be checked by the downloaderOne thread when it goes into sleep mode. So if at the time of issuing this interrupt, it was already in the middle of a download process that will go on unimpeded. <br /><br />At the end of the download however, it will go into sleep for one second, in which case that thread will be interrupted. And you&#39;ll see exactly what happens in such a case. We then join the downloaderTwo thread with the main thread. So we treat the two downloader threads differently. In the case of downloaderOne, we say that we will allow it to download whatever it can in 10 seconds and then interrupted beyond that. <br /><br />But for downloaderTwo, we will allow it to take as much time as it wants and only then will the main thread proceed. This is when we calculate the end time and then we also print the total time taken at the end, to see this code in action, let&#39;s save and run. <br /><br />[Video description begins] <em>He highlights the code on line 79 that reads: System.out.println(&#34;Total time taken: &#34; &#43; (endTime-startTime)/1000 &#43; &#34;s&#34;);.</em> [Video description ends] <br /><br />And in a few moments, we see that the pages are starting to get downloaded. But after about 10 seconds, well it looks like one of our threads has thrown an interrupted exception. I&#39;ll just play the recording once again and allow the downloader to go through. And it looks like the total time taken is still 22 seconds. This is in fact the time taken for the downloader to thread.<br /><br />Since downloaderOne was interrupted after 10 seconds. In fact, from this exception message, we can see that it was the sleep of the thread which was interrupted and there is a reference to line number 37 in my PageDownloader.Java source file. That is in fact the same line at which thread.sleep has been invoked. Scrolling up in the console. We observed that by the point it was interrupted, the downloaderOne thread did in fact complete the download of a few pages. <br /><br />For example, home.html, partners.html, as well as about.html were downloaded by the first thread. And by this point, downloaderTwo had also downloaded three pages. But after the interruption, well, downloaderOne simply stopped its execution. But downloaderTwo continued and then processed these last three html pages. So we now know exactly how threads can be interrupted in java. It&#39;s now time for us to test out what I had mentioned earlier that only waiting or sleeping threads can be interrupted. Well, to put this to the test let&#39;s first clear out the console. <br /><br />And we leave the main function exactly as it is, where we interrupt downloaderOne 10 seconds after it has been started. And then we head over to the last line of the run method, and then comment out this call to thread.sleep. <br /><br />So when we invoke downloaderOne.interrupt from the main function, it will set the interrupt flag for the downloader thread. However, that flag will not be checked since this thread does not go to sleep. To test that out, let&#39;s hit save, and then run the program once again. And the downloads just go through for both thread one and thread two on my machine. This took six seconds fewer than it did last time, since we don&#39;t sleep for a second after each download. <br /><br />And it&#39;s clear from this output that both of the threads ran through to completion. So thread one was clearly not interrupted here. So a question is, is it possible for us to have a thread be interrupted without actually putting it to sleep? Well, the answer is yes. To demonstrate this, let&#39;s go up within the run function of our PageDownloader and at the beginning of each iteration of the for loop, that is, before we begin the download of any file, well, we will check for a condition. <br /><br />[Video description begins] <em>He enters the following lines of codes from line 24 to line 27. Line 24 reads: if (Thread.currentThread().is Interrupted()) {. Line 25 reads: throw new InterruptedException(Thread.currentThread().getName()&#43;. Line 26 reads: &#34;interrupted&#34;);. Line 27 reads: }.</em> [Video description ends] <br /><br />Within this if statement, we check whether the interrupt flag has been set for this thread. For which we invoke Thread.currentThread().isInterrupted(). And if it is, well, then we proactively throw an interrupted exception. And within this exception, we supply our own custom message, where we print out the thread name and then mention that it has been interrupted. So just to summarize, before each page is downloaded, the thread will check whether it has been interrupted. <br /><br />And if it has been, it will raise this interrupted exception. So, can a thread be interrupted if it never goes to sleep? Well, we save and then run to find out. And after the initial files have been downloaded, sure enough, after 10 seconds, we see an interrupted exception. And it is clear from the output, that it is the first thread with the name of thread zero, which has been interrupted. When we scroll further up in the console. We observed that the first thread did in fact download four html pages, right down to industries.html. <br /><br />However, it was clearly interrupted before it could download the next two pages in its pipeline. And as we seen before, thread two goes on, as though nothing has really happened. One final question, which we will look to answer here, is where exactly this interrupted exception was raised? <br /><br />Well, we can just click on this message here, which will direct us to line number 25 of pagedownloader.Java. At least in my case, and the line which gets highlighted, is where we explicitly throw this InterruptedException. So with this check of the interrupted flag at the start of each iteration, we make sure that a thread can be interrupted, even without ever going to sleep.</div>
</div>
<div>
<h2 id="e8e1cbef-4a70-42d7-ae4a-05176c77890d">
Course Summary
</h2>
<div>[Video description begins] <em>Topic title: Course Summary</em> [Video description ends]<br /><br />Now that you have finished this lab only course on creating and launching Java threads, let&#39;s summarize the topics which we covered. We started off by defining a task which can be executed in a thread using the runnable interface and the thread class. We then moved on to running multiple concurrent threads, and then having one thread wait for another to finish its job. <br /><br />And we did this using the join function. We then covered some of the properties of a Java thread and how they affect its behavior from its priority level to its demon status. Finally, we looked into how the execution of a thread can be interrupted in order to stop or modify the course of its execution. <br /><br />At this point, you have some familiarity with concurrent programming and the implementation of multithreading in Java. You recognize the steps involved in spawning and managing threads, as well as the different phases a thread goes through in its life cycle. This sets you up rather nicely for a course covering more advance topics, such as synchronization of threads using the synchronized key words as well as lock objects.</div>
</div>
</body>
</html>
