<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Multithreading and Concurrency in Java: Thread Synchronization & Locks Transcript">
<title>Multithreading and Concurrency in Java: Thread Synchronization & Locks Transcript</title>
</head>
<body>
<h1>Multithreading and Concurrency in Java: Thread Synchronization & Locks</h1>
<p><p>In this demo-only course you will cover the basics of synchronization of threads in Java in order to prevent the unpredictability of the race condition. You will get experience with the implementation of synchronized functions and blocks, and also the use of Java lock objects such as the ReentrantLock and StampedLock.</p></p>
<div>
<h2>Table of Contents</h2>
<ol><li><a href="#04e12778-0dd1-4d35-85e0-2cacf002927c">Course Overview</a></li>
<li><a href="#cb611313-5b39-48b5-a418-c704b369756d">Synchronized Functions</a></li>
<li><a href="#221c5151-9eca-4e7c-bb7d-a9456d3606d4">Working with Multiple Shared Resources</a></li>
<li><a href="#d979e3d8-d51e-4e57-a31b-836e9c3fe7aa">Synchronized Blocks</a></li>
<li><a href="#391ddbf0-e72c-4bcb-a1b4-213b33c05ac6">Simulating a Deadlock</a></li>
<li><a href="#f6215c68-0275-4e75-a8e0-b45b0ecfcb6f">Deadlock Avoidance</a></li>
<li><a href="#0deba41b-6200-408f-bffb-cfe7270ecc7a">Explicit Locking in Java</a></li>
<li><a href="#f5f5dd25-c866-4cb2-b363-e6797fdc7349">The tryLock() Method</a></li>
<li><a href="#1342fc27-6e70-450b-bda1-0b92296e3ef8">Invoking tryLock() with a Timeout</a></li>
<li><a href="#54f74d19-5bba-4340-92bc-3692747b96d1">StampedLock in Java</a></li>
<li><a href="#c812f20b-3f7f-4964-82b4-3000d64149c6">The readLock() for StampedLock Instances</a></li>
<li><a href="#d90712c0-6729-44ae-91a3-0a4091593e62">Course Summary</a></li>
</ol></div>
<div>
<h2 id="04e12778-0dd1-4d35-85e0-2cacf002927c">
Course Overview
</h2>
<div>[Video description begins] <em>Topic title: Course Overview</em> [Video description ends]
<p>Hi and welcome to this course, an introduction to concurrent programming in Java. [Video description begins] <em>Your host for this session is Kishan Iyer. He is a software engineer and big data expert.</em> [Video description ends] My name is Kishan Iyer and I will be your instructor for this course. A little about myself first. I have a master&#39;s degree in computer science from Columbia University, and have previously worked in companies such as Deutsche Bank and WebMD in New York.</p>
<p>I presently work for Loonycorn, a studio for high-quality video content. Concurrent programming skills are among the most useful tools in the armory of any Software engineer. The ability to run several task simultaneously, even if they&#39;re sub-tasks created out of larger tasks can greatly improve your program&#39;s performance. This can save your organization a lot of time or even deliver a better experience to your end-users.</p>
<p>And the Java programming language offers a variety of options when it comes to implementing concurrent programming through multi-threading. This course is very much hands on and covers the management of concurrent threads which update common resources. This management is performed using synchronized functions and blocks as well as locks.</p>
<p>We begin by simulating a race condition in a multi-threaded Java program and how this can be prevented using synchronized functions. We then cover the more granular way of achieving thread synchronization using synchronized blocks. We then look at how more advanced synchronization operations can be performed using locks.</p>
<p>This includes the use of built-in locks in Java, such as the reentrant lock and the stamped lock. While doing this, we cover one of the big drawbacks of locking, the possibility of deadlocks. We simulate a deadlock and look at some of the options available to prevent their occurrence.</p>
<p>Once you finish the labs in this course, you will be quite familiar with the nitty-gritty of managing a multi-threaded application. You can move along then to a more advance course involving the implementation of the concurrency tools you will have covered, for instance, solving the producer consumer problem.</p></div>
</div>
<div>
<h2 id="cb611313-5b39-48b5-a418-c704b369756d">
Synchronized Functions
</h2>
<div>[Video description begins] <em>Topic title: Synchronized Functions. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>So far in this learning path, we have implemented multi-threading in Java on a fair number of instances. <br /><br />[Video description begins] <em>The screen displays an Eclipse IDE window. In the left pane, various projects are present. In the main pane, there is space for entering lines of code. At the bottom, there is a Console tab for showing the output.</em> [Video description ends] <br /><br />We have also seen in the case of a page downloader, how this can greatly help speed up certain tasks.</p>
<p>However, what we have not covered is when multiple-threads compete for access to a specific resource. That is precisely what we will now take a look at. And we will also cover how the race for a particular resource can, in fact, be avoided by implementing synchronization between different threads.</p>
<p>We will stick with the com.skillsoft.concurrency package we have been using so far in this learning path. And within this, let&#39;s now create a new class. We can call this one Synchronization. Just as a reminder, I am using Java 13 as my runtime environment. <br /><br />[Video description begins] <em>He creates a new tab, Synchronization.java. He highlights the following line of code in Line 3: public class Synchronization implements Runnable {.</em> [Video description ends]</p>
<p>Once this class have been created, well the first thing we do is to make sure that it implements the runable interface so that we can create multiple instances and get them to run on separate threads. And then let me go ahead and paste the code and then walk through the blocks one at a time. So we will have multiple instances of the Synchronization class. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 5: private static int myNum;.</em> [Video description ends]</p>
<p>However, all of them will compete to update this static myNum integer. Given it is a static int, it means that no matter how many instances we create of the Synchronization class, they&#39;ll all be accessing the same myNum variable. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 7: private static final int NUM_ITERATIONS &#61; 10;.</em> [Video description ends]</p>
<p>In fact, all of those threads will be updating myNum and the number of updates which they perform will be regulated by the value of NUM_ITERATIONS. By setting this to be static and final, we effectively consider this a constant. And in the first run of our programs, the number of iterations is equal to 10. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 9: public static class CommonCounter {.</em> [Video description ends] <br /><br />And the way we update myNum is through a common counter object. So we declare a static class called CommonCounter so that there is just one for each instance of our Synchronization class. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 11: public static void incrementCounter(){.</em> [Video description ends]<br /><br />And this in turn contains a single static method called incrementCounter. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 12: myNum&#43;&#43;;.</em> [Video description ends] <br /><br />Where each invocation of incrementCounter simply increments the value of myNum.</p>
<p>So, multiple instances of our Synchronization class, we&#39;ll use the same commonCounter object in order to increment myNum. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 16 to Line 17: Line 16: &#64; Override Line 17: public void run(){.</em> [Video description ends]<br /><br />And the way they perform the increment is defined in the run method. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 18 to Line 20: Line 18: for (int i &#61; 0; i &lt; NUM_ITERATIONS; i&#43;&#43;){ Line 19: CommonCounter.incrementCounter(); Line 20: }.</em> [Video description ends] <br /><br />So within this, we have a for loop. And the number of iterations is determined by the NUM_ITERATIONS variable. And in each iteration, we perform an increment of myNum through the CommonCounter. Given the value of NUM_ITERATIONS is now 10, when we create the threads, each of them will perform 10 increments of the myNum variable.</p>
<p>As for the definition of those threads, well, this is what takes place within the main function. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 23: public static void main(String[] args (){.</em> [Video description ends]<br /><br />So we create threadOne and threadTwo, each of which are threads, <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 25 to Line 26: Line 25: Thread threadOne &#61; new Thread(new Synchronization()); Line 26: Thread threadTwo &#61; new Thread(new Synchronization());.</em> [Video description ends]<br /><br />which are initialized with instances of the Synchronization class. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 28: System.out.println(&#34;Start value of myNum: &#34; &#43; myNum);.</em> [Video description ends] <br /><br />Following that, we print out to the Console the starting value of the static myNum variable, which we expect will be 0. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 31 to Line 32: Line 31:threadOne.start(); Line 32: threadTwo.start();.</em> [Video description ends]<br /><br />And then we start off the two threads.</p>
<p>When that happens, we expect that each of them will increment myNum ten times, and the final value of myNum should be 20. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 34: Thread.sleep(5000);.</em> [Video description ends]<br /><br />We make sure that the main thread sleeps for five seconds, which is more than enough time for both of our threads to conclude. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 39: System.out.println(&#34;End value of myNum: &#34; &#43; myNum);.</em> [Video description ends] <br /><br />And then we print out the final value of myNum, which I have mentioned, we expect to be 20. All right, so what happens if you were to save down and then run this program? Well, within a few moments, we see that the Start value of myNum was indeed 0, but its End value is 11, in my case, at least. This is a classic case of the race condition. Both of our threads have tried to access the myNum variable and carry out an update without any synchronization.</p>
<p>When this happens, the update which takes effect is effectively determined by a race between the two threads and the final output is unpredictable. In fact, in your case, you may still see the value of 20 as the final value of myNum. But you may, in fact, get a different value of the variable if you run this program a few times. Well, in my case, I&#39;m first going to clear out the Console and then increase the number of iterations from 10 to 100. <br /><br />[Video description begins] <em>He edits the line of code in Line 7 to the following: private static final int NUM_ITERATIONS &#61; 100;.</em> [Video description ends]</p>
<p>Then, when I hit Save and Run, well, it turns out that the End value of myNum now is in fact 200, which is what we expect. But again, this was purely down to luck and you cannot always expect this output without any synchronization. To reduce the chances of this accidental correct output, well, let&#39;s further increase the number of iterations, this time to 1000 and then rerun.</p>
<p>And in my case, the End value of myNum is less than what we consider the correct value of 2000. In fact, this is borne out if you were to perform a further increase in the number of iterations, this time to 10,000, in my case, and on running the program, well, the End value shows up as a little over 13,000. And in fact, without making any further changes, I&#39;m just going to save and run once again. And then the End value shows up as about 15,500.</p>
<p>In fact, you can run this program any number of times. And with this number of iterations, it is likely that you&#39;ll get a different End value of myNum for each run. And this is clearly not a desirable state of events. What we really need is for all of our threads to synchronize their updates to the shared resource. And there are a number of different ways in which this can be achieved in Java.</p>
<p>And we will, in fact, start with one of these immediately. <br /><br />[Video description begins] <em>He edits the line of code in Line 11 to the following: public static synchronized void incrementCounter(){.</em> [Video description ends]<br /><br />When we head over to the incrementCounter function, well, it is this function to which we want to synchronize access and make sure that only one thread is able to invoke it at any given time. And the way to do this is to define this function to be a synchronized function. By adding the synchronized keyword to any function definition, we make sure that all of the threads which access the function from its owning object will do so in a synchronized manner.</p>
<p>In our example, both threadOne and threadTwo, which run instances of the synchronization class, access the incrementCounter method using the CommonCounter object. And this is in fact, a shared object between the two since it is static. And when they invoke incrementCounter now, well, their actions will be synchronized. To see the effect of this, let&#39;s save things down and then run the program. And the End value of myNum is 20,000.</p>
<p>So it does look like the inclusion of the synchronized keyword. Make sure that only one thread is allowed to execute incrementCounter at any given time. Now of course, there is a rather small chance that the output which we see here is purely a fluke. And just to eliminate that possibility, let&#39;s head back to the code and then further increase the number of iterations to 100,000.</p>
<p>And when we Save and Run, well, the End value of myNum is now 200,000. In fact, just to be sure, you can run your program any number of times and on each occasion the final value of myNum should be the number of threads times the number of iterations. So now that we know how to define a function as synchronized in order to synchronize access to it. In the next video, we will explore further uses of the synchronized keyword. For example, to create a synchronized block of code.</p></div>
</div>
<div>
<h2 id="221c5151-9eca-4e7c-bb7d-a9456d3606d4">
Working with Multiple Shared Resources
</h2>
<div>[Video description begins] <em>Topic title: Working with Multiple Shared Resources. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>In the previous video, we saw how setting a function to be synchronized regulates access to that function. <br /><br />[Video description begins] <em>The screen displays the Eclipse IDE window in continuation with the previous video. He highlights the following lines of code from Line 11 to Line 13: Line 11: public static synchronized void incrementCounter(){ Line 12: myNum&#43;&#43;; Line 13: }.</em> [Video description ends]<br /><br />That is, it ensures that only a single thread is able to invoke that function at any given time. While doing so however, we were accessing some static resources, which is not always the case when you are working with a real application. So to make our example just a tad more realistic, let&#39;s go ahead and create some new classes.</p>
<p>We will stick with the com.skillsoft.concurrency package, and then create a New, Class within this which we will name CommonCounter. So this in fact is going to serve as a variable whose value can be incremented. And its variable can also be the value of a counter. <br /><br />[Video description begins] <em>He creates a new tab, CommonCounter.java. He highlights the following line of code in Line 5: private int myNum &#61; 0;.</em> [Video description ends]<br /><br />So let&#39;s go ahead and paste the code. And you&#39;ll observe that just as before, there is an integer called myNum here.</p>
<p>However, this is not a static integer, and its value is initialized to 0. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 7 to Line 9: Line 7: public void incrementCounter(){ Line 8: myNum&#43;&#43;; Line 9: }.</em> [Video description ends]<br /><br />Beyond that, we also define an incrementCounter method. And within this, we simply up the value of myNum by 1. In this first version of this common CounterClass, we don&#39;t set this to be a synchronized function.</p>
<p>And we will see exactly what happens when we create a race condition. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 11 to Line 13: Line 11: public int getMyNum(){ Line 12: return myNum; Line 13: }.</em> [Video description ends] <br /><br />Furthermore, to check the value of the myNum variable, we implement a getter function. So getMyNum simply returns the latest value of myNum. So now that we have defined a shared resource, which can be updated by multiple threads, let&#39;s define what each of those threads will look like.</p>
<p>So we will now create another runnable Class within the same package, and this will be called CounterIncrementer. <br /><br />[Video description begins] <em>He creates a new tab, CounterIncrementor.java. He highlights the following lines of code from Line 3 to Line 5: Line 3: public class CounterIncrementor{ Line 5: }.</em> [Video description ends]<br /><br />So this will contain the run method where the counter is incremented. So once we choose to Finish, well, the class is created. And of course, the first thing we need to do is to implement the runnable interface. <br /><br />[Video description begins] <em>He edits the line of code in Line 3 to the following: public class CounterIncrementor implements Runnable {. He pastes various lines of code.</em> [Video description ends]</p>
<p>Beyond that, this CounterIncrementer contains two private variables. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 5 to Line 6: Line 5: private CounterIncrementor myCounter; Line 6: private int numIterations;.</em> [Video description ends] <br /><br />One of these, is the CommonCounter instance, which it is meant to update, and the number of updates which it will perform is the other variable specified by numIterations. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 8: public CounterIncrementor(CommonCounter commonCounter, int numIterations){.</em> [Video description ends] <br /><br />In fact, both of these variables need to be supplied when a CounterIncrementer instance is created, which is why we have these in the constructor. And then we define the run method. This is similar to what we saw previously, where for <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 16 to Line 18: Line 16: for (int i &#61; 0; i &lt; numIterations; i&#43;&#43;){ Line 17: myCounter.incrementCounter(); Line 18: }.</em> [Video description ends] <br /><br />the number of iterations, we invoke myCounter.incrementCounter. So we now have a clear separation between the shared resource definition which are the common counter, and the class definition for the instances which updated. We are not quite done with our modifications though. So we head back to the Synchronization.java source file. And I&#39;m just going to clear out the entire contents. And furthermore, we&#39;ll also make sure that this class no longer implements the runnable interface. <br /><br />[Video description begins] <em>He edits the line of code in Line 3 to the following: public class Synchronization {.</em> [Video description ends] <br /><br />Because we will simply use this in order to create instances of our new CounterIncrementer, which of course implements runnable on its own. And the Synchronization.java will simply serve as a wrapper to initialize the threads and to run them. This becomes clear when we paste the code for this. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 5: private static final int NUM_ITERATIONS &#61; 10000;.</em> [Video description ends]</p>
<p>We start off by defining a constant called NUM_ITERATIONS, which we initialized to 10,000, and then within the main function where we create the shared resource. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 9: CommonCounter commonCounter &#61; new CommonCounter();.</em> [Video description ends] So we have a single instance of CommonCounter. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 11 to Line 12: Line 11: Thread threadOne &#61; new Thread(new CounterIncrementor( commonCounter, NUM_ITERATIONS)); Line 12: Thread threadTwo &#61; new Thread(new CounterIncrementor( commonCounter, NUM_ITERATIONS));.</em> [Video description ends] <br /><br />And then beyond that, we initialize two threads, threadOne and threadTwo, and each of these will run instances of CounterIncrementer. Note the arguments which we pass along to the constructor of these CounterIncrementer instances. Both of them use the same shared CommonCounter resource. So the updates which they perform will be on the same resource, which means that a race condition will be the result, since access to the commonCounter is not synchronized.</p>
<p>Furthermore, we also define the number of iterations by passing these along as an argument as well. And then once the threads have been initialized, we print out to <br /><br />[Video description begins] <em>He highlights the following line of code in Line 14: System.out.println(&#34;Start value of counter: &#34; &#43; commonCounter.getMyNum());.</em> [Video description ends]<br /><br />the Console the initial value of the myNum variable in the commonCounter. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 17 to Line 18: Line 17:threadOne.start(); Line 18: threadTwo.start();.</em> [Video description ends]<br /><br />Then we start off each of the CommonCounter threads. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 20: Thread.sleep(5000);.</em> [Video description ends] <br /><br />And then we put this main thread to sleep for 5 seconds. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 26: System.out.println(&#34;End value of counter: &#34; &#43; commonCounter.getMyNum());.</em> [Video description ends]</p>
<p>And then finally, we print out the End value of the commonCounter. All right, so this is effectively the same as what we had implemented previously. But let&#39;s just make sure first that a race condition is encountered. So we save things down and then run. And what we observe in the output, at least in my case, is that the End value is 20,000.</p>
<p>Well, it looks like there was no race condition here. Does that mean that access to the counter was synchronized? Or was this merely a fluke? Well, for that, let&#39;s just clear out the Console and then run the program once again. And the output this time confirms that what we saw on the previous run on my machine was a total fluke.</p>
<p>In fact, for another confirmation I&#39;m just going to rerun this program. And the End value appears as 19,000. And running it for the fourth time, again, it is clear that access to this variable is not synchronized. All right, to make sure that there is no race condition anymore,</p>
<p>let&#39;s head back to CommonCounter.java. And this time, we add the synchronized keyword for the incrementCounter function.<br /><br />[Video description begins] <em>He edits the line of code in Line 7 to the following: public synchronized void incrementCounter(){.</em> [Video description ends] <br /><br />And heading back to CounterIncrementer after saving this down, well, there is nothing for us to change here. All of the calls to incrementCounter within the for loop will now be synchronized.</p>
<p>To test this out though, let&#39;s just save and run. And sure enough, the End value shows up as 20,000. So we now have two concurrent threads, which are able to access a single shared resource in a synchronized manner. Heading back to the Synchronization source, however, we will now add a little more complexity by clearing out the contents of the main function and then pasting in this new code. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 9 to Line 10: Line 9: CommonCounter commonCounterOne &#61; new CommonCounter(); Line 10: CommonCounter commonCounterTwo &#61; new CommonCounter();.</em> [Video description ends]</p>
<p>What we have in this case are two instances of CommonCounter, commonCounterOne and commonCounterTwo.<br /><br />[Video description begins] <em>He highlights the following lines of code from Line 12 to Line 14: Line 12: Thread threadOne &#61; new Thread(new CounterIncrementor( commonCounterOne, NUM_ITERATIONS)); Line 13: Thread threadTwo &#61; new Thread(new CounterIncrementor( commonCounterTwo, NUM_ITERATIONS)); Line 14: Thread threadThree &#61; new Thread(new CounterIncrementor( commonCounterTwo, NUM_ITERATIONS));.</em> [Video description ends] <br /><br />And we then create three instances of the CounterIncrementer, and of course, each of these run on separate threads. The first of these references commonCounterOne, while the next to the reference commonCounterTwo. So access to commonCounterTwo in this case should be synchronized. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 16 to Line 17: Line 16: System.out.println(&#34;Start value of counterOne: &#34; &#43; commonCounterOne.getMyNum()); Line 17: System.out.println(&#34;Start value of counterTwo: &#34; &#43; commonCounterTwo.getMyNum());.</em> [Video description ends]</p>
<p>We then print out the initial values of commonCounters One and Two. We then start of the three threads put the main thread to sleep for <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 20 to Line 22: Line 20:threadOne.start(); Line 21: threadTwo.start(); Line 22: threadThree.start();.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the following line of code in Line 24: Thread.sleep(5000);.</em> [Video description ends] <br /><br />5 seconds, which is enough time for them to go over all of the iterations. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 30 to Line 31: Line 30: System.out.println(&#34;End value of counterOne: &#34; &#43; commonCounterOne.getMyNum()); Line 31: System.out.println(&#34;End value of counterTwo: &#34; &#43; commonCounterTwo.getMyNum());.</em> [Video description ends] <br /><br />And then print out the final values of the resources which we have created. So we should expect that CounterOne has a value of 10,000. And that CounterTwo will have a value of 20,000, no matter how many times we run this code.</p>
<p>So we now have three threads which work with two resources. threadOne has exclusive access to commonCounterOne. Whereas threadTwo and thread three share commonCounterTwo. So when we run, well, sure enough, the initial values of both the counters are 0. And the final values are in line with our expectations, 10,000 and 20,000.</p>
<p>Just to make sure that this is no fluke, I&#39;ll just run once again. And if the same output which is generated and run a third time produces the same values for counters One and Two. All right, so we&#39;re now convinced that the synchronized keyword works but for a final confirmation, let&#39;s head back to CommonCounter. And then remove the synchronized keyword, so that we once again create a race condition. <br /><br />[Video description begins] <em>He edits the line of code in Line 7 to the following: public void incrementCounter(){.</em> [Video description ends] <br /><br />Well, to test this, we head back to Synchronization.java.</p>
<p>And we&#39;ll then run the code. Sure enough, the value of counterOne at the end is 10,000. Since there is just a single thread which accesses it, but for counterTwo the final value will be unpredictable. Running it for a second time, I see 13,000 odd. And then for a third time, it&#39;s in the range of 14,000.</p></div>
</div>
<div>
<h2 id="d979e3d8-d51e-4e57-a31b-836e9c3fe7aa">
Synchronized Blocks
</h2>
<div>[Video description begins] <em>Topic title: Synchronized Blocks. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>So far, we have seen how the synchronize keyword works when it is applied to a function for a shared resource in Java. It allows a thread to effectively lock access to that function, and it releases a lock once it has executed it. We have seen that this works very well in terms of limiting access to a function to just a single thread. However, if your function happens to be rather large, then synchronizing the entire function may be a rather blunt instrument. And in fact, it may end up slowing down multiple-threads which require access to that function.<br /><br />[Video description begins] <em>The screen displays the Eclipse IDE window in continuation with the previous video.</em> [Video description ends]</p>
<p>Well, we will now explore the use of the synchronized block in order to synchronize access to just a certain part of a function, which gives us much more fine-grained control. To see how this works, let&#39;s head over to the CommonCounter class, where we have already explored the use of the synchronized keyword when applied to the incrementCounter function. This is all well and good when the function does just a single operation where it increments the value of one variable. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 8: myNum&#43;&#43;;.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 5 to Line 6: Line 5: private int firstNum &#61; 0; Line 6: private int secondNum &#61; 0;.</em> [Video description ends]<br /><br />Now let&#39;s modify this function code so that we have two different variables within the CommonCounter, firstNum and secondNum. So each instance of CommonCounter has two variables, and it is possible for us to synchronize access to each of them individually. When you take a look at the incrementCounter function now, each invocation of this function increments both of these variables, is to synchronize the increment of just one of these variables, rather than both of them. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 8 to Line 10: Line 8: public void incrementCounter(){ Line 9: firstNum&#43;&#43;; Line 9: secondNum&#43;&#43; Line 10: }.</em> [Video description ends]</p>
<p><br />[Video description begins] <em>He highlights the following lines of code from Line 13 to Line 19: Line 13: public int getFirstNum(){ Line 14: return firstNum; Line 15: } Line 17: public int getSecondNum(){ Line 18: return secondNum ; Line 19: }.</em> [Video description ends]<br /><br />And of course, to track the values of these variables, we define getters for both firstNum and secondNum. So with this new definition of CommonCounter, let&#39;s save things down. And the moment we do that, you&#39;ll observe that errors have popped up in Synchronization.java, since it invokes the getter for myNum, which no longer exists in the CommonCounter.</p>
<p>However, for this demo, we don&#39;t change the CounterIncrementor at all. It will still be initialized with an instance of CommonCounter along with the number of iterations in its for loop. And in each of those iterations, it will invoke this incrementCounter function, whose behavior has now been changed. However, let&#39;s head over to Synchronization.java now. And it is here where we will perform a few changes. I&#39;m just going to replace the entire code here within the main function. And let&#39;s walk through the different steps which we have define in this new version. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 5: private static final int NUM_ITERATIONS &#61; 10000;.</em> [Video description ends] So you&#39;ll observe that the number of iterations is still 10,000.<br /><br />[Video description begins]<em>He highlights the following line of code in Line 9: CommonCounter commonCounter &#61; new CommonCounter();.</em> [Video description ends] <br /><br />And beyond that, we initialize an instance of CommonCounter, which of course, now contains two variables, firstNum and secondNum.<br /><br />[Video description begins] <em>He highlights the following lines of code from Line 11 to Line 12: Line 11: Thread threadOne &#61; new Thread(new CounterIncrementor( commonCounter, NUM_ITERATIONS)); Line 12: Thread threadTwo &#61; new Thread(new CounterIncrementor( commonCounter, NUM_ITERATIONS));.</em> [Video description ends]</p>
<p>We then set up two threads, threadOne and threadTwo, which run instances of the CounterIncrementor. And both of these instances reference the same CommonCounter object we also pass along the same NUM_ITERATIONS for each of them. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 14 to Line 15: Line 14: System.out.println(&#34;Start value of firstNum: &#34; &#43; commonCounter.getFirstNum()); Line 15: System.out.println(&#34;Start value of secondNum: &#34; &#43; commonCounter.getSecondNum());.</em> [Video description ends] <br /><br />We then print out the values of firstNum and secondNum using their respective getters from CommonCounter, and after that, we kick off the two threads. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 18 to Line 19: Line 18: threadOne.start(); Line 19: threadTwo.start();.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the following line of code in Line 21: Thread.sleep(5000);.</em> [Video description ends] <br /><br />Five seconds is more than enough for them to complete that 10,000 iterations. So we sleep the main thread for that much time, and then we print out the final values of firstNum and secondNum. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 14 to Line 15: Line 14: System.out.println(&#34;End value of firstNum: &#34; &#43; commonCounter.getFirstNum()); Line 15: System.out.println(&#34;End value of secondNum: &#34; &#43; commonCounter.getSecondNum());.</em> [Video description ends] <br /><br />So when we save things down and run, well, in my case, it looks like there was no race condition and the final values are 20,000. But just to confirm that this was a fluke, I&#39;m going to rerun the code. And the final values of each of them are not only less than 20,000, but they&#39;re also different from each other.</p>
<p>So clearly, the race conditions can lead to a lot of inconsistency issues. I&#39;m now going to run this for a third time. And once again, the output is less than 20,000 and they&#39;re not identical to each other. All right, so now that we know that a race condition can be invoked, let&#39;s head back to the CommonCounter file.</p>
<p>And now, rather than synchronizing the entire function, let&#39;s introduce a synchronized block.<br /><br />[Video description begins] <em>He pastes various lines of code. He highlights the following lines of code from Line 10 to Line 13: Line 10: synchronized(this){ Line 11: firstNum&#43;&#43;; Line 12: secondNum&#43;&#43; Line 13: }.</em> [Video description ends]<br /><br />Well, in this case, we synchronize the increment of both firstNum and secondNum. And you&#39;ll observe that when we create the synchronized block, we pass along an argument. This argument defines the object on which the synchronization should occur. And by setting this to a value of this, it means that the entire CommonCounter instance will be logged by the thread which wishes to invoke incrementCounter.</p>
<p>So the way we have coded up Synchronization.java at the moment, we have two threads which invoke the same incrementCounter on the same object. But with this introduction of the synchronize block, that access will now be synchronized. Much like with a synchronized function, though, by synchronizing on this, any thread which wishes to increment either firstNum or secondNum will end up locking the entire object while the update is taking place. So with that, let&#39;s head back to Synchronization.java, and let&#39;s kick off our two threads by running this program.</p>
<p>And sure enough, the values of firstNum and secondNum show up as 20,000. Just to confirm that this is no fluke, I&#39;m just going to run once again. And yes, the final values are exactly the same. And now, running it for a third time gives us the same output, confirming that the synchronized block works exactly as we expect it to.</p>
<p>So how exactly is the synchronized block different from a synchronized function? Well, to demonstrate that, let&#39;s head back to CommonCounter.java. And the way we have things set up, all of the lines of code inside incrementCounter, specifically the two lines incrementing firstNum and secondNum, have been synchronized. Well, consider a case in a more realistic application where we have several lines of code and many of them will be read operations and some of them may be writes to a critical resource.</p>
<p>In such a case, it is inefficient for a thread to lock the entire function when only one part of it or some parts of it involve critical writes. So in the case of our incrementCounter, let&#39;s just say that firstNum is the one which we consider a critical resource, and secondNum is something which is less crucial for us. Well, in that case, let&#39;s introduce a synchronized block only around the increment of firstNum. This will make sure that any writes, that is, any increments of firstNum, will be synchronized, but this does not apply to second Num. And we may, in fact, encounter a race condition for that increment.</p>
<p>Again, this goes to show that Java does allow us more fine-grained control in terms of which parts of our code we wish to synchronize. To see how this works, let&#39;s save things down, head back to Synchronization.java and then run the program. Well, in the first run, the end values for both of the variables show up as 20,000. So I&#39;m just going to run once again, and this time the values are different.</p>
<p>Clearly, firstNum has its access fully synchronized, but the value of secondNum, which is a little less than 20,000, does indicate some instances of the race condition. Running it for a third time again gives us a value of 20,000 for firstNum, but a little less than that for second. And running it again, we confirm that the access to firstNum is indeed synchronized since each and every time the same value of 20,000 is returned. But this is not the case with the increment of secondNum.</p>
<p>So we now have a clear idea of the benefits of the synchronize keyword in Java which allows multiple threads to update shared resources without stepping on each other. Well, in the next video, we will take a look at some of the drawbacks of synchronized access in Java. Specifically, we will explore deadlocks.</p></div>
</div>
<div>
<h2 id="391ddbf0-e72c-4bcb-a1b4-213b33c05ac6">
Simulating a Deadlock
</h2>
<div>[Video description begins] <em>Topic title: Simulating a Deadlock. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>So far we have seen how it is possible to achieve synchronized access to shared resources in Java by making use of synchronized functions and synchronized blocks of code. This is all well and good in terms of providing consistent updates to shared resources. However, synchronized access can lead to the problem of deadlocks.</p>
<p>We will now simulate a deadlock in Java and we will also explore some of the options available to avoid them. For this, we create new classes within the com.skillsoft.concurrency package. And the first new class I create will be called ResourceOne. To simulate a deadlock, we will create two shared resources and also two threads which access them. <br /><br />[Video description begins] <em>The screen displays an Eclipse IDE window.</em> [Video description ends]<br /><br />[Video description begins] <em>He creates a new tab, ResourceOne.java.</em> [Video description ends]</p>
<p>So when we create this ResourceOne, well within the class, I&#39;m just going to go ahead and paste the code.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 5: public int myVar &#61; 100;.</em> [Video description ends] <br /><br />And this effectively serves as a wrapper around this myVar variable whose value here has been set to 100. Let&#39;s move along and create a second class within the same package. This is called ResourceTwo and let me just go ahead and paste the code, which in fact is very similar to ResourceOne. <br /><br />[Video description begins] <em>He creates a new tab, ResourceTwo.java. He highlights the following line of code in Line 5: public int myVar &#61; 1000;.</em> [Video description ends] </p>
<p>Again, the idea is to show that when we have multiple threads and multiple shared resources, there are a certain set of conditions which can result in a deadlock. All right, so now that we had defined the resources, let&#39;s create one more Class. And I&#39;m going to call this FirstTask, since this represents one of the tasks which will be executed in a separate thread, which will access both of the resources which we have created.<br /><br />[Video description begins] <em>He creates a new tab, FirstTask.java. He highlights the following line of code in Line 3: public class FirstTask implements Runnable {.</em> [Video description ends]<br /><br />And when the skeleton class have been generated, the first thing we do, is to make sure this implements the runnable interface.</p>
<p>And then once the code has been pasted, let&#39;s see exactly what this FirstTask does. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 5 to Line 6: Line 5: ResourceOne rOne; Line 6: ResourceTwo rTwo;.</em> [Video description ends]<br /><br />So it has two members, which are instances of ResourceOne and ResourceTwo, called rOne and rTwo and these resources are initialized by the constructor.<br /><br />[Video description begins] <em>He highlights the following lines of code from Line 8 to Line 11: Line 8: public FirstTask(ResourceOne r1, ResourceTwo r2){ Line 9: this.rOne &#61; r1; Line 10: this.rTwo &#61; r2; Line 11: }.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the following lines of code from Line 13 to Line 15: Line 13: &#64; Override Line 14: public void run(){ Line 15: {.</em> [Video description ends]<br /><br />And then we move along to the run method of this FirstTask. Within the code, we do have a few invocations of Thread.sleep, which is why we place everything in a try block.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 17: synchronized(rOne ){.</em> [Video description ends]<br /><br />And at the very beginning, we first create a synchronize block, and we synchronize on the rOne resource, which means that the FirstTask thread will have exclusive access to rOne. This fulfills one of the four conditions required for a deadlock, namely mutual exclusion. Keep in mind here that when we create a synchronized block on the rOne resource, we implicitly acquire a Lock on that resource.<br /><br />[Video description begins] <em>He highlights the following lines of code from Line 18 to Line 19: Line 18: System.out.println(&#34;Lock acquired on ResourceOne by &#34; Line 19: &#43; Thread.currentThread().getName());.</em> [Video description ends]<br /><br />So what exactly does the FirstTask do once it has acquired this Lock?  Well, it&#39;ll first print out to the Console that the Lock has been acquired.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 20: rOne.myVar&#43;&#43;;.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the following line of code in Line 21: Thread.sleep(1000);.</em> [Video description ends] <br /><br />Then it&#39;ll increment the value of rOne.myVar and then go to sleep for one second. So at this point, the first task instance holds the Lock on rOne and then it requests a lock on rTwo. This is conveyed by the second synchronized block, which is in fact nested within the first one. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 23: synchronized(rTwo ){.</em> [Video description ends] <br /><br />So what exactly does this do? Well, it fulfils a second condition for a deadlock to occur, namely, hold and wait. This instance of FirstTask will hold the Lock on ResourceOne and then waits for the Lock on ResourceTwo to be released if it is held by another thread. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 27: rTwo.myVar--;.</em> [Video description ends] <br /><br />On the other hand if the Lock is available, then we enter the second synchronize block where this thread will decrement the value of rTwo.myVar and go to sleep for one second.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 28: Thread.sleep(1000);.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 31 to Line 32: Line 31: System.out.println(&#34;Lock on ResourceTwo released by &#34; Line 32: &#43; Thread.currentThread().getName());.</em> [Video description ends]</p>
<p>When the code exits the synchronize block for rTwo, it means that the Lock on rTwo will be released and we convey this fact by printing a message to the Console. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 35 to Line 36: Line 35: System.out.println(&#34;Lock on ResourceOne released by &#34; Line 36: &#43; Thread.currentThread().getName());.</em> [Video description ends] <br /><br />This concludes the synchronized block for rOne following which the Lock on that resource is also released and once again, we convey it by printing a message to the Console. And then we define a catch block to handle an InterruptedException. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 40 to Line 42: Line 40: catch(InterruptedException e){ Line 41: e.printStackTrace(); Line 42: }.</em> [Video description ends]<br /><br />All right, with that, let&#39;s save down the FirstTask of Java source and then head over to the com.skillsoft.concurrency package to create one more class.</p>
<p>This will represent a SecondTask, which in fact is going to be very similar to the FirstTask, but with some subtle variations, which can result in a deadlock when run concurrently with FirstTask. <br /><br />[Video description begins] <em>He creates a new tab, SecondTask.java. He highlights the following line of code in Line 3: public class SecondTask implements Runnable {.</em> [Video description ends]<br /><br />We start off by once again making sure that it implements the runnable interface. And we&#39;ll then go ahead and paste the code.<br /><br />[Video description begins] <em>He highlights the following lines of code from Line 5 to Line 6: Line 5: ResourceOne rOne; Line 6: ResourceTwo rTwo;.</em> [Video description ends] <br /><br />SecondTask also has rOne and rTwo, which are instances of ResourceOne and ResourceTwo. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 8 to Line 11: Line 8: public SecondTask (ResourceOne r1, ResourceTwo r2){ Line 9: this.rOne &#61; r1; Line 10: this.rTwo &#61; r2; Line 11: }.</em> [Video description ends]</p>
<p>And in fact, both of these members need to be initialized in the constructor. And then we move along to the run function. This in many ways is symmetrical to the run function we defined within FirstTask where we have nested synchronized blocks, which effectively represent nested locking.</p>
<p>However, the difference here is that SecondTask first requests a lock on rTwo. And then after it performs an update on the rTwo resource, then there is a synchronized block once again, but this time on rOne. So imagine what can happen if you run instances of FirstTask and SecondTask concurrently. FirstTask will hold ResourceOne and request a Lock on ResourceTwo, while SecondTask holds ResourceTwo, and requests a Lock on ResourceOne.</p>
<p>In addition to the two deadlock conditions we have already discussed, this fulfills a third one, namely circular wait. If the lock acquisitions do go through however, we enter the second synchronize block on rOne. And then after that, the release of the Lock on rOne is conveyed by means of this print statement. Then, the release of rTwo is conveyed as well and our definition of SecondTask also comes to an end.</p>
<p>All right, so how exactly can we get instances of these task to run? Well, I&#39;m going to create a new class for that. And this is going to be called Deadlock. If you happen to be using an IDE, such as Eclipse, it may be possible to auto-generate a main function.</p>
<p>So I&#39;m going to make use of that option here and then hit Finish.<br /><br />[Video description begins] <em>He creates a new tab, Deadlock.java.</em> [Video description ends]<br /><br />This takes us back to the sources. And we see the Auto-generated public static void main which has been generated for the Deadlock class. The coding of the Deadlock class and then running it in order to create a deadlock is something we will cover in the next video.</p></div>
</div>
<div>
<h2 id="f6215c68-0275-4e75-a8e0-b45b0ecfcb6f">
Deadlock Avoidance
</h2>
<div>[Video description begins] <em>Topic title: Deadlock Avoidance. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>In the previous video, we define two resources, and also define two tasks which require locks on those resources to do their jobs. But the way we coded up those resources leave open the possibility that they will get into a state of deadlock when run concurrently. The fact that they acquire locks ensures mutual exclusion. We have also coded up the task so that there is a hold and wait situation. And if those tasks are kicked off at about the same time, it could also get into a state of circular wait.</p>
<p>And finally, the fourth and final condition for a deadlock that have no preemption is also fulfilled, since neither task can preempt the other. All right, let&#39;s now go about coding up the task so that there is a deadlock. And for that, we have this Deadlock class. <br /><br />[Video description begins] <em>The screen displays the Eclipse IDE window in continuation with the previous video.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the following line of code in Line 3: public class Deadlock {.</em> [Video description ends] <br /><br />And then for the main method, let&#39;s point to the fact that this could throw an InterruptedException. <br /><br />[Video description begins] <em>He edits the line of code in Line 5 to the following: public static void main(String[] args () throws InterruptedException {.</em> [Video description ends]</p>
<p>We will set up the main thread to join with the threads for the FirstTask and SecondTask, which means that we leave open the possibility of an InterruptedException being thrown.<br /><br />[Video description begins] <em>He pastes various lines of code. He highlights the following lines of code from Line 7 to Line 8: Line 7: ResourceOne r1 &#61; new ResourceOne(); Line 8: ResourceTwo r2 &#61; new ResourceTwo r2();.</em> [Video description ends] <br /><br />Continuing with the definition of the main method, we start off by defining one resource each of the type ResourceOne and ResourceTwo. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 10 to Line 11: Line 10: Thread firstTaskThread &#61; new Thread( new FirstTask(r1, r2), &#34;firstTaskThread&#34;); Line 11: Thread secondTaskThread &#61; new Thread( new SecondTask(r1, r2), &#34;secondTaskThread&#34;);.</em> [Video description ends] <br /><br />Next, we initialize a thread each for the FirstTask and the SecondTask. And both of these use the same set of resources, r1 and r2. So just to summarize, we have coded our FirstTask in a way where it holds r1, and then also requests r2 to move along. And SecondTask does the reverse. Furthermore, we have also passed along names of firstTaskThread and secondTaskThread, which won&#39;t necessarily be used for the name, but will be used by the task in their print statements to identify themselves.</p>
<p>Now, running these task will mean that three out of the four conditions required for a deadlock will be fulfilled. Mutual exclusion due to the acquisition of the locks, hold and wait, as well as no preemption. The final condition is a circular wait. <br /><br />[Video description begins] <em>He pastes various lines of code. He highlights the following lines of code from Line 15 to Line 16: Line 15: firstTaskThread.start(); Line 16: secondTaskThread.start();.</em> [Video description ends] <br /><br />And for that, all we need to do is to start off these two threads at about the same time. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 13: System.out.println(&#34;Starting the two thread. . .);.</em> [Video description ends]</p>
<p>After the print statement, we kick off the two threads by invoking the start methods. And this will ensure that the firstTaskThread acquires a lock on ResourceOne. And then at virtually the same time, the secondTaskThread will request and acquire the lock on ResourceTwo. About a second later, the FirstTask will request the lock on ResourceTwo. And then SecondTask will ask for the lock on ResourceOne, and this will lead to the circular wait.</p>
<p>At that point, neither thread will be able to proceed since they&#39;re waiting on each other to release a resource which they have asked for. And sure enough, we will end up in a deadlock. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 18 to Line 19: Line 18: firstTaskThread.join(); Line 19: secondTaskThread.join();.</em> [Video description ends] <br /><br />While we invoke the join methods from the main thread for both FirstTask and SecondTask, this is not quite relevant, because both of those task will go on forever. And to test those out, let&#39;s save things down and run the program. And sure enough, in the output, we get to see that the two threads are about to start. And the following print statements from each of them confirms that they have started their tasks. The firstTaskThread has acquired the lock on ResourceOne.</p>
<p>And similarly, the SecondTask has a lock on ResourceTwo. But then, of course, to enter the second synchronize block, each of them requires a lock on the other resource. And this is what has led to a circular wait. Now, the program is not going to proceed at this point.</p>
<p>And the only way to get it to stop is to proactively close down the execution. At this point, you are free to rerun this program as many times as you&#39;d like. But given the logic which we have defined for the task, if we start them at virtually the same time as we have here, it will almost always end in a deadlock.</p>
<p>So what exactly can we do to avoid such situations? Well, given that there are four necessary conditions for a deadlock, we just need to make sure that one of them can never happen. To implement one such avoidance technique, let&#39;s head over now to the SecondTask. And what we will change here is the order in which locks are requested and acquired. And this is to prevent the situation of a circular wait.</p>
<p>Once the code is up, well, what we can do here is to effectively replace the code within the try block and then paste in the new code. So what exactly is the change here? Well, we have simply flipped the order in which the locks are requested for and acquired. So this task, will first request a lock on rOne, so we have the first synchronize block.</p>
<p>And then we continue using a nested lock by requesting a lock on rTwo while holding rOne. So once again, the use of locks ensures mutual exclusion, and the nested locking leads to a hold and wait. However, given that both FirstTask and SecondTask will both hold rOne while requesting rTwo, at least one of them will be able to acquire the lock on rTwo and then proceed with that task. This means that the situation of a circular wait will not arise with this change in logic.</p>
<p>To generalize the solution, if you have multiple resources and then multiple task which need those resources, then setting an order in which locks are acquired can prevent the circular wait condition, and thus prevent a deadlock. To test this out, let&#39;s save things down and head over to the Deadlock source. And without making any changes, we run this program once again. And on this occasion, both task have run through to completion without any issues.</p>
<p>So the solution we have implemented will require some form of ordering of the different resources in your system. And while that can lead to some overhead, it does prevent the rather prickly situation of a deadlock. We can now move along and explore one more technique in order to avoid deadlocks. And this is where we don&#39;t get into the state of hold and wait.</p>
<p>So to implement this, we head over now to the FirstTask source. And what we have here is a hold and wait, thanks to this nested locking. So I&#39;m going to replace this code with the nested synchronized blocks, and then replace it with this one. So we now have two synchronized blocks in sequence.</p>
<p>This task first acquires a lock on rOne, then releases the lock, and then requests the lock on rTwo. So it never holds one lock while requesting another. You&#39;ll recall that we still have the hold and wait in the SecondTask implementation. But in the case of our code, since we only have two task, we can just save things down here for the FirstTask, head over to the Deadlock program, and then rerun.</p>
<p>On this occasion, we have prevented the circular wait due to the ordering in which the resources are locked. And we have also made sure that there is no hold and wait for the FirstTask. However, to ensure that our most recent implementation of the no hold and wait is the one which prevents the deadlock, let&#39;s head back to the SecondTask now. And then within this, we make sure that the ordering of the lock acquisition is different from the one in FirstTask.</p>
<p>So again, SecondTask requests a lock on rTwo, and then for a lock on rOne. However, thanks to the fact that there is no hold and wait here, this means that a deadlock will not occur. So to put this to the test, we save things down in the SecondTask, head back to Deadlock.java, and run the program once again. And sure enough, from the output in the Console, it&#39;s clear that both threads have run through to completion.</p>
<p>In other words, there was no deadlock. So either of the two techniques which we implemented can prevent deadlocks on their own. However, neither of these solutions may be applicable for your own application. So you could consider some of the other options, such as the ability to preempt threads. And in some cases, you may just decide to not prevent deadlocks, but merely to detect them as soon as they occur and then stop the programs if they do.</p></div>
</div>
<div>
<h2 id="0deba41b-6200-408f-bffb-cfe7270ecc7a">
Explicit Locking in Java
</h2>
<div>[Video description begins] <em>Topic title: Explicit Locking in Java. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>When we write code which make use of synchronized blocks on objects, we are in effect, setting a threat to acquire a lock on that object. At the end of the synchronized block, the lock on that object is released. In Java, this can be referred to as implicit locking. Since all we need to do is to define a synchronize block, and the locking and unlocking of the resource is handled by Java.</p>
<p>From this video onwards, we will take a look at some of the lock objects which are available in Java in order to perform explicit locking of resources. So let&#39;s get started.<br /><br />[Video description begins] <em>The screen displays an Eclipse IDE window.</em> [Video description ends]<br /><br />First, let&#39;s head over to ResourceOne, and I&#39;ve currently cleared out its contents since we will be adding some new code here. We&#39;ll not only have a variable which can be updated by multiple threads, but we will also include a lock with this resource. So that any thread which wishes to perform an update can acquire the lock first and then release it after its work is done.<br /><br />[Video description begins] <em>He pastes and highlights the following lines of code from Line 3 to Line 4: Line 3: import java.util.concurrent.locks.Lock; Line 4: import java.util.concurrent.locks.ReentrantLock;.</em> [Video description ends]<br /><br />So what are the lock objects which are available in Java? Well, we import two of these here. And the first of these is the lock interface. The lock interface includes a number of different methods which its implementations will need to define. This includes a lock function in order to lock a resource, as well as an unlock function and a few more which we will explore.</p>
<p>So this is the lock interface. But then what exactly is an implementation of that? Well, one of these is the ReentrantLock. This provides a lot of the functionality which synchronized blocks have to offer in terms of the ability to lock and unlock resources. But it does offer a few additional features as well.</p>
<p>And once we have imported these classes into our code, let&#39;s make use of them. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 8: public int myVar &#61; 100;.</em> [Video description ends] <br /><br />So just as before, we define an integer variable called myVar and set it to a value of 100.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 10: Lock rOneLock &#61; new ReentrantLock();.</em> [Video description ends] <br /><br />But beyond that, ResourceOne also includes a ReentrantLock called rOneLock. So, any thread which was performing an update on myVar has the ability to acquire rOneLock, and then release it once the update is carried out.</p>
<p>Let&#39;s move along then to ResourceTwo. Well, the code here will be rather similar. We import the lock interface and the ReentranLock.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 8: public int myVar &#61; 1000;.</em> [Video description ends] <br /><br />And once again, define an integer variable called myVar. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 10: Lock rTwoLock &#61; new ReentrantLock();.</em> [Video description ends]</p>
<p>And to perform an update on it, threads will have the ability to acquire rTwoLock, and then release it later. So now, each of our resources are bundled with ReentrantLocks. Now it&#39;s time for us to define each of our tasks to make use of them. Heading over then to FirstTask, I have once again cleared out the contents here.</p>
<p>And to begin coding, we make sure that it implements runnable, and<br /><br />[Video description begins] <em>He highlights the following line of code in Line 3: public class FirstTask implements Runnable {.</em> [Video description ends] <br /><br />will then proceed to paste the remaining code. [Video description begins] <em>He highlights the following lines of code from Line 5 to Line 6: Line 5: ResourceOne rOne; Line 6: ResourceTwo rTwo;.</em> [Video description ends] We still use ResourceOne and ResourceTwo in this case, and the constructor is exactly the same as before.<br /><br />[Video description begins] <em>He highlights the following lines of code from Line 8 to Line 11: Line 8: public FirstTask(ResourceOne r1, ResourceTwo r2){ Line 9: this.rOne &#61; r1; Line 10: this.rTwo &#61; r2; Line 11: }.</em> [Video description ends] <br /><br />The big change, however, from the previous version is in the run method. [Video description begins] <em>He highlights the following line of code in Line 17: rOne.rOneLock.lock();.</em> [Video description ends] Well, over here, rather than starting off with a synchronized block, this FirstTask will explicitly acquire a lock on the rOne resource using rOne.rOneLock.lock.</p>
<p>So this means that the thread of FirstTask will have exclusive access to that object. Then just as before, it prints out to the Console that a lock has been <br /><br />[Video description begins] <em>He highlights the following line of code in Line 19: System.out.println(&#34;Lock acquired on ResourceOne by &#34; &#43; Thread.currentThread().getName());.</em> [Video description ends] acquired on the ResourceOne instance and<br /><br />[Video description begins] <em>He highlights the following line of code in Line 21: rOne.myVar&#43;&#43;;.</em> [Video description ends] then proceeds to increment the value of rOne.myVar. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 22: Thread.sleep(1000);.</em> [Video description ends]<br /><br />The thread goes to sleep then for one second, and [Video description begins] <em>He highlights the following line of code in Line 24: rOne.rOneLock.unlock();.</em> [Video description ends] <br /><br />then releases the lock on rOne. So, we don&#39;t have a hold and wait in this case, which means that there should be no deadlock. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 26: System.out.println(&#34;Lock on ResourceOne released by &#34; &#43; Thread.currentThread().getName());.</em> [Video description ends]</p>
<p>So after rOneLock is released, we print out this fact to the Console, and then acquire a lock on rTwo. [Video description begins] <em>He highlights the following line of code in Line 28: rTwo.rTwoLock.lock();.</em> [Video description ends] Note here that the lock function for a ReentrantLock is a blocking call. This means that if another thread happens to hold that lock, this thread will have to wait and will effectively be blocked from execution until that lock becomes available. [Video description begins] <em>He highlights the following line of code in Line 30: System.out.println(&#34;Lock acquired on ResourceTwo by &#34; &#43; Thread.currentThread().getName());.</em> [Video description ends] So, once that lock does get acquired though, we print out to the Console from FirstTask that the lock on ResourceTwo is acquired. [Video description begins] <em>He highlights the following line of code in Line 32: rTwo.myVar--;.</em> [Video description ends] We then go on to decrement the value of rTwo.myVar. And then after sleeping for a second, release the lock on rTwo. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 35: rTwo.rTwoLock.unlock();.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the following line of code in Line 37: System.out.println(&#34;Lock on ResourceTwo released by &#34; &#43; Thread.currentThread().getName());.</em> [Video description ends]</p>
<p>So once the message conveying that has been printed to the Console, well, this concludes the FirstTask. So, you&#39;ll realize that the functionality of this version of FirstTask is pretty much exactly the same as in the previous version, where we made use of a synchronize block. The only difference is that on this occasion, we use explicit locking with a ReentrantLock. Whereas previously, it was implicit locking through a synchronized block.</p>
<p>Do keep in mind here that we do need to catch and handle an interrupted exception due to the invocation of Thread.sleep. Moving along then, to second task. Again, I have cleared out the code here. And after making sure that this implement&#39;s runnable, I&#39;ll go ahead and paste the remaining code for it.</p>
<p>So the members are exactly the same as before, instances of ResourceOne and ResourceTwo which are initialized in the constructor. And then in the run method, well, this is once again similar to the previous version, but with explicit locking. After requesting for a lock on rTwo SecondTask will print out this message to the Console and then increment the value of rTwo.myVar.</p>
<p>Then after a sleep of one second, we&#39;ll release the lock, print out a message to the Console, and then request a lock on rOne. Again, I mentioned that the lock method of a ReentrantLock is a blocking call. So, after this lock has been acquired, rOne.myVar is updated, and then the lock on rOne is released. So the FirstTask and SecondTask request the locks in a different order.</p>
<p>However, neither of them holds a lock while requesting for the other one, which means that a deadlock should not occur. And just to clarify, an interrupted exception is caught and handled. Let&#39;s move along then and then define a main class in order to run these task using the resources within the com.skillsoft.concurrency package. We&#39;ll create this new class whose Name is LockObjects.</p>
<p>I&#39;ll set this to have a pre-built main function. And then, let&#39;s go about defining the code. <br /><br />[Video description begins] <em>He edits the line of code in Line 5 to the following: public static void main(String[] args () throws InterruptedException {.</em> [Video description ends]<br /><br />So the main function can throw an interrupted exception, since we will make use of the join method here. And then within the function definition, well, just as before, we define instances of ResourceOne and ResourceTwo. <br /><br />[Video description begins] <em>He pastes various lines of code. He highlights the following lines of code from Line 7 to Line 8: Line 7: ResourceOne r1 &#61; new ResourceOne(); Line 8: ResourceTwo r2 &#61; new ResourceTwo r2();.</em> [Video description ends] <br /><br /><br />[Video description begins] <em>He highlights the following lines of code from Line 10 to Line 11: Line 10: Thread firstTaskThread &#61; new Thread( new FirstTask(r1, r2), &#34;firstTaskThread&#34;); Line 11: Thread secondTaskThread &#61; new Thread( new SecondTask(r1, r2), &#34;secondTaskThread&#34;);.</em> [Video description ends] <br /><br />And then pass them along to instances of FirstTask and SecondTask. And these will run in separate threads called firstTaskThread and secondTaskThread. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 15 to Line 16: Line 15: firstTaskThread.start(); Line 16: secondTaskThread.start();.</em> [Video description ends] <br /><br />And then, we go about starting the two threads, so<br /><br />[Video description begins] <em>He highlights the following lines of code from Line 18 to Line 19: Line 18: firstTaskThread.join(); Line 19: secondTaskThread.join();.</em> [Video description ends]<br /><br />they will run concurrently. And we make sure that this main method waits for those two threads to complete by invoking their join methods.</p>
<p>All right, so we expect that there should not be a deadlock. But, let&#39;s save things down and run to make sure that it does run as expected. And from the Console output, we get that confirmation. So each of them have acquired their respective locks, and then carried out their increment tasks, and then have concluded as well.</p>
<p>All right, the fact that we use explicit locks does not mean that deadlocks cannot occur. And in the next video, we will redefine the code within a FirstTask and SecondTask classes. So that even with the use of explicit locks, we can create a situation where the execution of the threads results in a deadlock.</p></div>
</div>
<div>
<h2 id="f5f5dd25-c866-4cb2-b363-e6797fdc7349">
The tryLock() Method
</h2>
<div>[Video description begins] <em>Topic title: The tryLock() Method. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />In the previous video, we redefined our resources and task classes, so that our tasks can explicitly acquire locks on the resources by means of a reentrant lock. <br /><br />[Video description begins] <em>The screen displays the Eclipse IDE window in continuation with the previous video.</em> [Video description ends]<br /><br />Well, we will now see how even the use of explicit locking can lead to a deadlock. So for that, I&#39;m first going to clear out the Console and then head over to the FirstTask.
<p>l&#39;lI just go ahead and paste the new code here, and effectively redefine the whole run method, and let&#39;s see what exactly happens. So once again, we start off by requesting for a lock on the rOne resource. After conveying this fact with the print message, and then updating the value of myVar in rOne, we&#39;ll then proceed to request for a lock on rTwo. So this change in code reintroduces the hold and wait scenario.</p>
<p>So let us presume that rTwo is available. Well in that case, we invoke a print statement again, update rTwo, and then release the lock on rOne and this is followed by releasing the lock on rTwo as well. So functionally, this is not very different from when we previously had nested synchronized blocks. Let&#39;s perform a similar change in the SecondTask class. Once we head over there, let&#39;s just clear out the contents of the run method and then paste in the new code.</p>
<p>So you should have an idea of what we do here. We acquire the lock on rTwo, update rTwo and then request for the lock on rOne. Once again introducing the hold and wait scenario. So once the lock on rOne has been acquired, we can update that resource as well, then release the locks on rTwo and rOne. You can see then that running both FirstTask and SecondTask at about the same time will lead to a deadlock thanks to the circular wait which can occur. To test it out, however, let&#39;s head back to the lock objects class. Make sure that all of the changes to FirstTask and SecondTask have been saved. And as for lock objects, we make no changes and simply run. And sure enough, from the output, it becomes clear that the two threads are now in a deadlock.</p>
<p>So functionally, a lock object such as a reentrant lock is very similar to a synchronize block. However, as mentioned earlier, there are a number of additional features which reentrant locks offer, and it&#39;s now time for us to start exploring them. The first feature we will take a look at is the tryLock function. But before we get to that, let&#39;s just stop this program from running since it is deadlocked. And now, to make the changes to FirstTask and SecondTask, well, let&#39;s start off by heading over to the FirstTask class. Once again, I&#39;m going to clear out the contents of the run method and then paste in the new code.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 18: boolean rOneLockAcquired &#61; rOne.rOneLock.tryLock();.</em> [Video description ends]<br /><br />So what exactly is different this time? Well, right at the beginning, you see that instead of acquiring the lock using rOne.rOnelock.lock, this time we invoke the tryLock method. This is different from the lock method in that a thread executing this does not block if that lock is not available. Instead, it will return a boolean value of false. If the lock is available, well then the lock is acquired and a true value is returned.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 20: if (rOneLockAcquired) {.</em> [Video description ends]<br /><br />So we then check whether rOne lock acquired is true. And if it is, it means that this thread holds the lock in which case, we print out the message to the Console, update the rOne resource. And then after sleeping for a second, we unlock by calling the unlock method. And then we print out to the Console that ResourceOne has been released. And then we go about checking whether ResourceTwo is available by invoking the tryLock method on its own lock.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 31: boolean rTwoLockAcquired &#61; rTwo.rTwoLock.tryLock();.</em> [Video description ends]<br /><br />So the process is similar here. This will return a boolean of true and will also acquire the lock on ResourceTwo if it is available. And this will return false otherwise, a point of significance with the tryLock method is that if the lock is not available, then the thread does not wait for it to become ready, but in fact, immediately returns a false value. And let&#39;s just say at this point, another thread has the lock on ResourceTwo.</p>
<p>Well, this tryLock will return false and we never get into the if block which follows it. This will mean that the FirstTask is effectively half done, because the lock on ResourceTwo was not immediately available when it was requested. So this is a drawback of the tryLock feature. And we will later explore how this can be mitigated to some degree. So once we save things down in FirstTask, it&#39;s time for us to head over to SecondTask and make similar code changes. After clearing out the run method, and then pasting in the new code, we see that at first this task will try to acquire the lock on ResourceTwo.</p>
<p>So let&#39;s just assume that FirstTask and SecondTask start off at exactly the same time. FirstTask, checks for the lock on ResourceOne, and it should be available and then it acquires it and the SecondTask will similarly acquired a lock on ResourceTwo. The code will then proceed to the first if blockes in each and then release their respective locks. In the case of the SecondTask, it is the lock on rTwo which will be released and then SecondTask will request a lock on rOne. It is possible that by this point, the firstTaskThread has released the lock on rOne and SecondTask will be able to proceed and execute this second if block. So, to see whether that is exactly what occurs, let&#39;s save things down here, and then head over to the LockObjects class. And we don&#39;t need to make any changes here.</p>
<p>So we just run the program and it looks like both of the threads have finished execution. So let&#39;s examine the output to see exactly what has gone on. The firstTaskThread acquires a lock on ResourceOne, and similarly, the secondTaskThread acquires a lock on ResourceTwo. They then proceed to release each of those locks. And then, the secondTaskThread acquires the lock on ResourceOne. But significantly, the firstTaskThread does not get the lock on the second resource because it was not immediately available when the request was made for it. Since the secondTaskThread had not quite released it at the time, you may have guessed that this is only because the SecondThread was started just moments after the FirstThread. And if the firstTaskThread had waited just a little longer for the lock on resource to be available, It could well have proceeded with its full execution.</p>
<p>Let&#39;s further highlight this problem by first closing out this Console and then heading over to the SecondTask class. Well, let&#39;s just see what happens if we were to increase this Thread.sleep from one second to five seconds. And let&#39;s just play out this new scenario. We assume that both FirstTask and SecondTask start at almost the same time and will acquire the locks on ResourceOne and ResourceTwo. The First Task will hold its lock on ResourceOne for just about one second. And will then request the lock on ResourceTwo. However, the SecondTask will hold the lock on ResourceTwo for five seconds. Which means that the point at which the FirstTask request the lock on ResourceTwo, it will be held by SecondTask and is not available.</p>
<p>All right, so let&#39;s save things done again, head back to LockObjects and then run the program and the output is the same as before. The firstTaskThread never gets the lock on ResourceTwo, and its job is nearly half done. In the next video, we will explore how the tryLock method can be set to wait for a specified amount of time for a lock to become available. Effectively, a timeout on the lock acquisition.</p></div>
</div>
<div>
<h2 id="1342fc27-6e70-450b-bda1-0b92296e3ef8">
Invoking tryLock() with a Timeout
</h2>
<div>[Video description begins] <em>Topic title: Invoking tryLock() with a Timeout&#61;-. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>When it comes to explicit locking, we have explored two different options so far. One of these has to do with calling the lock method, which can cause a thread to wait indefinitely for the lock to become available. And then, there is the tryLock method which returns immediately whether or not the lock is available. And if it is not, well we have seen that the code execution may simply be unable to proceed.</p>
<p>These, however, are the extreme cases. There is a compromise to be had and this is when we call the tryLock method with a timeout value.<br /><br />[Video description begins] <em>The screen displays the Eclipse IDE window in continuation with the previous video.</em> [Video description ends] <br /><br />It&#39;s now time for us to see exactly how that can be implemented. For that, let&#39;s head over to the FirstTask.</p>
<p>And before we make any changes to the tryLock call, we first import the TimeUnit class.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 3: import java.util.concurrent.locks.TimeUnit;.</em> [Video description ends] <br /><br />When we specify a timeout value, we do have options in terms of the time unit used for it and it is the TimeUnit class which allows this. In fact, we will need to specify a TimeUnit along with the tryLock method. And how exactly do we specify this timeout?</p>
<p>Well, first, let&#39;s just erase this particular call to tryLock and then replace it with a new one with a TimeUnit.<br /><br />[Video description begins] <em>He edits the line of code in Line 20 to the following: boolean rOneLockAcquired &#61; rOne.rOneLock.tryLock(10, TimeUnit.SECONDS);.</em> [Video description ends]<br /><br />The goal is for a FirstTask instance to try and acquire a lock on ResourceOne. And this attempt can be made for 10 seconds. If the lock is available by then, well, the lock is acquired, and if not, it simply gives up and then moves on. And to set this 10 second timeout, we supplied two arguments.</p>
<p>The first is the value of 10. And then in the second argument, we specify what TimeUnit this represents. TimeUnit.SECONDS conveys that this is a 10-second timeout. And similarly, we can specify timeout values in terms of days, hours, or even milliseconds.</p>
<p>Let&#39;s move along then and make a change to this tryLock invocation as well. <br /><br />[Video description begins] <em>He edits the line of code in Line 34 to the following: boolean rTwoLockAcquired &#61; rTwo.rTwoLock.tryLock(10, TimeUnit.SECONDS);.</em> [Video description ends] <br /><br />The way we have set things up currently, the SecondTask instance will hold a lock on ResourceTwo for about 5 seconds. And when this call is made to tryLock, well, the lock on ResourceTwo is unavailable. So it simply gives up and does not proceed in the code execution.</p>
<p>Well now, we will get the tryLock call to be a little more persistent, where the thread will now block for 10 seconds in an attempt to acquire the lock on rTwo. This is longer than the five seconds, for which a SecondTask instance holds the lock on rTwo. In which case, we expect that a FirstTask instance is able to acquire this lock. In which case, the value of rTwo lock acquired is eventually true. And then the code execution is allowed to proceed to the second if block.</p>
<p>On the other hand, if the lock is not available even after 10 seconds, well, rTwo lock acquired is false, and the code does not proceed here. All right, let&#39;s save things down and move along to the SecondTask. And our changes will be nearly identical. We import the TimeUnit class. And then for the tryLock call, we make sure that we pass along a timeout value, 10 seconds once again.</p>
<p>And we do exactly the same for the second tryLock call. And you could argue that at this point, the code is a little more robust. We make sure that we don&#39;t indefinitely wait for a lock to be released, which could of course lead to a deadlock. And on the other hand, a thread does not immediately give up on acquiring a lock if it is not available at the first attempt.</p>
<p>So it&#39;s time now for us to save this SecondTask, switch back to LockObjects and leaving things exactly as they are here, we run. So the two threads have acquired the locks on ResourceOne and Two. And then eventually, we observe that the firstTaskThread does go ahead and acquire the lock on ResourceTwo. In fact, both of the threads have been able to execute completely. So this is how using a lock object such as a ReentrantLock is better than having synchronized blocks within our code. </p>
<p>The use of the tryLock function allows us to define a timeout period, which is much more complicated to setup with the synchronize block. Furthermore, it does provide us with a good compromise between the lock function which can end up in an indefinite wait, and then a tryLock with no arguments, where we give up immediately if the lock is not available. We can now continue exploring the lock features by heading over to the FirstTask. And we will now explore why exactly a ReentrantLock has that name.</p>
<p>Specifically, we see how a thread can acquire a ReentrantLock when it&#39;s already in possession of that lock. That is, it has the ability to re-enter that lock. So we switch over to FirstTask. And the change we make is just before this call to rOneLock.unlock. So before this task releases its lock on rOne, well, it&#39;ll request for the lock once again. So the new code I have pasted here is from line 30 through 44. So while we are already in possession of rOneLock, well, this thread puts in a request for it once again using the tryLock method.</p>
<p>And given that this is a ReentrantLock, this invocation of tryLock will return true. The tryLock function only returns false if the lock is held by another thread. When the same lock is acquired for a second time by the same thread, well, the hold count for that thread on that lock is incremented. So within this second if block, we convey in the Console that a second lock is acquired on ResourceOne.</p>
<p>We then proceed to update the resource. And then when we invoke the unlock method here, only one of the two locks on this particular instance will be released. And the lock on rOne becomes available for another thread only when we invoke the unlock method for the second time on rOneLock. And for this demo, we will leave the remainder of the code exactly as is. And we save things down and head over to the LockObjects class.</p>
<p>Once again, no changes are needed here so we just run the program. And once the output is ready, let&#39;s take a look at whether the second lock on ResourceOne was acquired by the FirstTask. And in fact, that is precisely what we see in the fourth line of this Console output. Beyond that, the second lock was released by the firstTaskThread. And then its first lock was released following that.</p>
<p>And beyond that, both of the threads were able to execute all of their code. So we now know why ReentrantLocks are given that name. Now you may wonder what exactly the use cases are for ReentrantLocks. Well, consider the case where you don&#39;t want to check whether you hold a particular lock, because that can slow down your program&#39;s execution. And you&#39;ll just go ahead and acquire the lock if it is available, and then run updates on the LockResource. This is one example where the use of a ReentrantLock may provide a more optimal solution than having to check each and every time whether the resource has already been locked by the current thread.</p></div>
</div>
<div>
<h2 id="54f74d19-5bba-4340-92bc-3692747b96d1">
StampedLock in Java
</h2>
<div>[Video description begins] <em>Topic title: StampedLock in Java. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>We&#39;ve seen one example of a lock object which is available in Java, in the form of a ReentrantLock. Within the java.util.concurrent.locks package however, there are in fact a number of other locks available and we will now explore one more of these, which is the StampedLock. This is different from a reentrant lock in that it is not necessary for a thread which acquires a stamped lock to be the same thread which releases it. It is possible to get one thread to release the lock on behalf of another. <br /><br />[Video description begins] <em>The screen displays the Eclipse IDE window in continuation with the previous video.</em> [Video description ends]<br /><br />In this demo however, we won&#39;t get too much into depth in terms of stamped locks and we&#39;ll just explore some of its features. First though, let&#39;s head over to the SecondTask and then clear out its contents. And then head to FirstTask and do precisely the same. Heading over to ResourceOne, well, we will now redefine this so that instead of a ReentrantLock, it imports the StampedLock.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 3: import java.util.concurrent.locks.StampedLock;.</em> [Video description ends] <br /><br />And beyond that, the resource definition is about the same as before where we have a myVar variable and then a StampedLock which will be used to regulate access to this resource. Moving along then to ResourceTwo, and the changes will be similar. We import StampedLock and then include an instance of StampedLock within the resource. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 9: StampedLock rOneLock &#61; new StampedLock();.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the following line of code in Line 9: StampedLock rTwoLock &#61; new StampedLock();.</em> [Video description ends] <br /><br />Switching over then to the FirstTask, we&#39;ll now need to code this in order to make use of a StampedLock. So I&#39;ll just paste the code here. So the members are still ResourceOne and ResourceTwo, and we have the same constructor as before.<br /><br />[Video description begins] <em>He highlights the following line of code in Line 17: long writeLockOneStamp &#61;rOne.rOneLock.writeLock();.</em> [Video description ends]<br /><br />But within the run method, this is where we make use of the StampedLock in order to update the shared resources. So we start off by invoking rOne.rOneLock.writeLock and the writeLock is something which allows this particular thread exclusive access to that lock. This is in contrast to a readLock, which will give a thread non-exclusive access. So the writeLock call is a blocking call and the thread will wait until that lock becomes available. And when it is, it returns a write stamp. The write stamp on this lock will be required in order to release the lock in the future and this release can be performed either by the same thread or any other. It is the stamp which determines which lock is released. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 19: System.out.println(&#34;Lock acquired on ResourceOne by &#34; &#43; Thread.currentThread().getName() &#43; &#34; . Lock stamp is &#34; &#43; writeLockOneStamp);.</em> [Video description ends]</p>
<p>[Video description begins] <em>He highlights the following line of code in Line 22: int updatedVal &#61; rOne.myVar&#43;&#43;;.</em> [Video description ends] <br /><br />Well, after this writeLock is acquired, we print this fact out to the Console and take a look at what we do following that. We create a variable called updateVal, whose value is the current value of rOne.myVar, but then we go on to increment myVar. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 24: rOne.myVar &#61; updatedVal;.</em> [Video description ends]<br /><br />After sleeping for 20 seconds, we perform one more update on r0ne.myVar by setting this to updatedVal, which of course holds its old value. Once the update is carried out, we release the writeLock which we acquired by calling the unlock method. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 26: rOne.rOneLock.unlock(writeLockOneStamp);.</em> [Video description ends]<br /><br />So, whether it is a readLock or a writeLock which we acquire, we can use the same unlock function, but we do need to provide a stamp. When we do so, the lock corresponding to that stamp is the one which is released. Once we convey the release of this lock in the Console, we then go about acquiring a lock, specifically a writeLock for ResourceTwo. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 17: long writeLockTwoStamp &#61;rTwo.rTwoLock.writeLock();.</em> [Video description ends] <br /><br />And then we go through similar steps here, where we print a message to the Console, sleep for two seconds in this case, and then update rTwo.myVar, and then release the lock.</p>
<p>All right, before moving along, I&#39;m just going to switch over to ResourceOne, save things down here, head to ResourceTwo, and save the new code once again. And then we&#39;ll save changes to FirstTask as well. All right, it&#39;s now time for us to code up the SecondTask. I&#39;ll just paste the code once again. And the member definitions and the constructors are the same as before. And what we do within the run method is again symmetrical to what we have in the FirstTask.</p>
<p>You will note however, that after acquiring the lock on the second resource, we don&#39;t create a temporary variable in order to perform an update. We simply increment rTwo.myVar directly and then release the lock by calling rTwo.rTwoLock.unlock. We then request a writeLock on the first resource. We perform an update on that and then release the lock using the stamp which was returned at the time of lock acquisition.</p>
<p>All right, so with that, we have now coded up our resources to have StampedLocks associated with them and have also re-coded FirstTask and SecondTask to make use of those StampedLocks. We head over to the LockObjects source now and then we can just run this program. All right, let&#39;s take a look at the output and see exactly what has gone on. The firstTaskThread acquires a lock on ResourceOne with a stamp of 384.</p>
<p>And in fact it is the same stamp which is returned when the secondTaskThread acquires a lock on ResourceTwo. Both of the threads release their locks and then acquire locks on the other resource, and once again we observe that the stamp is identical. Specifically, 640, even those these are for different locks. So this is all well and good in terms of lock acquisition, but to get a better idea of how writeLocks and readLocks can work, well, let&#39;s first close down this Console and then make a few changes to our code.</p>
<p>Within the lock objects, I&#39;m just going to replace the code which is currently within the main function. And then paste in a new version where we have again one resource each of ResourceOne and ResourceTwo, but we have three different threads, One thread for the FirstTask and two for the SecondTask. All of them are setup with the same instances of r1 and r2. <br /><br />[Video description begins] <em>He highlights the following lines of code from Line 10 to Line 12: Line 10: Thread firstTaskThread &#61; new Thread( new FirstTask(r1, r2), &#34;firstTaskThread&#34;); Line 11: Thread secondTaskThread &#61; new Thread( new SecondTask(r1, r2), &#34;secondTaskThread&#34;); Line 12: Thread anotherSecondTaskThread &#61; new Thread( new SecondTask(r1, r2), &#34;anotherSecondTaskThread&#34;);.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the following line of code in Line 16: System.out.println(&#34;Start values of resources: &#34; &#43; r1.myVar &#43; &#34; , &#34; &#43; r2.myVar);.</em> [Video description ends]</p>
<p>Furthermore in the print statements, we first publish the initial values of r1.myVar and r2.myVar. Then after we start the three threads and then join the main functions to them, we print out the final values of those variables. <br /><br />[Video description begins] <em>He highlights the following line of code in Line 27: System.out.println(&#34;End values of resources: &#34; &#43; r1.myVar &#43; &#34; , &#34; &#43; r2.myVar);.</em> [Video description ends] <br /><br />Keep in mind here that the FirstTask will hold the lock on ResourceOne for a total of 20 seconds. And each of the instances of SecondTask will need to wait for that lock to be released. So let&#39;s see what happens when we save things down and then run this program. Well, soon enough, we see that the firstTaskThread has acquired a writeLock on r1. But the two threads for the secondTask instances, well, they compete for the lock on r2. The lock is first acquired by secondTaskThread with a Lock stamp of 384.</p>
<p>And then once it releases the lock, well, anotherSecondTaskThread acquires Lock with a stamp of 640. Both the second TaskThreads however are waiting for the FirstTask to release its lock on ResourceOne and once that happens, well their executions can proceed. So this is what we get when we have three concurrent threads, which make use of the StampedLock on our resources. And note the final values of the myVar variable in each of them. myVar in ResourceOne is effectively decremented by two since the FirstTask effectively makes no change to it, but then each of the secondTaskThreads decremented by one. The net effect on ResourceTwo is an increment of myVar from 1000 to 1001. In the next video, we&#39;ll take a look at what happens if you were to replace the writeLocks with readLocks on the same resources.</p></div>
</div>
<div>
<h2 id="c812f20b-3f7f-4964-82b4-3000d64149c6">
The readLock() for StampedLock Instances
</h2>
<div>[Video description begins] <em>Topic title: The readLock() for StampedLock Instances. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>We have covered the fact that a writeLock, when using a StampedLock in Java, allows a thread exclusive access on the lock. <br /><br />[Video description begins] <em>The screen displays the Eclipse IDE window in continuation with the previous video.</em> [Video description ends] <br /><br />However, let&#39;s see what happens if you were to replace all the writeLock acquisitions in our code with readLocks. For that, let&#39;s head over to the FirstTask. And in the first instance of a writeLock acquisition, well, let&#39;s just replace this with a call to the lock object .readLock. Unlike a writeLock, this does not grant a thread exclusive access to the lock. However, this call to readLock can block the thread if another thread has a writeLock on the same object. Once the lock is acquired, it is once again a stamp which is returned, specifically a numeric stamp. And this will be used later on to release the lock.</p>
<p>In fact, we leave the call to rOneLock.unlock exactly as it is. One thing to note here between the acquisition of the readLock and its release is that in spite of only obtaining a readLock, we do in fact try to perform an update to rOne.myVar. This in fact can lead to a race condition which we&#39;ll explore in just a little bit. For now though, let&#39;s replace this writeLock acquisition on the second resource with a readLock.</p>
<p>So the unlock function call which follows just a little later is still applicable. But you&#39;ll observe that between the readLock and the unlock, we perform an update to rTwo. This is incorrect use of a readLock, but let&#39;s just see what happens if you were to proceed with this use. Saving things down, let&#39;s move along to SecondTask.java. And the changes we make here will be similar. The first call to writeLock is replaced with a readLock acquisition. And once again, we continue with an update to the rTwo resource. And then instead of acquiring a writeLock on resource One, we again acquire a readLock, and then continue to perform an update. So there is a lot of incorrect use of a readLock going on here.</p>
<p>So let&#39;s save things down here and take a look at the effects of this readLock acquisition. So when we head over to LockObjects, and then leave the existing code exactly as it is, so we have three concurrent threads and then we run. All right, I have fast forwarded everything here. So let&#39;s take a look at what have gone on here.</p>
<p>Since all lock requests were for a readLock, there was nothing to block that acquisition. This becomes especially clear with the lock on ResourceOne, which is first obtained by firstTaskThread. And then later on, we see that both secondTaskThread and another secondTaskThread acquire locks on ResourceOne, with stamps of 258 and 259. In fact, both of these threads release their locks on ResourceOne before firstTaskThread gets to release its own lock.</p>
<p>The result of all of this can be seen in the final values of our variables, which are different from a previous run where we only had writeLocks. This concludes a brief introduction to the StampedLock in Java, which allows us to obtain different grades of locks. And also allows locks to be released using a stamp so that different threads can release locks, which were acquired by others.</p></div>
</div>
<div>
<h2 id="d90712c0-6729-44ae-91a3-0a4091593e62">
Course Summary
</h2>
<div>[Video description begins] <em>Topic title: Course Summary</em> [Video description ends]
<p>Now that you have completed this hands-on course on synchronization of Java threads, it&#39;s time to recap what was covered. At a high-level, the course involved the management of concurrent threads, which update common resources. In the labs, we looked at how this can be performed using synchronized functions and blocks, as well as locks. We began by simulating a race condition in a multi-threaded Java program. And how this can be prevented using a synchronized function.</p>
<p>We then covered the more granular way of achieving thread synchronization, using synchronized blocks. We then moved on to how more advanced synchronization is possible using locks. This included the use of built-in locks in Java, such as the ReentrantLock and the StampedLock. While doing all of this, we explored one of the big drawbacks of locking, the possibility of deadlocks. We simulated a deadlock and looked at some of the options available in order to avoid them.</p>
<p>At this point, you will be quite familiar with the nitty-gritty of managing a multithreaded Java application. You can move along to a more advanced course involving the implementation of the concurrency tools you have just explored. For example, by solving the Producer-Consumer problem. </p></div>
</div>
</body>
</html>
