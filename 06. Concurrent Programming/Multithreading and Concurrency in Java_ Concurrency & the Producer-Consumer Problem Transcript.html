<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Multithreading and Concurrency in Java: Concurrency & the Producer-Consumer Problem Transcript">
<title>Multithreading and Concurrency in Java: Concurrency & the Producer-Consumer Problem Transcript</title>
</head>
<body>
<h1>Multithreading and Concurrency in Java: Concurrency & the Producer-Consumer Problem</h1>
<p><p>The Producer-Consumer problem is a common issue to address when we have concurrent producer and consumer threads working with a bounded buffer. Solving this problem covers a variety of synchronization mechanisms in Java, and this course covers the implementation of synchronization blocks, locks, Condition objects, and Java&#39;s built-in data structures.</p></p>
<div>
<h2>Table of Contents</h2>
<ol><li><a href="#47bfdbaa-f355-4836-a511-3fcf6f57e318">Course Overview</a></li>
<li><a href="#88d0774f-f885-42e7-bbde-aba4c3b1aa2a">Simulating the Producer-Consumer Problem</a></li>
<li><a href="#87a5505b-04d4-423a-a716-621814ae1487">The Consumer Task</a></li>
<li><a href="#6accd0d9-ea3b-438b-84f9-06980c8d1b9e">Running the Producer and Consumer</a></li>
<li><a href="#7fac7d66-3460-4738-8e38-b97dbe3aba5d">Tweaking the Producer and Consumer</a></li>
<li><a href="#759fdeb5-c461-4538-b865-f08de04c5943">The Condition Object</a></li>
<li><a href="#2cd8fe88-2083-4d83-ac65-1e0d57d85212">Scaling the Producers and Consumers</a></li>
<li><a href="#65d6cf84-dd4f-42bc-9911-7be03ed9a815">The ArrayBlockingQueue</a></li>
<li><a href="#215cb802-69d9-423c-9a3f-49efa7fa90cc">Course Summary</a></li>
</ol></div>
<div>
<h2 id="47bfdbaa-f355-4836-a511-3fcf6f57e318">
Course Overview
</h2>
<div>[Video description begins] <em>Topic title: Course Overview</em> [Video description ends] <br /><br />Hi, and welcome to this course, An Introduction to Concurrent Programming in Java. My name is Kishan Iyer and I will be your instructor for this course. <br /><br />[Video description begins] <em>Your host for this session is Kishan Iyer. He is a software engineer and big data expert.</em> [Video description ends] <br /><br />A little about myself first. I have a Master&#39;s degree in Computer Science from Columbia University, and have previously worked in companies such as Deutsche Bank and WebMD in New York. I presently work for Loonycorn, a studio for high quality video content. Concurrent programming skills are among the most useful tools in the armory of any software engineer. <br /><br />The ability to run several tasks simultaneously, even if they&#39;re subtask created out of larger tasks, can greatly improve your program&#39;s performance. This can save your organization a lot of time, or even deliver a better experience to your end users. And the Java programming language offers a variety of options when it comes to implementing concurrent programming through multithreading. <br /><br />This course covers a variety of ways to address problems related to concurrent programming through implementing solutions to a common issue, the producer consumer problem. The specific constraints of this problem bring several concurrent programming constructs into the picture and help us understand where exactly they fit and what their limitations are. We begin by using synchronized blocks for concurrent producer and consumer threads in order to access and update a shared queue. We then address some of the limitations of this approach by implementing a ReentrantLock and Condition objects. Finally, we explore how the solution can be further simplified with the use of a built-in concurrent data structure offered by Java, the ArrayBlockingQueue. Once you&#39;re done with this course, you will have a firm grasp of locking mechanisms, their potential use cases, as well as their implementation. You will be well-equipped to move on to a course covering a breadth of concurrency objects available in the Java programming language, such as semaphores, atomic variables, and concurrent collections.</div>
</div>
<div>
<h2 id="88d0774f-f885-42e7-bbde-aba4c3b1aa2a">
Simulating the Producer-Consumer Problem
</h2>
<div>[Video description begins] <em>Topic title: Simulating the Producer-Consumer Problem. Your host for this session is Kishan Iyer.</em> [Video description ends]<br /><br />It&#39;s now time for us to make use of the skills which you have acquired so far as far as multithreading in Java is concerned. And then put them to use in order to solve a rather common problem when it comes to concurrent programming, specifically, the producer-consumer problem. <br /><br />In its simplest form, we have a single producer and a single consumer, the producer creates some items which the consumer can consume. The transfer of this item from the producer to the consumer, however, takes place by means of a buffer, which is usually implemented as a queue with a fixed capacity. This is also known as the bounded buffer problem. So let&#39;s now see how exactly this can be addressed in Java. I&#39;m going to make use of the same com.skillsoft.concurrency package, which I have been using so far in this learning path. And within this, let&#39;s go about creating some new classes. <br /><br />[Video description begins] <em>The screen displays an Eclipse IDE window. In the left pane, various projects are present. In the main pane, there is space for entering lines of code. At the bottom, there is a Console tab for showing the output.</em> [Video description ends]<br /><br />[Video description begins] <em>The host clicks the com.skillsoft.concurrency package. A shortcut menu opens. He selects New within it and a sub-menu displays. He selects Class within the sub-menu.</em> [Video description ends] <br /><br />[Video description begins] <em>A window labeled Java Class displays. It contains fields such as Source folder and Name. He enters the text SharedQueue in the Name field.</em> [Video description ends] <br /><br />The first of these, let&#39;s call this SharedQueue. And this is in fact going to serve as the bounded buffer to which a producer will add items to be consumed by the consumer. Once a skeleton class has been created, let&#39;s move ahead and then code it up. <br /><br />[Video description begins] <em>The SharedQueue class opens in the editor pane. It contains a few lines of code.</em> [Video description ends] <br /><br />The first thing we do is to import the java.util.Queue interface. Since our SharedQueue class will effectively serve as a wrapper around a Java queue implementation. <br /><br />[Video description begins] <em>He enters the following line of code in line 3: import java.util.Queue;.</em> [Video description ends] <br /><br />Within our SharedQueue, we define a couple of members. <br /><br />[Video description begins] <em>He enters multiple lines of code from line 7 to line 12.</em> [Video description ends] <br /><br />The first of these is the queue itself, which we call queue.<br /><br />[Video description begins] <em>He highlights the code in line 7 that reads: Queue&lt;String&gt; queue;.</em> [Video description ends] <br /><br />And a little later when we initialize an instance of SharedQueue, we will set this to be a linked list. Beyond that, this queue also has a limited capacity. And this is a big constraint in the producer-consumer problem.<br /><br />[Video description begins] <em>He highlights the code in line 8 that reads: int capacity;.</em> [Video description ends] <br /><br />A producer thread cannot add to a queue while it is full, while a consumer thread cannot consume anything from an empty queue. So we have a constructor for the SharedQueue. And this is where we initialize it with a queue implementation. And we will also play around with the overall capacity of the queue.<br /><br />[Video description begins] <em>He highlights the code from line 10 to line 13. Line 10 reads: public SharedQueue(Queue&lt;String&gt; queue, int capacity) {. Line 11 reads: this.queue &#61; queue;. Line 12 reads: this.capacity &#61; capacity;. Line 13 reads: }.</em> [Video description ends] <br /><br />So with this SharedQueue implemented, let&#39;s go along and then add one more class. And this is going to serve as the Producer.<br /><br />[Video description begins] <em>A class labeled Producer opens in the editor screen. It contains code in lines 1 and 3.</em> [Video description ends] <br /><br />Once it&#39;s created, we start off by making sure that it implements the runnable interface. Since we will get the producer to run in a separate thread. <br /><br />[Video description begins] <em>He highlights a section of the code in line 3 which reads: Producer implements Runnable.</em> [Video description ends] <br /><br />And after that, let me just paste the entire code for this and then walk you through each of the blocks. We start off by defining a SharedQueue instance which is a member of the producer. <br /><br />[Video description begins] <em>He highlights the code in line 5 which reads: SharedQueue sharedQueue;.</em> [Video description ends] <br /><br />And this is the queue to which the producer will keep adding items as it generates them. In the constructor, we initialize a producer instance with a sharedQueue object. <br /><br />[Video description begins] <em>He highlights the code in lines 7 to 9. Line 7 reads: public Producer(SharedQueue sharedQueue) {. Line 8 reads: this.sharedQueue &#61; sharedQueue; . Line 9 reads: }.</em> [Video description ends] <br /><br />Furthermore, we set each producer to have the capacity to produce 10 items. And these are ten different strings which we defined within this items array. And we&#39;ll iterate over these in order to simulate the production of these individual items. <br /><br />[Video description begins] <em>He highlights the code in lines 11 and 12. Line 11 reads: String[] items &#61; {&#34;ItemOne&#34;, &#34;ItemTwo&#34;, &#34;ItemThree&#34;, &#34;ItemFour&#34;, &#34;ItemFive&#34;,. Line 12 reads: &#34;ItemSix&#34;, &#34;ItemSeven&#34;,&#34;ItemEight&#34;,&#34;ItemNine&#34;,&#34;ItemTen&#34;};.</em> [Video description ends] <br /><br />And we define a single produce method in order to add an item to the sharedQueue. How exactly do we do this? <br /><br />[Video description begins] <em>He highlights the code in line 14 that reads: public void produce(String item) throws InterruptedException {.</em> [Video description ends] <br /><br />Well, it accepts an item as an argument. And this is the item which needs to be added to the sharedQueue. Do keep in mind that this produce method can throw an interrupted exception, since we do invoke the weight method within it. All right, so let&#39;s see how exactly the producer adds an item to the queue. <br /><br />[Video description begins] <em>He highlights the lines of code from line 16 to line 26.</em> [Video description ends] <br /><br />First, we start off by locking the sharedQueue, by implementing this synchronized block, and the argument which we passed is synchronized, which is the monitor object happens to be the sharedQueue. <br /><br />[Video description begins] <em>He highlights a section of the code in line 16 which reads: synchronized(sharedQueue).</em> [Video description ends] <br /><br />This means that an instance of the producer will effectively acquire a lock on the sharedQueue and it&#39;s now ready to add an item to the queue. However, a constraint is that the queue has a limited capacity and may not have the space for the produced item,which is why the producer first checks whether the queue is full. <br /><br />[Video description begins] <em>He highlights a section of the code in line 18 which reads: if (sharedQueue.queue.size() &gt;&#61; sharedQueue.capacity)</em> [Video description ends] <br /><br />Which is why the producer first checks whether the queue is full. We do this by checking whether the number of elements in the queue which is sharedQueue.queue.size, is greater than or equal to its capacity. And if it is, well, the producer prints this out to the console and then goes into a wait state.<br /><br />[Video description begins] <em>He highlights the code in line 20 which reads: System.out.println(&#34;Queue is full. Producer is waiting...&#34;);.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code in line 22 which reads: sharedQueue.wait();.</em> [Video description ends] <br /><br />When it does so, it releases the lock which it has acquired and effectively blocks. And it remains in its state of slumber until it is woken up by another thread using the same sharedQueue object. It is the consumer which needs to wake up the producer in this case. And we will define the consumer in such a way where it wakes up a producer when it has consumed an item from the queue. In which case, the queue does have some capacity. Well, at this point, we print out to the console that the Producer has woken up. <br /><br />[Video description begins] <em>He highlights the code in line 24 which reads: System.out.println(&#34;Producer has woken up&#34;);.</em> [Video description ends] <br /><br />And then it goes about acquiring a lock on the sharedQueue once again. <br /><br />[Video description begins] <em>He highlights a section of the code in line 29 which reads: synchronized(sharedQueue).</em> [Video description ends] <br /><br />And now it is safe for the producer to add to the queue, which is what we do next. Keep in mind that if the queue was not full, the code execution would still end up in this second synchronized block. So what exactly do we do when the queue does have capacity? Well, we just add the item to the queue.<br /><br />[Video description begins] <em>He highlights the code in line 31 which reads: sharedQueue.queue.add(item);.</em> [Video description ends] <br /><br />We then print out to the console that an item has been Produced.<br /><br />[Video description begins] <em>He highlights the code in line 33 which reads: System.out.println(&#34;Produced : &#34; &#43; item);.</em> [Video description ends] <br /><br />And then finally, we will issue a notify call. Because if you add it to an empty queue, there may be consumers which are waiting for the queue to have something for them to consume. <br /><br />[Video description begins] <em>He highlights the code in line 35 which reads: sharedQueue.notify();.</em> [Video description ends] <br /><br />Keep in mind though that I said they may be consumers in the plural. If there are multiple consumers waiting for the same producer, then this call to notify from the producer will wake up any one of those sleeping threads. Java includes a similar notify all method, which wakes up all sleeping threads waiting on the same object. <br /><br />All right, this concludes the definition of the produce method, where a producer thread adds a single item to a queue until it has the capacity to accept items. So how exactly do we invoke the produce method? Well, this is where we move along to the run function of this producer. <br /><br />[Video description begins] <em>He highlights multiple lines of code from line 39 to line 54.</em> [Video description ends] <br /><br />We previously initialized a list of ten strings. And this is where we iterate over those ten strings, and then invoke the produce function for each of the items. <br /><br />[Video description begins] <em>He highlights a section of the code in line 42 which reads: for(int i &#61; 0; i &lt; items.length; i&#43;&#43;)</em> [Video description ends] <br /><br /> [Video description begins] <em>He highlights the codes in lines 44 to 47. Line 44 reads: try {. Line 45 reads: Thread.sleep((long) (Math.random() * 1000) * 5);. Line 46 reads: produce(items[i]);. Line 47 reads: }.</em> [Video description ends] <br /><br />Keep in mind here that within the try block, we first put this thread to sleep for a random period of time between 0 and 5 seconds. The reason for this randomness is to simulate a somewhat real life situation where the rate of production is not constant, and neither is the rate of consumption. Our solution to the producer-consumer problem should be able to handle this randomness. And you&#39;ll also observe that since we put a thread to sleep here, we do need to handle an interrupted exception, which we do here.<br /><br />[Video description begins] <em>He highlights the code in lines 48 to 50. Line 48 reads: catch (InterruptedException e) {. Line 49 reads: e.printStackTrace();. Line 50 reads: }.</em> [Video description ends] <br /><br />And at the very end, we also print out to the console that the producer thread has run its course.<br /><br />[Video description begins] <em>He highlights the code in line 53 which reads: System.out.println(&#34;The producer has run its course&#34;);.</em> [Video description ends] <br /><br />So with that, the definition of a producer task is complete. In the next video, we will code up the consumer whose behavior will somewhat mirror that of the producer.</div>
</div>
<div>
<h2 id="87a5505b-04d4-423a-a716-621814ae1487">
The Consumer Task
</h2>
<div>[Video description begins] <em>Topic title: The Consumer Task. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />In the previous video, we defined a SharedQueue resource, which serves as a buffer between a producer and a consumer. And we also defined a producer task, which has the constraint that it cannot add items to a queue which is full. And the program which can take items off the SharedQueue is the consumer, which we now turn our attention to. After saving down the Producer, let&#39;s head back to the same com.skillsoft.concurrency package and create a new Class. <br /><br />[Video description begins] <em>The host enters the name Consumer in the Name field within the Java Class window.</em> [Video description ends] <br /><br />This of course is the Consumer, and again this is going to run within a thread.<br /><br />[Video description begins] <em>The Consumer class now displays in the editor pane. It contains a few lines of auto-generated code.</em> [Video description ends] <br /><br />[Video description begins] <em>He enters the following line of code on line 3: public class Consumer implements Runnable {.</em> [Video description ends] <br /><br />So we implement the Runnable interface, and then once again paste the code, which we will now go over. <br /><br />[Video description begins] <em>He pastes multiple lines of code.</em> [Video description ends] <br /><br />As you may expect, a Consumer will have access to a SharedQueue. And this is what it is initialized with in its constructor. <br /><br />[Video description begins] <em>He highlights the code on line 5 which reads: SharedQueue sharedQueue;.</em> [Video description ends]<br /><br />Beyond that, we also have a name for each Consumer.<br /><br />[Video description begins] <em>He highlights the code on line 6 which reads: String consumerName;.</em> [Video description ends] <br /><br />Furthermore, there is a limited capacity for each Consumer. And just as a Producer can produce 10 items, a Consumer can only consume a limited number of them. <br /><br />[Video description begins] <em>He highlights the code on line 7 which reads: int consumerCapacity;.</em> [Video description ends] <br /><br />Each of these members of a Consumer instance, will need to be initialized in the constructor.<br /><br />[Video description begins] <em>He highlights the lines of code from line 9 to line 13. Line 9 reads: public Consumer(SharedQueue sharedQueue, String name, int capacity) {. Line 10 reads: this.sharedQueue &#61; sharedQueue;. Line 11 reads: this.consumerName &#61; name;. Line 12 reads: this.consumerCapacity &#61; capacity;. Line 13 reads: }.</em> [Video description ends]<br /><br />And then, we move along to the consume function.<br /><br />[Video description begins] <em>He highlights a section of the code on line 15 which reads: public void consume() throws InterruptedException.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code on line 23 which reads: sharedQueue.wait();.</em> [Video description ends] <br /><br />You&#39;ll observe that there is a call to the wait method, which is why this is a thread which can be interrupted. Which is why we mentioned that this consume function can throw an interrupted exception. So what exactly does a Consumer do in order to consume an item? Well, it needs to open item of the SharedQueue, but it has the constraint that it cannot pop anything from a queue which is empty. And to implement this behavior, we first make sure that a Consumer threat acquires a lock on the SharedQueue, since we don&#39;t want this to get into a race with a Producer, when it comes to modifying the shared resource. <br /><br />[Video description begins] <em>He highlights a section of the code on line 17 which reads: synchronized(sharedQueue).</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights a section of the code on line 19 which reads: if (sharedQueue.queue.size() &#61;&#61; 0)</em> [Video description ends] <br /><br />Once this lock has been acquired, well, the Consumer first checks whether the queue is empty. And if it is, well, there is really nothing much it can do. So it just prints out a message to the console, that it&#39;s going to wait. <br /><br />[Video description begins] <em>He highlights the code on line 21 which reads: System.out.println(&#34;Queue is empty. &#34;&#43; consumerName &#43; &#34;is waiting...&#34;);.</em> [Video description ends] <br /><br />And that is precisely what it does by calling the blocking wait function.<br /><br />[Video description begins] <em>He highlights the code on line 23 which reads: sharedQueue.wait();.</em> [Video description ends] <br /><br />So while a thread is waiting, it is effectively not doing anything, and it can be interrupted. Or if something gets added to the queue, well, it can get woken up. When we wrote the code for the producer, we had set it to notify any waiting thread on the SharedQueue once it has added an item to it. And if a Consumer is woken up by that Producer, well, you print out a message to the console, and importantly it means that the Consumer has something to consume.<br /><br />[Video description begins] <em>He highlights the code on line 25 which reads: System.out.println(consumerName &#43; &#34;has woken up&#34;);.</em> [Video description ends]<br /><br />And then we move along to the second synchronized block. <br /><br />[Video description begins] <em>He highlights a section of the code on line 29 which reads: synchronized(sharedQueue).</em> [Video description ends] <br /><br />Again, if the queue was not full, we would come to the second block in any case. So once the lock is acquired on the SharedQueue, the consumer is now ready to remove an item from the queue. <br /><br />[Video description begins] <em>He highlights the code on line 31 which reads: String item &#61; sharedQueue.queue.remove();.</em> [Video description ends] <br /><br />And that is precisely what it does by invoking sharedQueue.queue.remove. This has the effect of removing an element from the head of the queue, and this is stored in the variable item, which we print out to the console. <br /><br />[Video description begins] <em>He highlights the code in line 33 which reads: System.out.printl n(consumerName &#43; &#34; has consumed &#34; &#43; item);.</em> [Video description ends] <br /><br />When a Consumer has removed an element from the queue, well, it means that the SharedQueue does have some spare capacity, which is why we issue a notify on the SharedQueue. <br /><br />[Video description begins] <em>He highlights the code in line 35 which reads: sharedQueue.notify();.</em> [Video description ends]<br /><br />And if there happens to be a Producer which is sleeping on the SharedQueue, well, it will get woken up and it can go on to add a new element to it. So this concludes the definition of the consume function, where a Consumer consumes elements from the shared queue. And then we define the run method.<br /><br />[Video description begins] <em>He highlights the lines of code from line 15 to line 39.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the lines of code from line 40 to line 54.</em> [Video description ends] <br /><br />This is where the Consumer invokes the consume function for as many times as it has the capacity. So we have a for loop here, and in each iteration, we put the Consumer to sleep for a random period of time between 0 and 5 seconds. <br /><br />[Video description begins] <em>He highlights a section of the code on line 43 that reads: for(int i &#61; 0; i &lt; consumerCapacity; i&#43;&#43;).</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the code on lines 45 to 48. Line 45 reads: try {. Line 46 reads: Thread.sleep((long)(Math.random() * 1000) * 5);. Line 47 reads: consume();. Line 48 reads: }.</em> [Video description ends] <br /><br />Again, the rate of consumption is somewhat random, similar to the rate of production. When this Consumer wakes up from the sleep, that is when it consumes a new item. Once a Consumer has exhausted his capacity to consume, well, that&#39;s when it needs to exit. And then we print out to the console that the Consumer has run its course. <br /><br />[Video description begins] <em>He highlights the code on line 54 that reads: System.out.println(consumerName &#43; &#34;has run its course&#34;);.</em> [Video description ends] <br /><br />So with that, we&#39;ve now wrapped up the definition of the Consumer.java source file. It&#39;s now time for us to set up new threads which run instances of the Producer and the Consumer. And then make sure that their behavior reflects what you&#39;ve written in the code. So once we save things down in the Consumer, let&#39;s create one more Class. And this is going to be called ProducerConsumer. And this is the one which will have a main function once we hit Finish. <br /><br />[Video description begins] <em>He selects the checkbox labeled public static void main(String[] args) under the heading Which method stubs would you like to create?</em> [Video description ends] <br /><br />Well, we have the Auto-generated code here, but we&#39;ll define the remainder of ProducerConsumer.java and run Producer and Consumer threads concurrently in the next video.</div>
</div>
<div>
<h2 id="6accd0d9-ea3b-438b-84f9-06980c8d1b9e">
Running the Producer and Consumer
</h2>
<div>[Video description begins] <em>Topic title: Running the Producer and Consumer. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />Previously, we have coded up a sharedQueue instance as well as a producer and the consumer, in order to simulate the producer consumer problem in concurrent programming.<br /><br />[Video description begins] <em>The screen displays the ProducerConsumer class containing auto-generated lines of code.</em> [Video description ends] <br /><br />Right here we have the skeleton of the ProducerConsumer class, which includes a main method. <br /><br />[Video description begins] <em>He highlights a section of the code on line 3 that reads: public class ProducerConsumer.</em> [Video description ends]<br /><br />But I&#39;m just going to go ahead and first import java.util.Linkedlist. <br /><br />[Video description begins] <em>He enters the following code on line 3: import java.util.LinkedList;.</em> [Video description ends] <br /><br />This is the queue implementation, which we are going to use. And we&#39;ll go ahead and then define the code for the main function, and it is rather simple.<br /><br />[Video description begins] <em>He enters various lines of code from line 9 to line 18.</em> [Video description ends] <br /><br />We create a single instance of the sharedQueue, which we initialize with a new LinkedList instance. <br /><br />[Video description begins] <em>He highlights the code on line 9 that reads: SharedQueue sharedQueue &#61; new SharedQuue(new LinkedList&lt;String&gt;(), 2);.</em> [Video description ends] <br /><br />This is a LinkedList of strings, and we set the sharedQueue to have a capacity of two. We then create an instance of the producer and one instance of the consumer, and both of these use the same sharedQueue.<br /><br />[Video description begins] <em>He highlights the code on lines 11 and 12. Line 11 reads: Producer producer &#61; new Producer(sharedQueue);. Line 12 reads: Consumer consumer &#61; new Consumer(sharedQueue, &#34;ConsumerOne&#34;, 10);.</em> [Video description ends] <br /><br />Furthermore, the name which you pass along for the consumer is Consumer0ne. And this has a capacity of 10, which matches exactly the number of items produced by the producer. And now it&#39;s time for us to run each of these in separate threads. So we initialize Threads p and c. <br /><br />[Video description begins] <em>He highlights the code on lines 14 and 15. Line 14 reads: Thread p &#61; new Thread(producer, &#34;Producer Thread&#34;);. Line 15 reads: Thread c&#61; new Thread(consumer, &#34;Consumer Thread&#34;);.</em> [Video description ends]<br /><br />Thread p runs an instance of the producer. And we set this thread a name of Producer Thread. And similarly, Thread c runs an instance of consumer with the name Consumer Thread. And then we just go ahead and start both of them.<br /><br />[Video description begins] <em>He highlights the code on lines 17 and 18. Line 17 reads: p.start();. Line 18 reads: c.start();.</em> [Video description ends] <br /><br />So we expect that 10 items will be produced by the producer, but the rate of production will vary between zero and five seconds for each item. Similarly, the rate of consumption for the consumer is also a random value between zero and five seconds. And while the producer and consumer threads are running. We can expect that there will be at least some instances where the rate of production exceeds the rate of consumption to the point where the queue gets full. <br /><br />And similarly, that a higher rate of consumption could lead to the queue being empty at some points. To test this out, though, let&#39;s save things down and then run the program. Well, once we do this, it looks like items are being produced and consumed. <br /><br />[Video description begins] <em>The output displays in the Console tab.</em> [Video description ends] <br /><br />And I&#39;m just going to fast forward this execution, and we can examine the output later to see exactly what has taken place. So it looks like both the threads have completed their jobs. And scrolling up in the console, we see that things begin with the producer producing a single item, and the consumer immediately consumes it. <br /><br />The same thing happens for ItemTwo, but following that, it looks like the producer took a little longer to produce ItemThree. Which is why the consumer found the queue empty and went into the wait state. Once the producer did produce ItemThree however, well, it issued the notify call. In which case, ConsumerOne was woken up and then it immediately consumed the produced item. <br /><br />So we&#39;ve now already seen an example of a consumer waiting on an empty queue. Moving along in the console output. Well, we have an example here of the rate of production greatly exceeding the rate of consumption, to the point where the queue gets full. And then it is the producer who goes into a wait state, waiting for a consumer to pick up one of the items in the queue so that it can add another item to it. <br /><br />And then finally, when the consumer does take off ItemFour from the queue. Well, it issues a notify call, in which case the producer, which was waiting on the sharedQueue, gets woken up, and then goes ahead and adds ItemSix to the queue. And when we examine the remainder of the output, well, it looks like the rate of production and the rate of consumption were never mismatched to the degree that the producer or the consumer had to wait. <br /><br />We see for example, that the consumer consumed both ItemSeven and Eight. But before it looked to consume anymore, the producer produced one more item and, sure enough, both of the threads went through to completion. The fact that we have introduced random sleep periods in each of the producer and consumer threads means that, if you were to save things down and run once again, we are likely to see a different output. To test that out, though, I&#39;m going to first clear out the console, and then run this program for a second time.<br /><br />Again, I&#39;m just going to fast forward the recording and then examine the output once it&#39;s done. And what we see in the output is a little different from the previous run. Initially, neither of the threads goes into a wait state. But just a little later, well, there is an empty queue when the consumer tries to consume a fifth item, but this has not been generated by the producer at the time. <br /><br />However, once it does produce ItemFive, the consumer gets woken up, and then goes ahead and consume some more. Until that is the producer adds ItemSeven and Eight to the queue, and then tries to add a ninth item, only to find that the queue is full. But of course, the producer does get woken up and then both the producer and the consumer are able to exhaust their capacities. <br /><br />All right, so with that, we have now successfully solved the simplest case of the producer consumer problem using multi-threading in Java. In the next video, we continue exploring this problem by altering the capacity to consume for the consumer. And we&#39;ll also see what happens if you were to create multiple instances of the consumer.</div>
</div>
<div>
<h2 id="7fac7d66-3460-4738-8e38-b97dbe3aba5d">
Tweaking the Producer and Consumer
</h2>
<div>[Video description begins] <em>Topic title: Tweaking the Producer and Consumer. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />Having simulated the Producer-Consumer problem using threads in Java, let&#39;s now put our implementation to the test by altering some of the configurations. <br /><br />[Video description begins] <em>The screen displays the ProducerConsumer class containing lines of code.</em> [Video description ends] <br /><br />So we currently have a shared queue with a buffer size of 2.<br /><br />[Video description begins] <em>He highlights the code on line 9 that reads: SharedQueue sharedQueue &#61; new SharedQuue(new LinkedList&lt;String&gt;(), 2);.</em> [Video description ends] <br /><br />Let&#39;s see what happens if you were to increase this to 4. The result of this modification is that the producer now has a little more wiggle room. <br /><br />[Video description begins] <em>He highlights the code on line 11 that reads: Producer producer &#61; new Producer(sharedQueue);.</em> [Video description ends] <br /><br />With this increased capacity, it is less likely that the producer will run into a full buffer. So let&#39;s see what happens if we were to save things down and then run the program. Well, from the first few iterations, at least in my case, neither the producer nor the consumer go into a wait state. But I&#39;m just going to let the threads run through to completion and then scroll up to take a look at the output. <br /><br />So at least in this run on my machine, it looks like the producer has been able to run without ever having to go into a wait state. In fact, this also applies to the consumer, right until it processes nine items, and then tries to remove one more item from the sharedQueue. But it finds that the producer has not yet generated a tenth item. But once that is done, well, both the producer and the consumer are able to complete their respective tasks.<br /><br />Moving along then, I&#39;m just going to re-run this program and once the output has been generated let&#39;s scroll up and take a look. And again, there is an instance of the consumer going into a wait state. But with the increased buffer size, this is never really a problem for the producer. All right, let&#39;s continue playing around with the configurations for the producer and the consumer. This time let&#39;s set the shared queue capacity back to 2.<br /><br />And then let&#39;s reduce the capacity of the consumer so that it&#39;s only able to consume 7 out of the 10 items which are generated by the producer.<br /><br />[Video description begins] <em>He changes the code on Line 12 which now reads: Consumer consumer &#61; new Consumer(sharedQueue, &#34;ConsumerOne&#34;, 7);.</em> [Video description ends] <br /><br />You can expect then that the producer will definitely encounter a full buffer. Once the consumer has consumed its seventh and last item, the producer can still produce three more items, but only two of those can be added to the queue. So let&#39;s just save things down and then run the program to see what exactly transpires. <br /><br />All right, so there are at least a couple of instances of the consumer going into the wait state, and the program freezes at the point where the queue is full. And the producer is waiting for something to take the items of the queue. So this is something to be mindful of, if the producer or the consumer have a limited capacity. Where one of them could effectively be starved if there is a mismatch between the rate of consumption and the rate of production. <br /><br />Scrolling up in the output, we can confirm that the consumer goes to sleep a couple of times. But the most significant detail here is that at the very end the producer has nothing to do. Now for us to move along, the only thing to do is to actively terminate the program. And on the Eclipse IDE we can hit the stop button for that. And when that&#39;s done, I just clear out the console as well for good measure. And we&#39;ll now make one more change, where we up the consumer capacity to 13.<br /><br />[Video description begins] <em>He changes the code on Line 12 which now reads: Consumer consumer &#61; new Consumer(sharedQueue, &#34;ConsumerOne&#34;, 13);.</em> [Video description ends] <br /><br />So you can imagine then that the producer will produce its ten items and once a consumer has processed all of them, well, it will be waiting on an empty queue. So the consumer will effectively be starved. To confirm that this is what happens, let&#39;s save things down and then rerun the program. <br /><br />And we see more instances of items being produced and consumed, and also a few weights as you can imagine. But then at the very end, well, the producer has run its course, but the consumer is still waiting. And we&#39;ll wait indefinitely until we proactively terminate the program. In a real application, it is possible that you will require the producer and consumer threads to run forever. <br /><br />However, if the producer or consumer have a finite capacity, this is something you will need to be mindful of. Moving along then I&#39;m going to clear up the console first, and it&#39;s time now for us to add a little more complexity. We have been working with a single producer and a single consumer thread so far, and things have been rather smooth. <br /><br />[Video description begins] <em>He replaces the code from lines 11 till 18. The new lines of code span from line 11 till line 21.</em> [Video description ends] <br /><br />But let&#39;s see what happens if you were to replace the code which we have in place at the moment, and then paste in this one where we still have a single producer, but now there are two consumers, consumerOne and Two, with capacities of 7 and 3. <br /><br />[Video description begins] <em>He highlights the code on line 11 that reads: Producer producer &#61; new Producer(sharedQueue);.</em> [Video description ends] <br /><br />[Video description begins] <em>He changes the code on Line 12 and line 13. Line 12 reads: Consumer consumerOne &#61; new Consumer(sharedQueue, &#34;ConsumerOne&#34;, 7);. Line 13 reads: Consumer consumerTwo &#61; new Consumer(sharedQueue, &#34;ConsumerTwo&#34;, 3);.</em> [Video description ends]<br /><br />So the production capacity now does match the consumption capacity. A problem we will face however, is when a consumer thread issues a notify call. The invocation of notify wakes up one of the sleeping threads on the object, but it&#39;s not in our control, which of the threads gets woken up, and this can lead to an error. <br /><br />[Video description begins] <em>He highlights the code on lines 16 and 17. Line 16 reads: Thread cOne &#61; new Thread(consumerOne, &#34;ConsumerOne Thread&#34;);. Line 17 reads: Thread cTwo &#61; new Thread(consumerTwo, &#34;ConsumerTwo Thread&#34;);.</em> [Video description ends] <br /><br />To see exactly how this works, let&#39;s save things down and then run this program. And once again, I&#39;m going to fast forward here, where you will already notice that there is some error, but we&#39;ll get to the details of that in just a little bit. Scrolling all the way to the top. Well, things do seem rather normal. The producer produces an item, ConsumerTwo consumes the first item, and then goes into a wait state. <br /><br />And then another item is produced, and then another one is consumed. And this is where things get interesting. You&#39;ll observe that at the bottom lines, both ConsumerOne and the ConsumerTwo threads are waiting on an empty queue. And right after that, well, the producer has produced item three, after which it will have issued a notify call and one of the two waiting threads will be woken up. In this case, it was ConsumerOne. Once ConsumerOne has consumed that item, though it invokes the notify function on the shared queue. And the only thread which was sleeping on that queue was ConsumerTwo.<br /><br />[Video description begins] <em>He highlights the code on line 17.</em> [Video description ends] <br /><br />However, there was nothing for ConsumerTwo to consume since the queue at that point was empty, and this is where an error gets thrown. ConsumerTwo has acquired a lock on the shared queue, and then has tried to remove an element from it. But of course, since there was nothing in there, a NoSuchElementException gets thrown. When we scroll further along, we see that this has no effect on the ConsumerOne, and producer threads. <br /><br />And, in fact, both of them keep going on. And on my machine each of them have completed their tasks. So the problem with our current solution for the producer consumer problem is that it can only work with a single producer and single consumer thread. A call to notify on the shared queue will wake up any sleeping thread. <br /><br />And there is no distinction between threads which wait on an empty queue, such as consumers and those which wait on a full queue such as producers. The producer and consumers in this case, wait on the same shared resource, but on different conditions. And the solution we will need to implement to fix this problem is to use a condition instance. We will explore that in the next video.</div>
</div>
<div>
<h2 id="759fdeb5-c461-4538-b865-f08de04c5943">
The Condition Object
</h2>
<div>[Video description begins] <em>Topic title: The Condition Object. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />In the previous video, we saw one of the limitations in how we have implemented the producer consumer problem. Specifically, it will not work if you have anything beyond a single producer and single consumer thread. The solution for us is to make use of the condition object which is available in Java. This allows different threads to wait on different conditions on the same object. So to see how this works, let&#39;s go ahead into our SharedQueue.java source and then make some modifications here. <br /><br />[Video description begins] <em>The SharedQueue class displays in the main pane. It contains lines of code.</em> [Video description ends]<br /><br />At the moment, the locking mechanism which we have in place for the SharedQueue is the synchronized block we have defined within the producer and consumer tasks. But now let&#39;s introduce a lock to go with the SharedQueue. <br /><br />[Video description begins] <em>He enters the following lines of code in lines 4, 5, and 6. Line 4 reads: import java.util.concurrent.locks.Condition;. Line 5 reads: import java.util.concurrent.locks.Lock;. Line 6 reads: import java.util.concurrent.locks.ReentrantLock;.</em> [Video description ends] <br /><br />We import the lock interface and also the ReentrantLock, but beyond that, we also import the condition interface. Since our producer and consumer threads will wait on different conditions for the SharedQueue, we will now package those conditions along with the SharedQueue. <br /><br />[Video description begins] <em>He highlights the code on line 8 that reads: public class SharedQueue {.</em> [Video description ends] <br /><br />I&#39;m now just going to clear out the current contents of the ShareQueue class and then paste in the new code. <br /><br />[Video description begins] <em>He highlights the code on lines 10 and 11. Line 10 reads: Queue&lt;String&gt; queue;. Line 11 reads: Int capacity;.</em> [Video description ends] <br /><br />And beyond the queue as well as the capacity members, we introduce a re-entrant lock called queueLock. <br /><br />[Video description begins] <em>He highlights the code on line 12 which reads: Lock queueLock &#61; new Reentrant Lock ();.</em> [Video description ends] <br /><br />The reason for this, is that reentrant lock does allow us to create conditions. And this is precisely what we do in the lines following this. So we create two conditions called notFull to represent a queue, which is not full. <br /><br />[Video description begins] <em>He highlights the code on line 13 which reads: Condition notFull &#61; queueLock.newCondition();.</em> [Video description ends] <br /><br />And this is the condition on which a producer will be waiting, since it can only add to a queue which is not full. Similarly, consumers will wait for the queue which is not empty. And this is the second condition we have here.<br /><br />[Video description begins] <em>He highlights the code on line 14 which reads: Condition notEmpty &#61; queuelock.newCondition();.</em> [Video description ends]<br /><br />The constructor for the SharedQueue is exactly the same as before. And this concludes the changes we need to make to the SharedQueue class.<br /><br />[Video description begins] <em>He highlights the code from line 16 to line 19. Line 16 reads: public SharedQueue(Queue&lt;String&gt; queue, int capacity {. Line 17 reads: this.queue &#61; queue;. Line 18 reads: this.capacity &#61; capacity;. Line 19 reads: }.</em> [Video description ends]<br /><br />So we save things down, and it&#39;s now time for us to modify the producer to make use of the fact that we now have conditions attached to a SharedQueue.<br /><br />[Video description begins] <em>The Producer class displays in the main pane.</em> [Video description ends] <br /><br />And once we get here, well, we can simply replace everything in the produce function, since we don&#39;t need these synchronized blocks anymore.<br /><br />[Video description begins] <em>He deletes the lines of code from lines 16 to 36.</em> [Video description ends] <br /><br />And then this is the new version of produce. <br /><br />[Video description begins] <em>He pastes new lines of code from line 16 to line 29.</em> [Video description ends]<br /><br />What exactly do we have here? Well, just as before, it will produce an item which has passed to it as argument. <br /><br />[Video description begins] <em>He highlights the code in line 14 which reads: public void produce(String item) throws InterruptedException {.</em> [Video description ends]<br /><br />But before it updates the SharedQueue, it will acquire the lock which is associated with it. <br /><br />[Video description begins] <em>He highlights the code on line 16 which reads: sharedQueue.queueLock.lock();.</em> [Video description ends] <br /><br />Since the queueLock is a reentrant lock, we can acquire it by invoking the lock function, and keep in mind that this is a blocking call. And once a lock is acquired, we check whether the queue is full.<br /><br />[Video description begins] <em>He highlights the code on line 17 which reads: If (sharedQueue.queue.size() &gt;&#61; sharedQueue.capacity) {.</em> [Video description ends] <br /><br />And if it is, well, we wait for the notFull condition. <br /><br />[Video description begins] <em>He highlights the code on line 21 which reads: sharedQueue.notFull.await();.</em> [Video description ends] <br /><br />And the way we do this is to access the notFull condition object and invoke the await function. So this is in some ways similar to the wait function we have come across in that it relinquishes the lock which it acquired. But unlike the wait function, once this thread has been woken up, the lock will be returned to the thread, which is why it can just go ahead and then add the new item over to the SharedQueue. <br /><br />Going back to the call to SharedQueue.notFull.await, since the notFull condition is associated with the reentrant lock in the shared queue, the thread is able to get back that same lock, which it had relinquished previously. All right, moving along then, once the item has been added to the SharedQueue. <br /><br />[Video description begins] <em>He highlights the code on line 24 which reads: sharedQueue.queue.add(item);.</em> [Video description ends] <br /><br />This detail is published to the console and then it is time to wake up any thread which is waiting for the queue to not be empty. <br /><br />[Video description begins] <em>He highlights the code on line 25 which reads: System.out.println(&#34;Produced : &#34; &#43; item);.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the code on line 27 which reads: sharedQueue.notEmpty.signal();.</em> [Video description ends]<br /><br />And this is where we invoke the function sharedQueue.notEmpty.signal. We will to define the consumer to wait or specifically await on the not empty condition. And the way to wake up one such a waiting consumer is to invoke the signal. Keep in mind that similar to notify and notify all we have the signal and signal all functions for a condition. By invoking signal here, we wake up one of the awaiting threads. And then it is time for us to unlock the reentrant lock for the SharedQueue.<br /><br />[Video description begins] <em>He highlights the code on line 29 which reads: sharedQueue.queueLock.unlock();.</em> [Video description ends]<br /><br />As for the run function, well, this remains exactly the same.<br /><br />[Video description begins] <em>He highlights the lines of code from line 33 to line 48.</em> [Video description ends] <br /><br />Let&#39;s move along then to the consumer.<br /><br />[Video description begins] <em>The Consumer class displays in the main pane. It contains lines of code.</em> [Video description ends] <br /><br />Again, it is the consume function which we now need to modify and not make use of the synchronized blocks. <br /><br />[Video description begins] <em>He deletes the lines of code from line 17 to line 36. He then pastes a new set of code.</em> [Video description ends] <br /><br />And the code which we have here has some kind of symmetry with what we implemented in the producer. To consume an item, the consumer will first lock the SharedQueue, and then check for an empty queue. <br /><br />[Video description begins] <em>He highlights the code on line 17 which reads: sharedQueue.queueLock.lock();.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code on line 19 which reads: if (sharedQueue.queue.size() &#61;&#61; 0) {.</em> [Video description ends] <br /><br />And if it is empty, well, it awaits on the notEmpty condition.<br /><br />[Video description begins] <em>He highlights the code on line 23 which reads: sharedQueue.notEmpty.await();.</em> [Video description ends] <br /><br />So it effectively remains suspended and also gives up its lock. Well, it can get woken up by a signal call on the notEmpty condition, which is what happens when a producer adds an item to the queue. Once a consumer is woken up, it regains its lock on the SharedQueue, and it&#39;ll go ahead and remove an element from it. <br /><br />[Video description begins] <em>He highlights the code on line 28 which reads: string item &#61; sharedQueue.queue.remove();.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code on line 29 which reads: System.out.println(consumerName &#43; &#34; has consumed &#34; &#43; item);.</em> [Video description ends] <br /><br />Once it conveys this to the console, well, it issues a wake up call to any threads waiting on the notFull condition, and this, of course, can only be a producer thread. <br /><br />[Video description begins] <em>He highlights the code on line 31 which reads: sharedQueue.notFull.signal();.</em> [Video description ends] <br /><br /> And then it releases its lock on the SharedQueue.<br /><br />[Video description begins] <em>He highlights the code on line 33 which reads: sharedQueue.queueLock.unlock();.</em> [Video description ends] <br /><br />All right, we have now made the changes to a SharedQueue resource as well as the producer and consumer tasks. And just like with the producer, there is no change required in the run function in the consumer. <br /><br />[Video description begins] <em>He highlights the lines of code from line 37 to line 52.</em> [Video description ends] <br /><br />So we can save things down now, and then switch over to the producer consumer class. <br /><br />[Video description begins] <em>The ProducerConsumer class displays in the main pane. It contains lines of code.</em> [Video description ends]<br /><br />And we lead things exactly as they are with a single producer and two consumers. And we&#39;ll test out whether waiting on conditions rather than the entire object will enable these threads to run without errors.<br /><br />[Video description begins] <em>He highlights the lines of code from line 11 to line 21.</em> [Video description ends] <br /><br />And when we run the program, well, things are looking good so far. But I&#39;ll just fast forward to the point where all of the threads have completed their tasks and then take a closer look at the output. After the first consumer has consumed item one, we see that both of the consumer threads are waiting on an empty queue. And once the producer has produced the second item. <br /><br />Sure enough, it wakes up one of the waiting threads. Significantly though, once ConsumerTwo has consumed that second item, it does not wake up the other consumer thread. In fact, scrolling along and taking a look at the entire output, it does look like all of the items which are produced were consumed without any issues, even though the consumers had to wait a few times for items to be added to the queue. All right, I&#39;m going to close down this console, and then rerun the program to make sure that this was not merely a fluke. <br /><br />And sure enough, this run of the program, once again, runs without any errors. In fact, you can run this program as many times as you like. And each of those executions should be error free. In the next video, we will focus on adding another producer thread and make sure that multiple producers and multiple consumers can run concurrently.</div>
</div>
<div>
<h2 id="2cd8fe88-2083-4d83-ac65-1e0d57d85212">
Scaling the Producers and Consumers
</h2>
<div>[Video description begins] <em>Topic title: Scaling the Producers and Consumers. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />[Video description begins] <em>The ProducerConsumer class displays in the main pane. It contains multiple lines of code.</em> [Video description ends] <br /><br />With the modifications we made to a producer and consumer implementation, we have been able to run a single producer thread concurrently with two consumer threads. The true test of our application&#39;s ability to scale is when we have multiple instances of the producer running concurrently with several instances of a consumer. Well, to test it out, we will need to make a few modifications to the producer. Specifically, we&#39;ll modify the print statements so that the name of the producer thread is printed out along with the other messages. <br /><br />[Video description begins] <em>The Producer class displays in the main pane. It contains multiple lines of code.</em> [Video description ends] <br /><br />Once we are in the producer, well, let&#39;s just select everything within the produce method once again, and then replace it with this new code. <br /><br />[Video description begins] <em>He replaces multiple lines of code within the class.</em> [Video description ends] <br /><br />The logic here is in fact exactly the same as before. It&#39;s just the print statements which have been changed. But beyond that, we also have the declaration of a thread name variable at the top, which is set to the name of the current thread.<br /><br />[Video description begins] <em>He highlights the code on line 16 that reads: String threadName &#61; Thread.currentThread().getName();.</em> [Video description ends] <br /><br />We in fact use that thread name in each of the print statements. When the queue is full, we will now know exactly which of the producer threads is waiting for it to have some spare capacity. <br /><br />[Video description begins] <em>He highlights the code on line 21 that reads: System.out.println(&#34;Queue is full. &#34; &#43; threadName &#43; &#34;is waiting...&#34;);.</em> [Video description ends] <br /><br />Similarly, when a produced item has been added to the queue, we&#39;ll now know which of the threads have performed that addition. <br /><br />[Video description begins] <em>He highlights the code on line 26 that reads: sharedQueue.queue.add(item);.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code on line 27 that reads: System.out.println(threadName &#43; &#34; produced : &#34; &#43; item);.</em> [Video description ends] <br /><br />So these are the only changes we need within the producer. So we save things down now and can, in fact, head straight over to the producer consumer source. We don&#39;t need to change Consumer.java since its print statements already include the name of the consumer instance.<br /><br />[Video description begins] <em>The ProducerConsumer class displays in the main pane. It contains multiple lines of code.</em> [Video description ends] <br /><br />So within the main function here, I&#39;m again going to select everything and paste in the new code. <br /><br />[Video description begins] <em>He highlights the code in line 7 which reads: public static void main(String[] args ) {.</em> [Video description ends] <br /><br />And we now have two instances of the producer, producerOne and producerTwo. <br /><br />[Video description begins] <em>He highlights the code in lines 11 and 12. Line 11 reads: Producer producerOne &#61; new Producer(sharedQueue);. Line 12 reads: Producer producerTwo &#61; new Producer(sharedQueue);.</em> [Video description ends] <br /><br />Both of these use the same sharedQueue. And we expand the number of consumers as well to three. <br /><br />[Video description begins] <em>He highlights the code on lines 14, 15, and 16. Line 14 reads: Consumer consumerOne &#61; new Consumer(sharedQueue, &#34;ConsumerOne&#34;, 7);. Line 15 reads: Consumer consumerTwo &#61; new Consumer(sharedQueue, &#34;ConsumerTwo&#34;, 8);. Line 16 reads: Consumer consumerThree &#61; new Consumer(sharedQueue, &#34;ConsumerThree&#34;, 5);.</em> [Video description ends] <br /><br />Once again, all of them use the sharedQueue. So we will now have five concurrent threads using the same shared resource. Furthermore, you will observe that the producer threads have a total capacity of 20 items. And all of those 20 items will be consumed across the three consumers. We then initialize five threads with each of the five instances which we have created. <br /><br />[Video description begins] <em>He highlights the code from line 18 to line 23. Line 18 reads: Thread pOne &#61; new Thread(producerOne, &#34;ProducerOne Thread&#34;);. Line 19 reads: Thread pTwo &#61; new Thread(producerTwo, &#34;ProducerTwo Thread&#34;);. Line 21 reads: Thread cOne &#61; new Thread(consumerOne, &#34;ConsumerOne Thread&#34;);. Line 22 reads: Thread cTwo &#61; new Thread(consumerTwo, &#34;ConsumerTwo Thread&#34;);. Line 23 reads: Thread cThree &#61; new Thread(consumerThree, &#34;ConsumerThree Thread&#34;);</em> [Video description ends] <br /><br />And then we start the two producers and the three consumers.<br /><br />[Video description begins] <em>He highlights the lines of code on lines 26 and 27. Line 26 reads: pOne.start();. Line 27 reads: pTwo.start();.</em> [Video description ends] [Video description begins] <em>He highlights the lines of code from lines 29 to line 31. Line 29 reads: cOne.start();. Line 30 reads: cTwo.start();. Line 31 reads: cThree.start();.</em> [Video description ends] <br /><br />So what happens when we save and run? Well, we hopefully should not see any errors thanks to our implementation. And as far as my execution is concerned, there is at least one instance of a consumer thread waiting on an empty queue. And further along, I also see an instance of a producer thread which is awaiting on the not full condition. <br /><br />Furthermore, the consumer three thread which has the lowest capacity has finished execution. And a little later, ProducerTwo also seems to have generated all of its items. I see the message here that ConsumerTwo has also run its course. And a little later well the remaining producer, and the remaining consumer have also finished their executions. <br /><br />So we now know that our solution to the producer consumer problem is definitely scalable. However, it is in fact a little more complex than it needs to be. This is because a lot of the synchronization which we have implemented in code is a built-in feature in many Java data structures. We will explore one such structure in the form of the array blocking queue in the next video. At this point though, you do have a fairly good understanding of condition objects in Java.</div>
</div>
<div>
<h2 id="65d6cf84-dd4f-42bc-9911-7be03ed9a815">
The ArrayBlockingQueue
</h2>
<div>[Video description begins] <em>Topic title: The ArrayBlockingQueue. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />[Video description begins] <em>The ProducerConsumer class displays in the main pane. It contains multiple lines of code.</em> [Video description ends] <br /><br />For a simulation of the producer consumer problem, we have defined our own SharedQueue, which is a queue with a limited capacity and which is also packaged with a lock and conditions. <br /><br />[Video description begins] <em>He highlights the code on line 2.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the lines of code from line 11 to line 17.</em> [Video description ends] <br /><br />These need to be used by the producer and consumer threads, which may operate on the sharedQueue instances concurrently. <br /><br />[Video description begins] <em>He highlights the lines of code from line 18 to line 23.</em> [Video description ends] <br /><br />However, things don&#39;t really need to be this complex. We&#39;ll now see that our code can be a lot simpler. If you just use the built in array blocking queue, which is provided by Java. In fact, we won&#39;t be referring to the shared queue anymore. And we&#39;ll just recode the producer and consumer, to use an ArrayBlockingQueue. So let&#39;s head over to the producer. <br /><br />And I&#39;m just going to replace the existing code. But first we&#39;ll input the ArrayBlockingQueue. <br /><br />[Video description begins] <em>He enters the following code on line 3: import java.util.concurrent.ArrayBlockingQueue;.</em> [Video description ends]<br /><br />This is something which fulfills a lot of the properties which we need for the producer consumer queue. For example, it has a limited capacity, which we initialize it with when creating the queue. And then it also happens to be a blocking queue, threads will block when trying to remove from an existing queue. And we&#39;ll also block when they try to add an element to a queue which is full. So we move along to the code for the producer which makes use of this array blocking queue.<br /><br />[Video description begins] <em>He highlights the code on line 7 which reads: ArrayBlockingQueue&lt;String&gt; SharedQueue;.</em> [Video description ends] <br /><br />Each producer now has a member variable called sharedQueue, which is of type ArrayBlockingQueue. Each element of this queue is a string. And in the constructor for this class, well, it is the ArrayBlockingQueue which needs to be passed to it, in order to create a producer instance.<br /><br />[Video description begins] <em>He highlights the code on lines 9 to 11. Line 9 reads: public Producer(ArrayBlockingQueue&lt;String&gt; sharedQueue) {. Line 10 reads: this.sharedQueue &#61; sharedQueue;. Line 11 reads:}.</em> [Video description ends] <br /><br />We have the same array of ten string items as we did before, but it is the produce function where things get a little interesting, right off the bat, you will observe that it&#39;s much smaller than our previous produce function. <br /><br />[Video description begins] <em>He highlights the code on lines 13 and 14. Line 13 reads: String[] items &#61; {&#34;ItemOne&#34;, &#34;ItemTwo&#34;, &#34;ItemThree&#34;, &#34;ItemFour&#34;, &#34;ItemFive&#34;,. Line 14 reads: &#34;ItemSix&#34;, &#34;ItemSeven&#34;,&#34;ItemEight&#34;,&#34;ItemNine&#34;,&#34;ItemTen&#34;};.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights a section of the code on line 16 which reads: public void produce(String item) throws InterruptedException.</em> [Video description ends]<br /><br />And this is all thanks to the fact that we don&#39;t need to implement any synchronization on our own. So, what exactly do we do here? Well, just like in the old version, there is a string argument, which is the item to be added to the queue. And then inside the function, all we do is to initialize the threatening variable with the name of the current thread.<br /><br />[Video description begins] <em>He highlights the code on line 18 which reads: String threadName &#61; Thread.currentThread().getName();.</em> [Video description ends] <br /><br />And we call the sharedQueue variables put function. <br /><br />[Video description begins] <em>He highlights the code on line 20 which reads: sharedQueue.put(item);.</em> [Video description ends] <br /><br />And this is what is used to add the item to the queue. The ArrayBlockingQueue itself will take care of the synchronization as well as the blocking conditions which we had implemented earlier. Is the queue is full, well, the producer instance will wait until a slot opens up. And if another thread happens to have a lock on this queue, well once again, the put operation will wait. In fact, most of the methods for ArrayBlockingQueues including the put function, a thread safe.<br /><br />So with a highly simplified produce function, we move along to the run method. And this is pretty much exactly the same as before. We iterate over each of the items in the items array, wait for a random period of time between zero and five seconds and then invoke the produce function. The print statement at the end now includes the thread name for the producer. <br /><br />So this concludes the changes required for the producer and we switch focus to the consumer. Well, the changes will be somewhat similar. So I&#39;m just going to replace the existing code, make sure that the ArrayBlockingQueue is available here and then paste in the new consumer code. <br /><br />[Video description begins] <em>The Consumer class displays in the main pane. He highlights the code on line 3 which reads: import java.util.concurrent.ArrayBlockingQueue;.</em> [Video description ends] <br /><br />Sure enough, each instance of a consumer is associated with an ArrayBlockingQueue called sharedQueue. <br /><br />[Video description begins] <em>He highlights the code on line 7 which reads: ArrayBlockingQueue&lt;String&gt; SharedQueue;.</em> [Video description ends] <br /><br />And just as before, it does have a limited capacity and also a name. <br /><br />[Video description begins] <em>He highlights the code on lines 8 and 9 . Line 8 reads: String consumerName;. Line 9 reads: int consumerCapacity;.</em> [Video description ends]<br /><br />And then it is the consume function, which is greatly simplified, all we do to remove an item from the sharedQueue is to invoke the take function, again this is a thread safe operation, so even if there are multiple consumers trying to remove an element from the queue, only one will have access to it at any given time. <br /><br />[Video description begins] <em>He highlights a section of the code on line 17 that reads: public void consume () throws InterruptedException.</em> [Video description ends] <br /><br /> [Video description begins] <em>He highlights the code on line 19 which reads: String item &#61; sharedQueue.take();.</em> [Video description ends] <br /><br />And significantly, if the queue is empty, the consumer thread will just have to wait. So the put an eight functions which we have seen in the producer and consumer will in effect, lock the array blocking queue. But that behavior has already been coded and we don&#39;t need to implement it on our own. Moving along then to the run function, which remains pretty much the same as before.<br /><br />All right, so we have now recoded the producer and consumer and it&#39;s now time for us to head over to the main function. So ProducerConsumer.java will no longer require a linked list and will instead make use of an ArrayBlockingQueue. <br /><br />[Video description begins] <em>The ProducerConsumer class displays. He enters the following code in line 3: import java.util.concurrent.ArrayBlockingQueue;.</em> [Video description ends]<br /><br />Furthermore, we can now get rid of this reference to the sharedQueue instance. <br /><br />[Video description begins] <em>He deletes the code in line 9.</em> [Video description ends] <br /><br />And instead define an ArrayBlockingQueue with a capacity of two items. <br /><br />[Video description begins] <em>He enters the following code in line 9: ArrayBlockingQueue&lt;String&gt; sharedQueue &#61; new ArrayBlockingQueue&lt;String&gt;(2);.</em> [Video description ends] <br /><br />And with that, we&#39;ve concluded all of the changes we need to make to our source files. However, at least in my case, these are still not saved. So I&#39;ll just switch over to the producer and then save. We&#39;ll do the same with the consumer. And finally, we head over to producer consumer, save things down. And it&#39;s not time for us to run our program. Soon enough, the console messages have started to appear. <br /><br />And they don&#39;t seem to be any errors. And once all of the threads have finished execution, well, we can just scroll up and make sure that everything has behaved exactly as we wanted to. So we see that each of our producers and each of our consumers have done their jobs in terms of production and consumption of items. <br /><br />And we can in fact confirm that a total of 20 items have been produced, and then 20 of them have been consumed. And this is the benefit of using the built in thread safe data structures with Java has to offer. Since we don&#39;t need to implement any of the synchronization on our own that however, only applies if the data structure does fulfill a specific purpose. <br /><br />So for example, for a producer consumer problem, the ArrayBlockingQueue may fit the requirements perfectly. On the other hand, if you do need to implement your own data structure, you now know how you can set up locks and conditions. In order to synchronize access to that as well.</div>
</div>
<div>
<h2 id="215cb802-69d9-423c-9a3f-49efa7fa90cc">
Course Summary
</h2>
<div>[Video description begins] <em>Topic title: Course Summary</em> [Video description ends] <br /><br />You have now covered a lot of the low level locking mechanisms in the Java programming language and how these can be applied to solving the producer-consumer problem. Here is a summary of what was covered in this course. We started off by using synchronized blocks for concurrent producer and consumer threads to access and update a shared queue. We then addressed some of the limitations of this approach by implementing a ReentrantLock and Condition objects. <br /><br />The Condition objects allow the producer to wait on one condition while the consumer waits on a different one, even though they both apply to the same shared queue resource. Finally, we explored how the solution can be simplified with the use of a built-in concurrent data structure which is offered by Java. This is the ArrayBlockingQueue, which is specifically meant for the producer-consumer problem. <br /><br />Now that you&#39;ve done the labs in this course, you have a firm grasp of locking mechanisms, their potential use cases, as well as the specifics of their implementation. You are well equipped to move on to a course covering a breadth of concurrency objects available in the Java programming language such as semaphores, atomic variables, as well as concurrent collection objects.</div>
</div>
</body>
</html>
