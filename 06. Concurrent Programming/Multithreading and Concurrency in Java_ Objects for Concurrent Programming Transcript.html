<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Multithreading and Concurrency in Java: Objects for Concurrent Programming Transcript">
<title>Multithreading and Concurrency in Java: Objects for Concurrent Programming Transcript</title>
</head>
<body>
<h1>Multithreading and Concurrency in Java: Objects for Concurrent Programming</h1>
<p><p>Java includes a variety of objects and mechanisms to manage concurrently executing threads working on shared resources. In this course, you will get hands-on with a variety of Java objects and mechanisms to manage concurrently executing threads working on shared resources. You will get to implement semaphores, volatile, and atomic variables and concurrent collections, while recognizing their inidividual features and use cases.</p></p>
<div>
<h2>Table of Contents</h2>
<ol><li><a href="#14b7d71d-73b4-4d10-b083-e6e9d9521602">Course Overview</a></li>
<li><a href="#e7ea1cff-c95a-45bd-b85b-2615c7d62f73">An Introduction to Semaphores</a></li>
<li><a href="#9e8b0750-bf4a-48bf-8aff-423851a9538a">Permit Acquisition in Semaphores</a></li>
<li><a href="#ed5b77d3-f603-4e39-a4e5-3c232f941257">Visibility of Updates to Shared Variables</a></li>
<li><a href="#39cd1c30-b679-4bf6-9eb1-de0a9fefe8a3">Volatile Variables in Java</a></li>
<li><a href="#26d29be2-9a7f-41cb-8fb1-f2cd189bc194">Atomic Variables</a></li>
<li><a href="#25b9d5eb-f403-48f9-9db8-46d6a52fdb98">Synchronized Collections</a></li>
<li><a href="#c7a03cc1-6451-49fe-8477-edd8b7357f73">Thread-safe Lists</a></li>
<li><a href="#3a830d12-c7eb-4343-9141-e0350cf57d35">Writing while Iterating over Lists</a></li>
<li><a href="#fedf5a18-94bf-4956-9a49-84d6b110ee34">The ConcurrentHashMap</a></li>
<li><a href="#76055191-3f2c-470b-a6f3-44dab566ca56">Concurrent Collections Performance</a></li>
<li><a href="#309c2b24-8bd2-4f21-99fb-b83b5f35c235">Course Summary</a></li>
</ol></div>
<div>
<h2 id="14b7d71d-73b4-4d10-b083-e6e9d9521602">
Course Overview
</h2>
<div>[Video description begins] <em>Topic title: Course Overview</em> [Video description ends]
<p>Hi and welcome to this course, an introduction to concurrent programming in Java. My name is Kishan Iyer, and I will be your instructor for this course.<br /><br />[Video description begins] <em>Your host for this session is Kishan Iyer. He is a Software engineer and big data expert.</em> [Video description ends] <br /><br />A little about myself first. I have a Master&#39;s degree in Computer Science from Columbia University, and have previously worked in companies such as Deutsche Bank and Web MD in New York. I presently work for Loonycorn, a studio for high-quality video content. Concurrent programming skills are among the most useful tools in the armory of any software engineer.</p>
<p>The ability to run several tasks simultaneously, even if the sub-task created out of larger tasks, can greatly improve your program&#39;s performance. This can save your organization a lot of time or even deliver a better experience to your end-users. And the Java programming language offers a variety of options when it comes to implementing concurrent programming through multi-threading. Once you&#39;ve understood the fundamentals of concurrent programming, the goal becomes implementing the correct solution for your own multi-threaded Java application. And this course explores the variety of options available in this language to solve concurrency related issues. We begin with the use of semaphores to restrict access to a shared resource to only a specific number of threads.</p>
<p>We then look at the use of volatile variables to ensure updates to shared data is visible to all concurrent threads. We then explore the use of atomic variables to perform atomic operations on data. And finally, we cover a number of built-in data structures available in Java for concurrent programming. And this includes the copy on write ArrayList, and the concurrent hash map. At the end of this course, you will have a breadth of knowledge on the concurrent objects and data structures, which you can use in various scenarios while building your multi-threaded Java app. You will be ready to move on to other advanced topics on concurrent programming in Java. Such as the executor service and the fork joint framework.</p></div>
</div>
<div>
<h2 id="e7ea1cff-c95a-45bd-b85b-2615c7d62f73">
An Introduction to Semaphores
</h2>
<div>[Video description begins] <em>Topic title: An Introduction to Semaphores. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>So far in this learning path, we have covered a number of different ways in which a thread can be granted exclusive access to a resource. This will ensure that there are no race conditions. And that the output of any application will be consistent. So while locks and other mutual exclusion mechanisms do serve a purpose. There will be situations where your goal is not mutual exclusion, but simply to regulate the amount of traffic on a particular resource. This is where Semaphores are a very useful instrument. They allow us to specify an upper limit on the number of concurrent threads which can access a resource.<br /><br />[Video description begins] <em>An Eclipse IDE interface displays. It is divided into three sections. The left pane is titled as, &#34;Package Explorer&#34;, which contains a folder titled as: ThreadingAndConcurrency. To the right is the editor pane and towards the bottom is the Console.</em> [Video description ends]</p>
<p>To see how this works, let us now go ahead and create a new class in the com.skillsoft.concurrency package. Let&#39;s call this one SharedResource.<br /><br />[Video description begins] <em>As he right clicks on the: com.skillsoft.concurrency package, a context menu with multiple options appears. He selects the option: New. A context sub menu appears. He selects the option: Class in the context sub menu. A dialog box titled: New Java Class appears.</em> [Video description ends] <br /><br />And let&#39;s just say this will serve as a wrapper around a number of different shared variables.<br /><br />[Video description begins] <em>As he clicks the &#34;Finish&#34; button in the: New Java Class dialog box. A &#34;SharedResource.java&#34; file gets created in the left pane. The details of the: SharedResource.java displays on the editor pane.</em> [Video description ends]</p>
<p>Once the class is in place, well, I&#39;ll first import the ArrayList class here, and we&#39;ll go ahead and place some other members within the SharedResource. <br /><br />[Video description begins] <em>Line 3 reads as: import java.util.ArrayList;.</em> [Video description ends]<br /><br />[Video description begins] <em>He enters various lines of code from line 7 to line 9.</em> [Video description ends]<br /><br />For the purposes of our demo, the exact variables defined within this resource is not important. Since you won&#39;t be performing any operations on them. And our purpose is to simply show that Semaphores can help us. Restrict the number of active threads on an instance of a SharedResource to a specific number. All right, so now that we have a SharedResource, let&#39;s save things down, and then create one more class in our package. And let&#39;s call this one, MyTask.</p>
<p>And this is one which will require access to an instance of our SharedResource. However, that access will only be granted through a Semaphore.<br /><br />[Video description begins] <em>The details of &#34;MyTask.java&#34; file displays in the editor pane.</em> [Video description ends] <br /><br />And now for us to write the code. The first thing we do is to import the Semaphore class from the java.util.concurrent package.<br /><br />[Video description begins] <em>Line 3 reads as: import java.util.concurrent.Semaphore;.</em> [Video description ends] <br /><br />And this includes functions for threads to acquire and release the Semaphore. Furthermore, we&#39;ll need to make sure that the MyTask class does implement the Runnable interface. <br /><br />[Video description begins] <em>Line 5 reads as: public class MyTask implements Runnable {.</em> [Video description ends] <br /><br />And we will create multiple instances of MyTask to access one instance of a SharedResource via Semaphore. And now, we paste the remaining code for MyTask. So it does include an instance of the SharedResource and also a Semaphore. <br /><br />[Video description begins] <em>He highlights the lines of code from line 7 to line 9. Line 7 reads as: SharedResource sr;. Line 8 reads as: Semaphore sem;. Line 9 reads as: String threadName;.</em> [Video description ends] <br /><br />We also create a variable to store the thread name for each instance of MyTask.<br /><br />[Video description begins] <em>Line 11 reads as: public MyTask (SharedResource sr, Semaphore sem) {. Line 12 reads as: this.sr &#61; sr;. Line 13 reads as: this.sem &#61; sem;. Line 14 reads as: }.</em> [Video description ends] <br /><br />As for the constructor, each MyTask instance will be initialized with an instance of the SharedResource and also a Semaphore. So the goal is for the MyTask instance to access the SharedResource after it has acquired the Semaphore. And how exactly do we do that? Well, for this we move along to the run function. <br /><br />[Video description begins] <em>Line 16 reads as: &#64;Override. Line 17 reads as: public void run() {.</em> [Video description ends]</p>
<p>We start off by initializing the threadName, and then printing out to the Console that this thread is now waiting for the Semaphore. <br /><br />[Video description begins] <em>Line 20 reads as: threadName &#61; Thread.currentThread().getName();.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 22 reads as: System.out.println(threadName &#43; &#34; is waiting for the semaphore...&#34;);.</em> [Video description ends] <br /><br />It&#39;s at this point where we invoke the Semaphore&#39;s acquire function. <br /><br />[Video description begins] <em>Line 24 reads as: sem.acquire();.</em> [Video description ends] <br /><br />So this is potentially a blocking call. If the Semaphore does have capacity, well, the Semaphore is acquired immediately and the code execution can proceed. However, if the capacity has been hit for the Semaphore. The thread will simply have to wait until one of the other threads which have acquired the Semaphore release it. However, once the Semaphore is acquired, we print this fact out to the console.<br /><br />[Video description begins] <em>Line 26 reads as: System.out.println(threadName &#43; &#34; has ACQUIRED the semaphore ! &#34;);.</em> [Video description ends]</p>
<p>And we also include the thread name in the message so that we know exactly which thread has acquired the Semaphore. Then we simulate some work on the SharedResource. In a realistic situation, this may involve some actual updates or even reading data from the SharedResource. But in our case, we just put the thread to sleep for a random period of time up to five seconds. <br /><br />[Video description begins] <em>Line 29 reads as: Thread.sleep((long) (Math.random() * 1000) * 5);.</em> [Video description ends] <br /><br />And beyond that, well, we can do pretty much anything. In my case, I have accessed the size of the ArrayList in the SharedResource.<br /><br />[Video description begins] <em>Line 30 reads as: int numListElements &#61; sr.myList.size();.</em> [Video description ends]</p>
<p>The important thing is the Semaphore is acquired for up to five seconds and then released by the thread by invoking the release function. At this point, one more slot becomes available on the Semaphore and another thread can acquire it and access the SharedResource. Furthermore, make sure that you do handle the interrupted exception. <br /><br />[Video description begins] <em>Line 32 reads as: sem.release();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 36 reads as: catch (InterruptedException e) {. Line 37 reads as: e.printStackTrace();. Line 38 reads as: }.</em> [Video description ends] <br /><br />Because in this case it can be thrown by the call to Thread.sleep, but also, when a thread invokes the Semaphore&#39;s acquire method. Since a thread could be suspended while it&#39;s waiting for another thread to release the Semaphore. Let&#39;s move along then to the main function for the class. What we do here is to create an instance of the SharedResource, which will be shared by a number of different threads. <br /><br />[Video description begins] <em>Line 43 reads as: SharedResource sharedRes &#61; new SharedResource();.</em> [Video description ends]<br /><br />And we also initialize an instance of a Semaphore. The argument to the Semaphore constructor is the number of permits to be linked with it. And in this case, we set it to a value of 2. The way we have coded up this class, when the acquire function is invoked, one of the permits is taken. <br /><br />[Video description begins] <em>Line 45 reads as: Semaphore sem &#61; new Semaphore(2);.</em> [Video description ends]</p>
<p>And similarly, one permit is released when the release function is invoked. This means that there can be at most two concurrent instances of my task which acquire the Semaphore. To demonstrate that we create ten different threads, each of them running an instance of MyTask using the same SharedResource and Semaphore. And we do this within the for loop. <br /><br />[Video description begins] <em>Line 49 reads as: Thread t &#61; new Thread(new MyTask(sharedRes, sem), &#34;Task-&#34; &#43; i);.</em> [Video description ends] <br /><br />[Video description begins] <em>The for loop in line 47 reads as: for (int i&#61;0;i&lt;10;i&#43;&#43;) {.</em> [Video description ends] <br /><br />You&#39;ll observe from the names given to each thread that they will have the names Task-0, Task-1, Task-2, and so on. And at each iteration, we start the thread.<br /><br />[Video description begins] <em>Line 50 reads as: t.start();.</em> [Video description ends] <br /><br />So very quickly, we will have ten concurrent threads, but only two of them at any given point in time can acquire the Semaphore. All right, it&#39;s now time to put our implementation to the test. For which we save things down, and then run the program. Given the ten concurrent threads, you can imagine that there is a flurry of activity. So I&#39;m just going to let this run its course.</p>
<p>And once it&#39;s done, let&#39;s scroll up in the console and see exactly what has happened. So ten different task have been spawned. And the first one to acquire the Semaphore is Task-2. Similarly, Task-1 also acquired the Semaphore but then all of the others had to wait for it. In fact, this does go on for a while. And all of the other eight tasks are at this point waiting for the Semaphore. And then eventually Task-2 releases the Semaphore. This is when Task-5 acquires it and we&#39;re back to two concurrent threads which have acquired the Semaphore. The others are still waiting though.</p>
<p>But when Task-1 releases its hold on it, well this allows one of the other threads to acquire and proceed and that happens to be Task-3. Do keep in mind that individual print statements may often be a little delayed. However, it does become clear from this output that the Semaphore has restricted access to the SharedResource to just two concurrent threads. Let&#39;s move along now and see what happens if you were to increase the number of permits associated with the Semaphore from two to four.<br /><br />[Video description begins] <em>He edits the code in line 45, that now reads as: Semaphore sem &#61; new Semaphore(4);.</em> [Video description ends]</p>
<p>So this means that there can be more concurrent threads which acts as the SharedResource. And let&#39;s see if this is borne out when we save and then run the program. Once again, I&#39;ll just fast forward in this execution. And when we take a look at the output, well, we can see one acquisition here and then a few more acquisitions and releases.</p>
<p>And then at the very end, there were four threads which had access to the Semaphore. Which is confirmed by the fact that the last four messages here are releases. So with that, we have now covered the simplest implementation of semaphores. Where each thread is treated equally and acquires exactly one permit and releases that permit once the job is done. In the next video, we will explore a different variation of Semaphores where different threads acquire different numbers of permits.</p></div>
</div>
<div>
<h2 id="9e8b0750-bf4a-48bf-8aff-423851a9538a">
Permit Acquisition in Semaphores
</h2>
<div>[Video description begins] <em>Topic title: Permit Acquisition in Semaphores. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />[Video description begins] <em>The host continues with the lines of code from the previous video.</em> [Video description ends]
<p>While we have successfully incorporated a semaphore in a multithreaded application, our implementation is somewhat simple. Specifically, it assumes that all of the threads which access the semaphore are equal. This is conveyed through the fact that every single thread acquires and releases exactly one permit on the semaphore. However, in a more realistic application, it is likely that there are some tasks which place a higher burden on the SharedResource than others.</p>
<p>In which case, they should be treated a little differently, when they acquire a semaphore to access that resource. We&#39;ll see exactly how that works now, but first, let&#39;s clear out the contents of the MyTask class. And before we paste in the new code, I&#39;m just going to import the java.util.Random class. <br /><br />[Video description begins] <em>Line 4 reads as: import java.util.Random;.</em> [Video description ends]<br /><br />[Video description begins] <em>He highlights the lines of code from line 8 to line 10. Line 8 reads as: SharedResource sr;. Line 9 reads as: Semaphore sem;. Line 10 reads as: String threadName;.</em> [Video description ends]</p>
<p>And then we can put in the new code, and we can walk through the different steps here. So in addition to the SharedResource, the semaphore and the thread name, each instance of MyTask is now associated with a number of permits.<br /><br />[Video description begins] <em>Line 11 reads as: int numPermits &#61; 1;.</em> [Video description ends]</p>
<p>So in our new implementation, each thread does not just acquire and release a single permit on the semaphore but this value can be greater than one. In a realistic setting you may associate a thread with either higher priority or a higher load on the system with a higher number of permits. In our case we set a default value of one for numPermit. But this is a value which an instance of MyTask is initialized with in the constructor.<br /><br />[Video description begins] <em>He highlights the various lines of code from line 13 to line 17. Line 13 reads as: public MyTask (SharedResource sr, Semaphore sem, int permits) {. Line 14 reads as: this.sr &#61; sr;. Line 15 reads as: this.sem &#61; sem;. Line 16 reads as: this.numPermits&#61; permits;. Line 17 reads as: }.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 19 reads as: &#64;Override. Line 20 reads as: public void run() {.</em> [Video description ends] <br /><br />Let&#39;s move along then to the run function definition. And this is where things are a little different. So beyond initializing the threadName variable and then printing out a message to the Console, we also print out the number of permits associated with the thread. And then when the thread invokes the semaphore&#39;s acquire method, it passes along the number of permits which it needs. <br /><br />[Video description begins] <em>Line 23 reads as: threadName &#61; Thread.currentThread().getName();.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 25 reads as: System.out.println(threadName &#43; &#34; is waiting for &#34; &#43; numPermits &#43; &#34; sem permits...&#34;);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 24 reads as: sem.acquire(numPermits);.</em> [Video description ends] <br /><br />This makes our semaphore a little more flexible in that it is theoretically possible for a thread to acquire all of the associated permits and in effect have exclusive access to the SharedResource. In a similar way, you can have a large number of threads which require just a few permits running concurrently and just a few threads which require a high number of permits, which can concurrently acquire the semaphore. All right, so once a thread has acquired does required number of permits on the semaphore, it prints out a message to the Console. <br /><br />[Video description begins] <em>Line 29 reads as: System.out.println(threadName &#43; &#34; has ACQUIRED &#34; &#43; numPermits &#43; &#34; permits! &#34;);.</em> [Video description ends]<br /><br />And then in our simulation of work, we put the thread to sleep for a total of up to 5 seconds. And then the thread invokes the release function on the semaphore, where it releases all of the permits which had required. So this concludes the run function definition. So we can move along then to the main function. Once again, we create an instance of the SharedResource and to start with, we create a variable called maxPermits to a value of 2. <br /><br />[Video description begins] <em>Line 32 reads as: Thread.sleep((long) (Math.random() * 1000) * 5);.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 34 reads as: sem.release(numPermits);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 45 reads as: SharedResource sharedRes &#61; new SharedResource();.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 47 reads as: int maxPermits &#61; 2;.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 48 reads as: Semaphore sem &#61; new Semaphore(maxPermits);.</em> [Video description ends] <br /><br />We in fact use that variable when we initialize an instance of our semaphore. So it will currently only have two permits to offer, but in subsequent runs, we&#39;ll make sure to increase the number of permits. The goal for us is to create a number of concurrent threads, which require a varying number of permits to access the semaphore. And this number can vary from one up to maxPermits. And how exactly do we do that? Well, observe that we create an instance of the random class. <br /><br />[Video description begins] <em>Line 50 reads as: Random random &#61; new Random();.</em> [Video description ends]</p>
<p>Because in each iteration of the for loop, we initialize an integer called permits, which randomly contains a value between one and the max number of permits. And this permit value will be used when we initialize an instance of MyTask. <br /><br />[Video description begins] <em>Line 52 reads as: for (int i&#61;0;i&lt;10;i&#43;&#43;) {.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 54 reads as: int permits &#61; random.nextInt(maxPermits) &#43; 1;.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 56 reads as: Thread t &#61; new Thread(new MyTask(sharedRes, sem, permits), &#34;Task-&#34; &#43; i);.</em> [Video description ends]</p>
<p>So, in the first run of our program, we will have 10 concurrent threads. And each of them will require either one or two permits to access the semaphore. So let&#39;s see what happens by saving things down and then running this program. Again, I&#39;m going to let this program run its course. And then, we will scroll up to examine the output. Sure enough, there are ten different tasks which are created. <br /><br />And you will observe that some of them require one permit, while others need 2. So scrolling further along, at least in my execution, It looks like Task-8 has ACQUIRED 2 permits on the semaphore. And then of course, no other thread can acquire it. But once Task-8 has RELEASED its 2 permits, well both Task-2 and Task-0 which require only one are able to acquire the semaphore and proceed.</p>
<p>Only once both of those tasks released their respective wholes on the semaphore was Task-which requires 2 permits, able to acquire it and go on. And in the case of Task-1, it effectively had exclusive access to the SharedResource. Thanks to acquiring all of the permits which were available on the semaphore. And we see a few other examples in the output here where threads such as Task number 6, which required 2 permits, need other threads to release those permits in order to proceed. <br /><br />So, we have now successfully simulated a situation where different threads have different degrees of access to the SharedResource. And just to be sure, I am going to re-run this program and we see a similar pattern playing out. All right, let&#39;s now tweak our code just a little bit specifically we can now change the value of the maxPermits variable from 2 to 4. And once we save things down, and re-run, we now have 10 threads, which require between 1 and 4 permits on the semaphore.</p>
<p>I&#39;ll just pause the recording at different points in order to examine the output here. As it turns out in this run, none of the 10 threads required just a single permit, which is of course a possibility when we use a random number generator. But the consequence of that is that when Task-3 acquires three permits on the semaphore, well, all of the others are waiting for it. Which means that Task-3 has exclusive access to the SharedResource. <br /><br />It&#39;s only a little later when Task-3 releases its permits that the other threads can proceed. So it looks like Task-4 has picked up two of the permits which were needed and then it goes on to release them. Which allows another Task needing 3 permits to pick them up and move along. And in this particular run, it is quite rare for two threads to hold the semaphore at any given point in time. I see one instance here with Tasks-5 and 6 which required 2 permits each, are able to aquire the semaphore at the same time. <br /><br />And just a little later, when both of them release the semaphore where all four permits become available. And Task-7, which requires all four of them, has taken the opportunity to acquire them and proceed. So I&#39;ll just let this program run its course. And we see one more instance of Task-9 which required all four permits on the semaphore. So we have now successfully implemented a multi-threading application, where in terms of acquiring a semaphore, not all threads are created equal. This of course gives us the flexibility of setting threads, which put a higher load on the resources to require more permits in order to acquire the SharedResource.</p></div>
</div>
<div>
<h2 id="ed5b77d3-f603-4e39-a4e5-3c232f941257">
Visibility of Updates to Shared Variables
</h2>
<div>[Video description begins] <em>Topic title: Visibility of Updates to Shared Variables. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>One issue with running a multi threaded application on hardware which contains several CPU cores is that we may have multiple threads accessing a SharedResource which run on separate course. And, when an update is performed to the shared resource, they will write to their own CPU cache, rather than to the main memory, which is visible to all threads.<br /><br />[Video description begins] <em>An Eclipse IDE interface displays.</em> [Video description ends] <br /><br />Thankfully, the Java programming language does account for this and enforces rights to main memory if we declare a variable to be volatile. To see precisely how this works, we will create another class in the com.skillsoft.concurrency package. This one will be called Looper, which will include a loop which can run indefinitely. If it does not pick up an update made to a shared resource. Once this has been created, well, we can proceed and paste the code for it.</p>
<p>First of all, we&#39;ll need to make sure that it implements the Runnable interface so that its instances can run in a thread. And then, once the code is pasted, let&#39;s see precisely what the Looper class does. So all instances of Looper will share two variables.<br /><br />[Video description begins] <em>Line 5 reads as: public static boolean keepLooping &#61; true;. Line 6 reads as: public static int number &#61; 0;.</em> [Video description ends] <br /><br />One of these is a boolean called keepLooping, and this is set to true. This is a condition on which we decide whether to continue with a while loop a little later. And the other static member is an integer called number, which is initialized to 0. This is a value which will get updated in that while loop. Furthermore, each instance will have its own local variable called localNum.<br /><br />[Video description begins] <em>Line 8 reads as: public int localNum &#61; 0;.</em> [Video description ends] <br /><br />So what exactly happens to each looper instance when it&#39;s run in a thread?<br /><br />[Video description begins] <em>Line 10 reads as: &#64;Override. Line 11 reads as: public void run() {.</em> [Video description ends]</p>
<p>Well, within the run function, we start off by setting a threaName and then we have the while loop. <br /><br />[Video description begins] <em>Line 13 reads as: String threadName &#61; Thread.currentThread().getName();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 15 reads as: while(keepLooping) {.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 17 reads as: if(localNum !&#61; number) {.</em> [Video description ends]</p>
<p>So while the keepLooping variable is true, this while loop will keep executing. In each iteration, it checks whether the value of the localNum variable matches that of the static number. And if there is a mismatch, well that is when we enter this if block. And then print out a message to the Console that a change has been detected in the value of the number and then we update the value of localNum.<br /><br />[Video description begins] <em>Line 18 reads as: System.out.println(threadName &#43; &#34; has picked up the change in number&#34;);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 19 reads as: localNum &#61; number;.</em> [Video description ends] <br /><br />So what exactly is the purpose of defining the run method in this manner? Well, when we spawn an instance of the Looper and run it in a thread, we will separately update the keepLooping variable from the main thread. And the goal is to see whether that update does propagate to the instance of Looper. So when we do perform the update, we will set keepLooping to false, in which case the Looper instance should exit the while loop.<br /><br />[Video description begins] <em>Line 23 reads as: System.out.println(threadName &#43; &#34; is done!&#34;);.</em> [Video description ends] <br /><br />And then we print out to the Console that the thread is done. And then it&#39;s time to define the main function. We start off by spawning 10 instances of the Looper. Each of these are set to run in separate threads ,and we proceed to start each of those threads as well. From the code, we know that keepLooping is initialized to true, which is why the while loop will keep going on. <br /><br />And the values of localNum and number are also initialized to 0. So while the threads are spawned, they will keep executing the while loop without entering the if-block within it. But, once we exit the for loop in the main function, well this is where we have 10 concurrent threads, each running an instance of Looper, and we change the value of the static number variable to 13. <br /><br />[Video description begins] <em>Line 27 reads as: for (int i&#61;0;i&lt;10;i&#43;&#43;) {.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 29 reads as: Thread t &#61; new Thread(new Looper(), &#34;Looper-&#34; &#43; i);. Line 30 reads as: t.start();.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 32 reads as: number &#61; 13;.</em> [Video description ends]</p>
<p>This should trigger a mismatch between localNum and number, which means that the code execution should enter the if block. Since the main thread, as well as each thread running a Looper instance share the same static number variable. However, this is only possible if the update to number performed by main has been propagated to all of the other threads. If it had only updated its own CPU cache, then this update will not be visible to the other Looper threads. In any case, after this update, the main function prints out to the Console that it has changed the number variable and then it goes to sleep for 10 seconds. <br /><br />[Video description begins] <em>Line 33 reads as: System.out.println(&#34; number changed by MAIN&#34;);.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 35 reads as: Thread.sleep(10000);.</em> [Video description ends]</p>
<p>After which, it updates the static keepLooping variable by changing this to false. [Video description begins] <em>Line 36 reads as: keepLooping &#61; false;.</em> [Video description ends]<br /><br />If this update has been propagated to all of the Looper instances, they should exit their while loops and then print out to the Console that they are done. But again, this is only applicable if the update to keepLooping is visible to all of the threads. So, let&#39;s see what exactly happens if we were to save and then run this program. Well, in a few seconds, it looks like the change to the value of number has been performed by the main thread. And in fact, that change has been picked up by Looper number 9. <br /><br />However, none of the other threads has seen it, which is why that code execution never enters the if block. Furthermore, over 10 seconds have elapsed at this point, which means that the main thread has updated the value of keepLooping. But, none of the threads not even Looper-9 has picked up this change. Which is why all of the Looper instances are now caught in an infinite loop. Keep in mind, however, that the behavior on your own system may be a little different. It is possible that the updates have been propagated, and all your Looper instances have terminated as well.</p>
<p>However, this behavior is not guaranteed unless we declare the shared variables to be volatile. So the only solution at this point to stop the program execution is to forcibly hit the stop button in the IDE. So, what we have implemented here highlights one of the problems in a multi-threaded setting. Where updates made by a thread may not be visible to all of the others. Since it&#39;s possible that the update has only been written to the CPU cache of the thread performing that update, in our case, this is the main thread. <br /><br />Now just to confirm that this behavior was no fluke, I&#39;m just going to rerun the program and the output is in fact, identical to the last run.Where the main thread has updated the value of number, but this has only been picked up by one of the Looper threads. So once again, I&#39;m just going to forcibly stop this execution. And in the next video, we will take a look at how the volatile keyword can guarantee visibility of any updates to a variable to all threads which share it.</p></div>
</div>
<div>
<h2 id="39cd1c30-b679-4bf6-9eb1-de0a9fefe8a3">
Volatile Variables in Java
</h2>
<div>[Video description begins] <em>Topic title: Volatile Variables in Java. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>In the previous video, we saw how the update made to a shared variable by one thread may not be visible to all others. Java fully recognizes this, which is why it has introduced the volatile keyword. To see how this works, let&#39;s see what happens if you were to head up in this class definition and then declare the number variable to be volatile. <br /><br />[Video description begins] <em>The host continues with the lines of code from the previous video.</em> [Video description ends] <br /><br />[Video description begins] <em>He edits the line of code in line 6, which now reads as: public static volatile int number &#61; 0;.</em> [Video description ends]</p>
<p>When we do this, Java guarantees that the update to the number variable will not just be performed within the CPU cache of the updating thread, but it will be performed in main memory. Furthermore, any reads on this variable will also be performed through main memory, which means that all of the threads which share this variable will in effect, be working on the same copy. And not on their local copies in the CPU cache. So to test what effect this has on our program, let&#39;s save things down, and then run.</p>
<p>Now I&#39;m just going to let this program run, and we&#39;ll examine the output at the end. And in fact, we see that as soon as the main thread has updated the number variable, each of the different looper threads have picked up this modification. And in fact, if we were to scroll along a little further, we observe that the change to keepLooping has also been propagated to the different threads and they have exited their while loops. So you&#39;ll observe that, I do not need to forcibly stop the program execution this time, since all of the threads have exited gracefully.</p>
<p>And this is, in fact, an effect of declaring the number variable to be volatile. Some of the compiler optimizations which are carried out, are invalidated when we include a volatile variable. Which seems to have had the effect of allowing the threads to view the update to keepLooping as well. I&#39;m now just going to rerun this program. And then once it is done, I&#39;ll just scroll up and take a look at what exactly has transpired.</p>
<p>We observe here that, a lot of the print statements from the individual threads have shown up just before the print statement from main. Again, this is a quirk of how Java executes the print statements, rather than the actual ordering of how the updates were picked up. However, once again, we observe that it&#39;s not just the change in the number variable but the change to keepLooping which has also been propagated to the different threads. Let&#39;s now tweak our program just a little bit, where we head over to the variable definitions.Â <br /><br />[Video description begins] <em>He edits the lines of code in line 5 and line 6. Line 5 now reads as: public static volatile boolean keepLooping &#61; true;. Line 6 now reads as: public static int number &#61; 0;.</em> [Video description ends]</p>
<p>And then, change the number variable to be nonvolatile once again, but now keepLooping is a volatile variable. So what effect does this have on our code execution? Well, we can just run to find out. Well, it looks like the changes to number as well as the update to keep Looping have been picked up. So I&#39;m just going to scroll up in the output to see what has transpired. So the main thread has updated the number variable, and then each of the Looper threads have entered their respective if blocks.</p>
<p>Once that statement has been printed out, well, a little later, it looks like the update to keepLooping has also been propagated to the different threads. And of course, this is thanks to the fact that keepLooping is now a volatile variable. Which means that all of the writes as well as the different reads, now reference the same location in memory. And this is an important lesson when it comes to using shared variables across multiple threads.</p>
<p>If we do want the updates to be visible to each and every thread, you are better off declaring those variables to be volatile. I&#39;m now just going to rerun this program to make sure that this output was no fluke. And on this occasion as well, it looks like the updates to the shared variables have been propagated to all of the threads. All right, as a final check, let&#39;s see what happens if you were to make both of the variables nonvolatile once again.<br /><br />[Video description begins] <em>He again edits the lines of code in line 5, that now reads as: public static boolean keepLooping &#61; true;.</em> [Video description ends]</p>
<p>So I&#39;m going to save things done, and then rerun the program. And I&#39;m back to the previous state of events, where the main thread has updated the number variable. However, only one of the threads has picked this up. And the only option available at this point to terminate the program is to hit the Stop button. So now that we know how the visibility of updates to variables can be guaranteed by declaring them as volatile, in the next video, we will explore how certain types of operations on shared variables can be made atomic by the use of atomic variables.</p></div>
</div>
<div>
<h2 id="26d29be2-9a7f-41cb-8fb1-f2cd189bc194">
Atomic Variables
</h2>
<div><br />[Video description begins] <em>Topic title: Atomic Variables. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>When developing a multi-threaded application, there may be instances where you wish to perform an update on a variable and immediately read the updated value. You may also want both of these operations to be performed in an Atomic manner, where you&#39;re able to read your own updates. We have already covered the fact that this can be achieved by means of locking. However, that does come at a significant cost in terms of overall performance. If it is just a single variable whose updates and reads you wish to make Atomic, well, the best solution in this case is to make use of the built-in Atomic variables in Java. <br /><br />[Video description begins] <em>An Eclipse IDE interface displays.</em> [Video description ends] <br /><br />To see how these work, we can now create another class in the package we&#39;ve been using so far. And this will be called CommonCounter. We have already created a CommonCounter class previously in this learning path. So if you still have that source file accessible you may as well go and reuse it. If it&#39;s not accessible though, you can click along with me and then paste this code in the CommonCounter. <br /><br />[Video description begins] <em>Line 3 reads as: public class CommonCounter {.</em> [Video description ends] <br /><br />What we have here are two integers, firstNum and secondNum, which we initialize to 0.<br /><br />[Video description begins] <em>Line 5 reads as: private int firstNum &#61; 0;. Line 6 reads as: private int secondNum &#61; 0;.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 8 reads as: public void incrementCounter() {.</em> [Video description ends] <br /><br />And then we have an incrementCounter() function. For now, we&#39;ll leave this as an unsynchronized function. And within this, both of these variables will be incremented. We also define getters for each of them so that we can monitor their values. <br /><br />[Video description begins] <em>Line 10 reads as: firstNum&#43;&#43;;. Line 11 reads as: secondNum&#43;&#43;;.</em> [Video description ends]<br /><br />[Video description begins] <em>The get function code for &#34;firstNum&#34; variable is present from line 14 to line 16. Line 14 reads as: public int getFirstNum() {. Line 15 reads as: return firstNum;. Line 16 reads as: }. In a similar way, the code for &#34;secondNum&#34; is defined from lines 18 to 20.</em> [Video description ends]</p>
<p>So within our CommonCounter, we have two variables. And we&#39;ll see what happens if you were to declare one of them as an Atomic variable and leave the other one as a regular integer. All right, now that we have a CommonCounter, let&#39;s go ahead and create one more Class. This will be called CountIncrementor. And again, if you already have this class from the previous labs to the learning path, feel free to reuse it. But we will be making a fair number of code changes in any case. To enable the running of CounterIncrementor instances in threads, we implement the Runnable interface here. <br /><br />[Video description begins] <em>Line 3 reads as: public class CounterIncrementor implements Runnable {. He pastes multiple lines of code after line 3.</em> [Video description ends]<br /><br />And then beyond that, each CounterIncrementor has access to an instance of CommonCounter, whose incrementCounter() function will be invoked a set number of times.<br /><br />[Video description begins] <em>Line 5 reads as: private CommonCounter myCounter;. Line 6 reads as: private int numIterations;.</em> [Video description ends]</p>
<p>Where and the number of times is determined by the numIterations variable. Both a CommonCounter instance and the number of iterations will be passed along when initializing an instance of CounterIncrementer. <br /><br />[Video description begins] <em>Line 8 reads as: public CounterIncrementor(CommonCounter commonCounter, int numIterations) {. Line 9 reads as: this.myCounter &#61; commonCounter;. Line 10 reads as: this.numIterations &#61; numIterations;. Line 11 reads as: }.</em>[Video description ends] <br /><br />And then the run function for this is rather simple. For the given number of iterations, we just call the incrementCounter() function on the myCounter variable. <br /><br />[Video description begins] <em>Line 16 reads as: for (int i&#61;0;i&lt;numIterations;i&#43;&#43;) {.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 18 reads as: myCounter.incrementCounter();.</em> [Video description ends] <br /><br />The plan is to spawn multiple instances of the CounterIncrementor, and run them in separate threads. And if they&#39;re all invoking the incrementCounter() function on the same CommonCounter object, it is quite likely that a race condition will be the result.</p>
<p>All right, now that we have defined the common resource, and the task which will increment that resource, we now create another class. And this is called Synchronization. If you already have a source file with that name, well, you can just reuse it. This is one where we will have a main function. <br /><br />[Video description begins] <em>He selects the check box: public static void main(String[] args), underneath the section: Which method stubs would you like to create? present in the &#34;New Java Class&#34; dialog box.</em> [Video description ends] <br /><br />And we go ahead and create this. As usual, I will paste the code for the synchronization class. <br /><br />[Video description begins] <em>Line 3 reads as: public class Synchronization {.</em> [Video description ends]</p>
<p>First though, I&#39;ll remove this comment from the main function. <br /><br />[Video description begins] <em>He removes the following comment from line 6, that reads as: // TODO Auto-generated method stub.</em> [Video description ends] <br /><br />And then just before it, we&#39;ll define a constant called NUM_ITERATIONS whose value is 1 million. <br /><br />[Video description begins] <em>He adds the following line of code before the main function in line 5, that reads as: private static final int NUM_ITERATIONS &#61; 1000000;.</em> [Video description ends] <br /><br />So our CounterIncrementer instances will be initialized with this constant. Moving along then to the main function. We start off by creating an instance of CommonCounter. <br /><br />[Video description begins] <em>He pastes multiple lines of code.</em> [Video description ends]</p>
<p><br />[Video description begins] <em>Line 9 reads as: CommonCounter commonCounter &#61; new CommonCounter();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 11 reads as: Thread threadOne &#61; new Thread(new CounterIncrementor(commonCounter , NUM_ITERATIONS));. Line 12 reads as: Thread threadTwo &#61; new Thread(new CounterIncrementor(commonCounter , NUM_ITERATIONS));.</em> [Video description ends]</p>
<p>And this is one which will be shared across two threads. And then its the thread definition itself. Each thread will run an instance of CounterIncrementor, which in turn is initialised with the shared CommonCounter and a NUM_ITERATIONS value of 1 million. The goal is to run these threads concurrently and then check out what the final values of the two variables in the CommonCounter are. But we print out their initial values to the Console first, and then start off the two threads. <br /><br />[Video description begins] <em>Line 14 reads as: System.out.println(&#34;Start value of firstNum: &#34;&#43; commonCounter.getFirstNum());. Line 15 reads as: System.out.println(&#34;Start value of secondNum: &#34;&#43; commonCounter.getSecondNum());.</em> [Video description ends] <br /><br />[Video description begins] <em>The following are the lines of code inside the try block. Line 18 reads as: threadOne.start();. Line 19 reads as: threadTwo.start();.</em> [Video description ends]</p>
<p><br />[Video description begins] <em>Line 21 reads as: Thread.sleep(5000);.</em> [Video description ends] <br /><br />We will then put the main thread to sleep for five seconds, which is enough time for both threadOne and threadTwo to finish their 1 million iterations. And then at the very end, we print out the final values of the firstNum and secondNum variables in the commonCounter. <br /><br />[Video description begins] <em>Line 27 reads as: System.out.println(&#34;End value of firstNum: &#34;&#43; commonCounter.getFirstNum());. Line 28 reads as: System.out.println(&#34;End value of secondNum: &#34;&#43; commonCounter.getSecondNum());.</em> [Video description ends]</p>
<p>If the increment operations were thread safe, we should expect that both of them will have values of 2 million. However, the expectation is that there will be a race condition. So let&#39;s see if that is the case by saving things down and then running this program. And in the first run well, the initial values, sure enough, are 0 and the final values are a shade below 2 million. So there have definitely been many instances, where each thread has read a stale value of firstNum and secondNum. <br /><br />And we have seen previously that this race condition can be prevented, by either using a synchronised function or even a synchronised block. And a lock is also a viable solution. With the way things are, if you were to rerun the program, we will always get a value less than 2 million. To prevent a race condition on the firstNum variable, let&#39;s head back to the commonCounter and then wrap its increment here around a synchronized block.<br /><br />[Video description begins] <em>He removes the line of code in line 10 and adds few new lines of code. Line 10 reads as: synchronized(this) {. Line 11 reads as: firstNum&#43;&#43;;. Line 12 reads as: }. Line 13 reads as: secondNum&#43;&#43;;.</em> [Video description ends]</p>
<p>This synchronization is achieved on the entire object. So heading back to the Synchronization.java class, let&#39;s see what happens if you were to rerun the program. Sure enough, the output is 2 million for firstNum, but a little less than 2 million for the secondNum.</p>
<p>And rerunning the program gives us a somewhat similar output. So is it possible for us to achieve a similar result, but without the overhead of a synchronized block? Well, the answer is yes. And to see how this can be done using an AutomicInteger, we head back to the CommonCounter. And in its current form, with the synchronized block, each thread execution, in effect, assumes the worst from the other concurrent threads, that they may perform an update, which is invalid. <br /><br />As a result, when it acquires a lock in order to perform this update other threads wanting to perform a similar update will need to suspend themselves and then restart once a lock has been released. This of course, adds a lot of overhead to the thread executions and can slow things down. But now we will introduce an AtomicInteger into the mix.<br /><br />[Video description begins] <em>He adds a line of code in line 3, that reads as: import java.util.concurrent.atomic.AtomicInteger;.</em> [Video description ends]<br /><br />[Video description begins] <em>He removes multiple lines of code in &#34;CommonCounter.java&#34; file and adds multiple new lines of code. Line 7 reads as: private AtomicInteger firstNum &#61; new AtomicInteger(0);.</em> [Video description ends]<br /><br />Specifically, we will convert the firstNum variable to be an AtomicInteger rather than a normal int. So we initialize this with a value of 0, which we pass to the AtomicInteger constructor. And in the incrementCounter function to perform the increment, we invoke the incrementAndGet() function. <br /><br />[Video description begins] <em>Line 10 reads as: public void incrementCounter() {. Line 12 reads as: firstNum.incrementAndGet();. Line 13 reads as: secondNum&#43;&#43;;.</em> [Video description ends] <br /><br />This is one which, in fact, performs two operations in an atomic manner, where it increments the value of firstNum and then returns the updated value. Any thread which invokes this incrementAndGet is guaranteed to read its own update. Similar to incrementAndGet, there are a number of other functions available for AtomicIntegers. This includes one like GetAndAdd, GetAndDecrement, and so on. Furthermore, you will observe that in the getter which we have for firstNum, we invoke the Get() function of the AtomicInteger.<br /><br />[Video description begins] <em>Line 16 reads as: public int getFirstNum() {. Line 17 reads as: return firstNum.get();. Line 18 reads as: }.</em> [Video description ends] <br /><br />All right, so let&#39;s save down this change. And it&#39;s time now for us to head to the Snchronization.java class and then rerun this program to see if we get an output similar to what we saw last time where the increments which are applied to firstNum are thread safe and we get a final value of 2 million.</p>
<p>But end up with inconsistent values for the secondNum. Well, on the first run, this does seem to be the case. I&#39;m just going to re-execute this code, however. And in the second run as well, all the updates to firstNum have taken place in a thread safe manner, but not so with the secondNum. Well, for that, let&#39;s go ahead and make one more change in the commonCounter.java source. I&#39;m now going to replace the code so that it&#39;s not just firstNum which is an AtomicInteger, but secondNum as well. <br /><br />[Video description begins] <em>Line 8 reads as: private AtomicInteger secondNum &#61; new AtomicInteger(0);.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 13 now reads as: secondNum.incrementAndGet();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 20 reads as: public int getSecondNum() {. Line 21 reads as: return secondNum.get();. Line 22 reads as: }.</em> [Video description ends] <br /><br />The incrementCounter() function now includes a call to incrementAndGet() for secondNum. And then the getter, we call the Get() function. And heading back to Synchronization.java and re-running the code, this time both of the variables have a final value of 2 million.</p></div>
</div>
<div>
<h2 id="25b9d5eb-f403-48f9-9db8-46d6a52fdb98">
Synchronized Collections
</h2>
<div>[Video description begins] <em>Topic title: Synchronized Collections. Your host for this session is Kishan Iyer.</em> [Video description ends]
<p>Throughout this learning path, we have come across several Java objects which can be used to implement concurrent programming in a thread-safe manner. These have include locks in order to enable mutual exclusion, and also semaphores to regulate access to critical resources. And then we have also seen Atomic variables. In many instances though, what we really need are concurrent data structures, including array lists, queues, and so on. Over the next few videos, we will take a look at a handful of commonly used data structures in Java and also that thread-safe variants. <br /><br />[Video description begins] <em>An Eclipse IDE interface displays.</em> [Video description ends]</p>
<p>To start though, we can create a new class in the com.skillsoft.concurrency package. Let&#39;s call this one ConcurrentTask. And as implied by the Name, this will be a task which can be executed in separate threads which will run concurrently. So to start off, let&#39;s import a rather common data structure used in Java, which is the ArrayList. <br /><br />[Video description begins] <em>Line 3 reads as: import java.util.ArrayList;.</em> [Video description ends]</p>
<p>And note that this is not a thread safe data structure as we will soon see. Moving along to the ConcurrentTask class definition. We&#39;ll make sure it implements the Runnable interface. [Video description begins] <em>Line 5 reads as: public class ConcurrentTask implements Runnable {.</em> [Video description ends] And then over to the code. First, we define a constant variable called NUM_ITERATIONS. <br /><br />[Video description begins] <em>Line 7 reads as: private static final int NUM_ITERATIONS &#61; 10000;.</em> [Video description ends]</p>
<p>Let&#39;s initialize this with a value of 10000. And then we define a commonResource which is of type ArrayList. <br /><br />[Video description begins] <em>Line 9 reads as: public ArrayList&lt;String&gt; commonResource;.</em> [Video description ends] <br /><br />So the goal for us is to have a number of instances of the ConcurrentTask, updating the same ArrayList. And to enable that, we define the construct of a ConcurrentTask, where this ArrayList is passed along. <br /><br />[Video description begins] <em>Line 11 reads as: public ConcurrentTask (ArrayList&lt;String&gt; commonResource) {. Line 12 reads as: this.commonResource &#61; commonResource;. Line 13 reads as: }.</em> [Video description ends]<br /><br />And then over to the run function. <br /><br />[Video description begins] <em>Line 16 reads as: public void run().</em> [Video description ends]<br /><br />[Video description begins] <em>Line 18 reads as: String threadName &#61; Thread.currentThread().getName();.</em> [Video description ends] <br /><br />This is now similar to what we have performed a number of times throughout this learning path where we accessed the thread name and then in a for loop we perform a number of iterations which updates the commonResource. <br /><br />[Video description begins] <em>Line 21 reads as: for(int i &#61; 0; i&lt; NUM_ITERATIONS; i&#43;&#43;) {.</em> [Video description ends]<br /><br />So what exactly do we do in the update?<br /><br />[Video description begins] <em>Line 22 reads as: commonResource.add(threadName &#43; &#34;-data-&#34; &#43; i);.</em> [Video description ends] <br /><br />Well, in each iteration, one string gets added over to the ArrayList. So by invoking commonResource.add, we put in the name of the thread, along with the string data, and then the iteration number. So that we have some idea of which string has written to the ArrayList. And once all the iterations are complete, we just print out to the Console that the thread has finished its execution. <br /><br />[Video description begins] <em>Line 29 reads as: System.out.println(threadName &#43; &#34; has finished execution&#34;);.</em> [Video description ends]</p>
<p>Heading over then to the main function. We begin of course by defining an ArrayList as a commonResource to be passed along to multiple-threads. <br /><br />[Video description begins] <em>Line 34 reads as: ArrayList&lt;String&gt; commonRes &#61; new ArrayList&lt;String&gt;(); </em>[Video description ends]<br /><br />And then we set up the threads themselves.<br /><br />[Video description begins] <em>Line 36 reads as: Thread firstThread &#61; new Thread(new ConcurrentTask(commonRes), &#34;firstThread&#34;);. Line 37 reads as: Thread secondThread &#61; new Thread(new ConcurrentTask(commonRes), &#34;secondThread&#34;);.</em> [Video description ends] <br /><br />Each of them works on an instance of ConcurrentTask. And along with the commonResource array, we specify the names of the threads as well. And then of course, it&#39;s time to run these threads in a concurrent manner.<br /><br />[Video description begins] <em>Line 39 reads as: firstThread.start();. Line 40 reads as: secondThread.start();.</em> [Video description ends] <br /><br />So we invoke the start function, one after the other for each of the threads. And then we make sure that the main thread waits for each of them to execute by calling the join function. <br /><br />[Video description begins] <em>Line 42 reads as: firstThread.join();. Line 43 reads as: secondThread.join();.</em> [Video description ends] <br /><br />And then at the very end, let&#39;s print out the size of the commonResource array. <br /><br />[Video description begins] <em>Line 45 reads as: System.out.println(&#34; #elements in commonRes:&#34; &#43; commonRes.size());.</em> [Video description ends] <br /><br />We should expect that given the value of num iterations is 10000 at the moment. The number of elements which are added to this array will be 20000. So what happens when we save things down and then run this program?</p>
<p>Well, both of the threads do run through to completion. And perform the Add operation on the commonResource array a total of 10,000 times each. However, the total number of elements in the array is a shade over 19,000. Clearly, those operations were not synchronized, which is why a race condition was the result on many occasions.</p>
<p>Let&#39;s see what happens if you were to rerun the program. I&#39;m sure enough, the value is not 20,000. And this of course is because the ArrayList data structure is not thread safe. Not having to check for concurrent threads accessing the ArrayList makes the addition of elements to this data structure very efficient. However, this only produces the correct results in a single threaded environment. And there is no guarantee that updates to an ArrayList will be performed correctly in a multi-threaded setting. And not like this situation where we get a different number of Adds, which are performed on the array in each run.</p>
<p>So what is the thread safe version of the ArrayList which we can use? Well, we do in fact have a number of different options. Let&#39;s start exploring them one by one. First from the java.util package we import both the Collection, in singular, and Collections, in plural, classes.<br /><br />[Video description begins] <em>Line 4 reads as: import java.util.Collection;. Line 5 reads as: import java.util.Collections;.</em> [Video description ends]</p>
<p>These will allow us to create a synchronized variant of the ArrayList but it will be in the form of a generic collection. To see how this works, well, let&#39;s head into the class definition and then replace this section of code with this new version. <br /><br />[Video description begins] <em>He removes the lines of code from line 11 to line 15 and adds various new lines of code.</em> [Video description ends] <br /><br />So in here, the common resource is a generic Collection.<br /><br />[Video description begins] <em>Line 11 reads as: public Collection&lt;String&gt; commonResource;.</em> [Video description ends]</p>
<p>And we also modify the constructor to accept such a data structure. <br /><br />[Video description begins] <em>Line 13 reads as: public ConcurrentTask (Collection&lt;String&gt; commonResource) {. Line 14 reads as: this.commonResource &#61; commonResource;. Line 15 reads as: }.</em> [Video description ends] <br /><br />This is in fact going to be a synchronize collection. And to set that up, we head over to the main function and then replace this declaration of an ArrayList. With this declaration of a collection of strings. <br /><br />[Video description begins] <em>He removes the previous line of code from line 36 and adds a new line of code. Line 36 reads as: Collection&lt;String&gt; commonRes &#61;. Line 37 reads as: Collections.synchronizedCollection(new ArrayList&lt;String&gt;());.</em> [Video description ends]<br /><br />This is not just any collection, however, but in fact, it is a synchronized collection which is based of an ArrayList. So right at the heart of it, we do in fact have an ArrayList data structure. However, by wrapping things around in the form of a synchronize collection, The commonRes variable is now a thread-safe version of the ArrayList. The Collections.synchronizedCollection function allow us to pass along any form of collection, and then it returns a synchronized version of it which is wrapped in a Collection object.</p>
<p>Which means that we can perform the generic collection operations on it. These include the invocations of the add, remove, and size functions. However, ArrayList specific functions such as lastIndexOf won&#39;t be applicable here. However, this is good enough for our demo. So let&#39;s save things down and then run the program once again. And from the output, it looks like there was no race condition encountered on this run. But of course, we will need to ensure that this was not a fluke. I&#39;m going to run the program once again and the size of the ArrayList shows up now as 20000.</p>
<p>All right, so have now successfully implemented a thread safe variant of the ArrayList. However, the commonRes variable now is no longer a list, but is in fact a more generic collection, which does not include list specific operations. In the next video, we will take a look at how we can get not just a generic synchronize collection, but the slightly more specialized synchronizedList.</p></div>
</div>
<div>
<h2 id="c7a03cc1-6451-49fe-8477-edd8b7357f73">
Thread-safe Lists
</h2>
<div>[Video description begins] <em>Topic title: Thread-safe Lists. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />[Video description begins] <em>The host continues with the lines of code from the previous video.</em> [Video description ends]
<p>In the previous video, we saw that an ArrayList is not a thread-safe data structure. But we then covered how we can wrap it up inside a synchronize collection object in order to make it thread-safe. A synchronize collection, however, only offers the standard operations available to all collections, but not list specific operations, such as the ability to retrieve elements using an index. So to get a synchronized variation of an ArrayList which includes all the list like operations, well we can create a synchronizedList. First though, let&#39;s head over to the import statements, and then add a new one. <br /><br />[Video description begins] <em>Line 6 reads as: import java.util.List;.</em> [Video description ends]</p>
<p>Specifically, we will now import a list and the commonResource within our class is no longer going to be a generic collection, but a more specialized list type. <br /><br />[Video description begins] <em>He removes the lines of code from line 12 to line 16. He adds a new line of code in line 12, that reads as: public List&lt;String&gt; commonResource;.</em> [Video description ends] <br /><br />The constructor will also need to be modified to reflect this.<br /><br />[Video description begins] <em>Line 14 reads as: public ConcurrentTask (List&lt;String&gt; commonResource) {. Line 15 reads as: this.commonResource &#61; commonResource;. Line 16 reads as: }.</em> [Video description ends] <br /><br />And then we head over to the main function and we&#39;ll now change the type for the commonRes variable. This now becomes a List of Strings and, in fact, it&#39;s a synchronizedList of strings. <br /><br />[Video description begins] <em>Line 36 reads as: List&lt;String&gt; commonRes &#61;. Line 37 reads as: Collections.synchronizedList(new ArrayList&lt;String&gt;());.</em> [Video description ends]<br /><br />Again, the data structure backing it up is an ArrayList.Â I&#39;m just going to save things down to remove the errors which show up and with that, we have created one more type of synchronized data structure out of an ArrayList. We won&#39;t get into the details of the synchronizedList, but we&#39;ll just confirm that the add operations on it are executed in a thread-safe manner. Before proceeding though, I&#39;m just going to eliminate the warning which shows up here. And this is due to an unused import statement. Specifically, we no longer make use of the Collection class. So once we get rid of that, well, we can just save things down and then run this program.</p>
<p>And, as expected, the number of elements within this array, specifically within the synchronizedList, is 20000. Just to make sure that this was no fluke, I&#39;ll just rerun the program. And yes, the number of elements is 20000 once again, so this does confirm the fact that a synchronizedList is, in fact, a thread-safe data structure. That said though, in many cases, it may not be the optimal thread-safe data structure backed by a list. For example, when a write needs to be performed to a synchronizedList, the entire list is locked. Even if just one element needs to be updated in a list containing tens of thousands of items.</p>
<p>If the number of writes on your ArrayList are a lot less frequent than the number of reads, then this can lead to performance issues and a better data structure in such a case is a CopyOnWriteArrayList. To see how this works, well, let&#39;s head up to the import statements and then import this from the Concurrent package.<br /><br />[Video description begins] <em>Line 6 reads as: import java.util.concurrent.CopyOnWriteArrayList;.</em> [Video description ends] <br /><br />Furthermore, we modify the type of the commonResource within the class and also the constructor. <br /><br />[Video description begins] <em>He removes the lines of code from line 12 to line 16 and adds new lines of code from line 12 to line 16. Line 12 reads as: public CopyOnWriteArrayList&lt;String&gt; commonResource;. Line 14 reads as: public ConcurrentTask (CopyOnWriteArrayList&lt;String&gt; commonResource) {. Line 15 reads as: this.commonResource &#61; commonResource;. Line 16 reads as: }.</em> [Video description ends]<br /><br />And then, of course, we head over to the main function, and then define the commonRes variable to be a CopyOnWriteArrayList with string elements. <br /><br />[Video description begins] <em>He removes lines of code from line 37 to line 38 and adds a new line of code in line 37, that reads as: CopyOnWriteArrayList&lt;String&gt; commonRes &#61; new CopyOnWriteArrayList&lt;String&gt;();.</em> [Video description ends] <br /><br />As implied by the name, in a CopyOnWriteArrayList, when a write operation is performed, it in fact is done on a copy of the ArrayList, while the original version is still available for other threads to read. This does mean that the read operations may not be able to view the latest updates. And the write operations themselves can prove to be rather costly, since they do need to create a copy of the entire ArrayList.</p>
<p>However, a CopyOnWriteArrayList can be iterated over while a write is being performed, and we will explore that a little later. For now, though, let&#39;s remove the warning from the code by heading up and then removing these unused import statements, and then we can save things down and then run this program. <br /><br />[Video description begins] <em>He removes the lines of code from line 3 to line 5.</em> [Video description ends] <br /><br />The output confirms that the CopyOnWriteArrayList is also a thread-safe structure. I&#39;m just going to rerun the program now. And on the second run as well, the number of elements is 20000. So now that we&#39;ve confirmed that synchronized lists as well as CopyOnWriteArrayLists are indeed thread-safe. In the next video, we&#39;ll turn our attention towards the differences between these two data structures. Where we perform an iteration over the data structure in one thread while a write is being performed on the same data structure in another.</p></div>
</div>
<div>
<h2 id="3a830d12-c7eb-4343-9141-e0350cf57d35">
Writing while Iterating over Lists
</h2>
<div>[Video description begins] <em>Topic title: Writing while Iterating over Lists. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />[Video description begins] <em>The host continues with the lines of code from the previous video.</em> [Video description ends]
<p>In our exploration of the thread-safetiness of ArrayList and its Concurrent variance, we have performed a very specific tasks. Namely, we have run two Concurrent threads which both add elements to the data structure. In a more realistic setting though, it is likely that you&#39;ll have some threads which write to the data structure.</p>
<p>While others will concurrently try to read from it. Let&#39;s see what happens when we use the different data structures we have explored so far in such a scenario. To begin though, we will explore the use of an ArrayList. So for that, I&#39;m just going to clear out the entire contents of the ConcurrentTask class.</p>
<p>And then before we add any code into the class. We import an ArrayList and also an Iterator which we will use to iterate over the elements of the ArrayList. <br /><br />[Video description begins] <em>Line 3 reads as: import java.util.ArrayList;. Line 4 reads as: import java.util.Iterator;.</em> [Video description ends]<br /><br />And then within the class itself, well, the commonResource member is now once again an ArrayList.<br /><br />[Video description begins] <em>Line 8 reads as: public ArrayList&lt;String&gt; commonResource;.</em> [Video description ends]<br /><br />And we also modify the constructor to reflect it.<br /><br />[Video description begins] <em>Line 10 reads as: public ConcurrentTask (ArrayList&lt;String&gt; commonResource) {. Line 11 reads as: this.commonResource &#61; commonResource;. Line 12 reads as: }.</em> [Video description ends] <br /><br />And then we move along to the run function.<br /><br />[Video description begins] <em>He highlights the lines of code from line 14 to line 30.</em> [Video description ends]</p>
<p>In this case, we only have a total of 20 iterations. <br /><br />[Video description begins] <em>Line 20 reads as: for (int i&#61;0;i&lt;20;i&#43;&#43;) {.</em> [Video description ends] <br /><br />Since we don&#39;t really need too many to demonstrate what happens when one thread writes to the ArrayList, while another iterates over it. In each iteration, we put the Thread to sleep for 100 milliseconds or 0.1 seconds and then add a string element to the ArrayList. <br /><br />[Video description begins] <em>Line 21 reads as: Thread.sleep(100);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 22 reads as: commonResource.add(threadName &#43; &#34;-data-&#34; &#43; i);.</em> [Video description ends] <br /><br />And finally, we print out the message that the thread has finished its execution. <br /><br />[Video description begins] <em>Line 29 reads as: System.out.println(threadName &#43; &#34; has finished execution&#34;);.</em> [Video description ends] <br /><br />Moving along then to the main function.</p>
<p>Once again, we declared a commonRes variable which is an ArrayList. <br /><br />[Video description begins] <em>Line 34 reads as: ArrayList&lt;String&gt; commonRes &#61; new ArrayList&lt;String&gt;();.</em> [Video description ends]<br /><br />And pass these along to two instances of ConcurrentTask, which run in separate threads. Which you go on to start, and then we put the main Thread to sleep for one second. <br /><br />[Video description begins] <em>Line 36 reads as: Thread firstThread &#61; new Thread(new ConcurrentTask(commonRes), &#34;firstThread&#34;);. Line 37 reads as: Thread secondThread &#61; new Thread(new ConcurrentTask(commonRes), &#34;secondThread&#34;);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 39 reads as: firstThread.start();. Line 40 reads as: secondThread.start();.</em> [Video description ends] <br /><br />Â [Video description begins] <em>Line 42 reads as: Thread.sleep(1000);.</em> [Video description ends] <br /><br />This gives enough time for the two Concurrent threads to add some elements into the ArrayList. And then we create an Iterator to go over the ArrayList elements. <br /><br />[Video description begins] <em>Line 44 reads as: Iterator&lt;String&gt; itr &#61; commonRes.iterator();.</em> [Video description ends]</p>
<p>So once this Iterator has been generated, we use a while loop in order to go over each element.<br /><br />[Video description begins] <em>He highlights the lines of code from line 46 to line 51.</em> [Video description ends] <br /><br />So we access the element by invoking the Iterator&#39;s next function, and then we print out that element over to the Console. <br /><br />[Video description begins] <em>Line 46 reads as: while (itr.hasNext()) {. Line 47 reads as: String str &#61; (String) itr.next();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 49 reads as: System.out.println(&#34;str : &#34; &#43; str);.</em> [Video description ends] <br /><br />And then the main thread goes to sleep for 100 milliseconds.<br /><br />[Video description begins] <em>Line 50 reads as: Thread.sleep(100);.</em> [Video description ends] <br /><br />So, with this code, we will have three Concurrent threads operating on the same ArrayList. There are two of them which write data to the ArrayList and then the main thread will read from it through the Iterator. So let&#39;s see what happens if you were to save things down and then run the program. And within moments, we see that a ConcurrentModificationException gets thrown. This is, in fact, a common occurrence when we have threads writing to a data structure and other threads reading from it. This is something which is not permitted on ArrayList data structures which we already know are not thread-safe in any case. We do see, however, that the iterator was able to read one element from the ArrayList before it raise the exception. And beyond that, both the threads which write to the data structure were able to complete their executions.</p>
<p>So clearly, the ArrayList will not allow this to happen. But what about a SynchronizedList? Well, to substitute our ArrayList with its synchronized version, we first go up, and then import the java.util.List and the Collections class as well. And then we modify the member as well as the constructor for the class. So that it&#39;s now a List, which is the commonResource, rather than an ArrayList. <br /><br />[Video description begins] <em>He edits the lines of code from line 10 to line 14.</em> [Video description ends] Â <br /><br />[Video description begins] <em>Line 10 reads as: public List&lt;String&gt; commonResource;.</em> [Video description ends]</p>
<p>And then moving along to the main function, again, the declaration changes. So that a synchronizedList is generated by invoking Collections.synchronizedList. And this of course is backed up by an ArrayList.<br /><br />[Video description begins] <em>Line 36 reads as: List&lt;String&gt; commonRes &#61;. Line 37 reads as: Collections.synchronizedList(new ArrayList&lt;String&gt;());.</em> [Video description ends] <br /><br />So given that a synchronizedList is thread-safe, does it allow two threads to perform writes while another performs a read operation from it? Well, to find out, we just need to save things down and then run the code.</p>
<p>And in fact we end up with the same type of ConcurrentModificationException, which we solve with the use of the ArrayList. So while a synchronizedList is thread-safe, its Iterator happens to be a fail-fast Iterator. Which means that it would rather fail quickly and cleanly, rather than read stale values from an ArrayList. To confirm this, let&#39;s rerun the program, and in fact, is the same ConcurrentModificationException once again. Now it is possible that for your use case, that is precisely the behavior which you require. However, in many cases, you may be okay with reading slightly stale values as long as there are no failures within your code execution.</p>
<p>In which case, what you really require is an Iterator which is fail-safe, rather than fail-fast. And this is precisely what we get with the CopyOnWriteArrayList. It&#39;s now time for us to see that data structure in action. So heading up to the import statements, I will import once again the CopyOnWriteArrayList.<br /><br />[Video description begins] <em>Line 7 reads as: import java.util.concurrent.CopyOnWriteArrayList;.</em> [Video description ends] <br /><br />And you should know the drill by now, where we replace the common resource declaration as well as the constructor.</p>
<p>So that they now reflect the new data structure which we plan to use.<br /><br />[Video description begins] <em>He changes the lines of code from line 11 to line 15. Line 11 reads as: public CopyOnWriteArrayList&lt;String&gt; commonResource;. Line 12 is left blank. Line 13 reads as: public ConcurrentTask (CopyOnWriteArrayList&lt;String&gt; commonResource) {. Line 14 reads as: this.commonResource &#61; commonResource;. Line 15 reads as: }.</em> [Video description ends] <br /><br />And then of course within the main function, we set the commonRes variable to be a CopyOnWriteArrayList. <br /><br />[Video description begins] <em>He changes the lines of code in line 37 and line 38 and adds a new line of code. Line 37 now reads as: CopyOnWriteArrayList&lt;String&gt; commonRes &#61; new CopyOnWriteArrayList&lt;String&gt;();.</em> [Video description ends] <br /><br />I&#39;m going to head back up to the import statements. And then get rid of those which we no longer require in order to eliminate the warnings from this code.<br /><br />[Video description begins] <em>He removes the following three import statements, that reads as: import java.util.List;. import java.util.Collections;. import java.util.ArrayList;.</em> [Video description ends]<br /><br />All right, it&#39;s now time to see whether two threads can write to the CopyOnWriteArrayList, while another thread iterates over its elements.</p>
<p>So we save things down and then run. And from the output, we observe that there is no ConcurrentModificationException this time. And there is of course a reason for this. In the previous data structures. The Iterator detected that the data structure it was going over had been modified from the time the Iterator was initialized. And rather than potentially read an incorrect value, it decided to throw an exception and then fail immediately.</p>
<p>For the CopyOnWriteArrayList, though, I&#39;d like to draw your attention to line number 44 in my code, where we initialize the Iterator for it. And given this is a fail-safe Iterator, the values it operates on are what is available in the ArrayList at that time this Iterator is created. So if the ArrayList gets modified during the iteration process, well, this Iterator will simply not pick it up. In fact, if you scroll along in the output. You&#39;ll observe that both of the threads which write to the CopyOnWriteArrayList have finished their executions. Which means that each of them have written 20 elements into it. However, only has access to a total of nine elements written by each thread. This is because the Iterator was initialized about one second into the execution of those two writing threads.</p>
<p>At which point, you&#39;re just about halfway through their writes. And this brings into focus the name CopyOnWriteArrayList. Each of the writing threads happened to write to a separate copy of the ArrayList which was not accessible to this Iterator. So the CopyOnWriteArrayList is okay if an Iterator reads stale values, as long as there is no failure in the execution. All right, let&#39;s see an instance where the CopyOnWriteArrayList can throw an exception. So while the Iterator is going over each of the elements, what happens if you were to remove an element from the list?<br /><br />[Video description begins] <em>He adds a new line of code in line 52 that reads as: itr.remove();.</em> [Video description ends]</p>
<p>Well, let&#39;s save things down and then run this program to find out. And there is in fact an exception which is thrown, specifically an UnsupportedOperationException. So the Iterator for a CopyOnWriteArrayList does not permit any modification operation. So if we use it to remove, set or add data, it will be flagged as an unsupported operation and such an exception will be thrown. So, we&#39;re now aware of a clear distinction between a synchronizedList and a CopyOnWriteArrayList.</p></div>
</div>
<div>
<h2 id="fedf5a18-94bf-4956-9a49-84d6b110ee34">
The ConcurrentHashMap
</h2>
<div>[Video description begins] <em>Topic title: The ConcurrentHashMap. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />[Video description begins] <em>The host continues with the lines of code from the previous video.</em> [Video description ends]
<p>We have worked with CopyOnWriteArrayList so far, which are not only thread-safe. But it is also possible for us to iterate over them while writes are being performed. And a map data structure, which does provide similar form of access is the ConcurrentHashMap. Regular HashMaps in Java are not thread-safe. And a HashTable, while it does provide thread-safe operations thus suffer from degraded performance, since even a get operation on it does require a lock.</p>
<p>This is not, however, the case with concurrent HashMaps, which works on a bucket level. And locks buckets within the HashMap when performing an update, rather than the entire data structure. To see how these work and contrast them with regular HashMaps. Let&#39;s first select all the code within the ConcurrentTask class, and then get rid of them. Since we no longer need the CopyOnWriteArrayList, we can get rid of that input statement. And instead, we will first make use of a HashMap. <br /><br />[Video description begins] <em>Line 4 reads as: import java.util.HashMap;.</em> [Video description ends]</p>
<p>And we&#39;ll see what happens if you were to update a HashMap while iterating over its elements. Moving along then to the code. Well, within the ConcurrentTasks class, we now have a commonResource member, which is a HashMap containing Strings for both keys and values. <br /><br />[Video description begins] <em>Line 8 reads as: public HashMap&lt;String, String&gt; commonResource;.</em> [Video description ends] <br /><br />This HashMap will also be initialized in the constructor.<br /><br />[Video description begins] <em>Line 10 reads as: public ConcurrentTask (HashMap&lt;String, String&gt; commonResource) {. Line 11 reads as: this.commonResource &#61; commonResource;. Line 12 reads as: }.</em> [Video description ends]</p>
<p>And then within the run function, where we have the same for loop as before. Where for 20 iterations, we first put the Thread to sleep for 0.1 seconds.<br /><br />[Video description begins] <em>Line 21 reads as: Thread.sleep(100);.</em> [Video description ends] <br /><br />And then we put a key and value pair into the HashMap. <br /><br />[Video description begins] <em>Line 22 reads as: commonResource.put(threadName &#43; &#34;-key-&#34; &#43; i,. Line 23 reads as: threadName &#43; &#34;-val-&#34; &#43; i);.</em> [Video description ends] <br /><br />For both the key and the value we include the threadName and also the substrings key and val. And in each case, we include a number as well.</p>
<p>We will have two Concurrent threads which write to the HashMap, and we&#39;ll iterate over the HashMap&#39;s elements from the main thread. And speaking of the main thread, let&#39;s now write the code which will run within that. <br /><br />[Video description begins] <em>Line 35 reads as: HashMap&lt;String, String&gt; commonRes &#61;. Line 36 reads as: new HashMap&lt;String, String&gt;();.</em> [Video description ends]</p>
<p>So the commonRes variable is now a HashMap. And we pass this along two instances of ConcurrentTasks, which are set to run in separate threads. <br /><br />[Video description begins] <em>Line 38 reads as: Thread firstThread &#61; new Thread(new ConcurrentTask(commonRes), &#34;firstThread&#34;);. Line 39 reads as: Thread secondThread &#61; new Thread(new ConcurrentTask(commonRes), &#34;secondThread&#34;);.</em> [Video description ends] <br /><br />Well, after starting up those threads, just as we did before. When working with ArrayLists, we put the main thread to sleep for one second. <br /><br />[Video description begins] <em>Line 41 reads as: firstThread.start();. Line 42 reads as: secondThread.start();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 44 reads as: Thread.sleep(1000);.</em> [Video description ends] <br /><br />By which point, the first thread and second thread, will have written about nine or 10 values each into the HashMap.</p>
<p>That is assuming of course, that they did not step on each other&#39;s toes. And then we initialize an Iterator to go over the keys of the HashMap.<br /><br />[Video description begins] <em>Line 46 reads as: Iterator&lt;String&gt; itr &#61; commonRes.keySet().iterator();.</em> [Video description ends] <br /><br />So we call commonRes.keySet().iterator() for this. And then using the while loop, we iterate over each of the keys. <br /><br />[Video description begins] <em>Line 48 reads as: while (itr.hasNext()) {. Line 49 reads as: String str &#61; (String) commonRes.get( itr.next());.</em> [Video description ends] <br /><br />And then use each key to access the corresponding value in the ConcurrentHashMap using the get function. This value is then printed out to the Console. <br /><br />[Video description begins] <em>Line 51 reads as: System.out.println(&#34;main : &#34; &#43; str);.</em> [Video description ends]</p>
<p>After this at the end of each iteration, we put the main thread to sleep for 100 milliseconds.<br /><br />[Video description begins] <em>Line 52 reads as: Thread.sleep(100);.</em> [Video description ends]<br /><br />Since a HashMap is not thread-safe, we should expect a ConcurrentModificationException when we run this. So let&#39;s save things down and do precisely that. And sure enough, we have that confirmation. The iterator of the HashMaps is fail-fast. The moment it realized that a write has been performed on the HashMap after the iterator was initialized, it has decided to throw this exception and fail.</p>
<p>So what&#39;ll happen if you were to replace a HashMap with a ConcurrentHashMap? Well, to test it out, we head back over to the import statements. And add a ConcurrentHashMap, which is part of the java.util.concurrent package.<br /><br />[Video description begins] <em>Line 5 reads as: import java.util.concurrent.ConcurrentHashMap;.</em> [Video description ends] <br /><br />And to get the concurrentTask instances to use this, we set the commonResource to be of type concurrentHashMap.<br /><br />[Video description begins] <em>He changes the lines of code from line 9 to line 13. Line 9 reads as: public ConcurrentHashMap&lt;String, String&gt; commonResource;.</em> [Video description ends] <br /><br />And just as with a regular HashMap, we do need to specify the types for the key and value which remain as String. And then of course, the constructor is also changed. <br /><br />[Video description begins] <em>Line 11 reads as: public ConcurrentTask (ConcurrentHashMap&lt;String, String&gt; commonResource) {. Line 12 reads as: this.commonResource &#61; commonResource;. Line 13 reads as: }.</em> [Video description ends]</p>
<p>And then we head over to the main function, and then change the type for the commonRes variable as well.<br /><br />[Video description begins] <em>Line 36 reads as: ConcurrentHashMap&lt;String, String&gt; commonRes &#61;. Line 37 reads as: new ConcurrentHashMap&lt;String, String&gt;();.</em> [Video description ends] <br /><br />So this time, the Iterator which is generated will be one which is fail-first rather than fail-safe. And it is possible for us to Iterate over the different keys, while writes are being performed concurrently. Sure enough to get rid of the warnings, I&#39;ll once again head back to the top, and clear out this import of the HashMap. And then it&#39;s time to save the ConcurrentTask and run. Sure enough, this time there is no ConcurrentModificationException.</p>
<p>And we get to see the different values, which the Iterator has been able to access. You&#39;ll see that in the middle of the iteration, both the first thread and the second threads have finished their executions. However, the iterator has gone on, and you will observe that it has been able to access values which were written after the iterator was initialized. For example, firstThread-val-19 is the last value which will have been written by the firstThread, and the iterator has been able to retrieve it.</p>
<p>The iterator for a concurrentHashMap is weakly consistent. This means that it may be able to pick up updates after it was initialized. However, this is not guaranteed by Java, so you should not count on it. However, it is clear that when we use a ConcurrentHashMap, it is possible for us to perform reads, including iterations when there are writes going on to the same data structure concurrently.</p></div>
</div>
<div>
<h2 id="76055191-3f2c-470b-a6f3-44dab566ca56">
Concurrent Collections Performance
</h2>
<div>[Video description begins] <em>Topic title: Concurrent Collections Performance. Your host for this session is Kishan Iyer.</em> [Video description ends] <br /><br />[Video description begins] <em>A blank Eclipse IDE interface displays.</em> [Video description ends]
<p>So far, we have examined the behaviors of various collections in Java, whether they&#39;re synchronized or not. We have also discussed their overall performances. But in this demo, we will compare the performance of write operations on a number of different data structures.</p>
<p>To start off, let&#39;s create a new class in the package we have been using so far. And we can call this one CollectionPerformance, and then we will make use of a number of different data structures. So we import all of them in here. First, we will check out ArrayLists and then also synchronize lists for <br /><br />[Video description begins] <em>Line 3 reads as: import java.util.ArrayList;.</em> [Video description ends] <br /><br />which we import the list and collections classes. <br /><br />[Video description begins] <em>Line 4 reads as: import java.util.List;. Line 5 reads as: import java.util.Collections;.</em> [Video description ends]</p>
<p>And then, we will also cover a thread-safe version of an ArrayList, which is a Vector. <br /><br />[Video description begins] <em>Line 6 reads as: import java.util.Vector;.</em> [Video description ends] <br /><br />But this does not provide the same flexibility as the copy on write array list which we have explored. <br /><br />[Video description begins] <em>Line 7 reads as: import java.util.concurrent.CopyOnWriteArrayList;.</em> [Video description ends] <br /><br />So, let&#39;s go ahead and test out the performance of write operations on the different data structures. But first, let&#39;s create instances of these data structures within the CollectionPerformance class.<br /><br />[Video description begins] <em>Line 9 reads as: public class CollectionPerformance {.</em> [Video description ends] <br /><br />So we have here an ArrayList called myList, and then a SynchronizedList called mySyncList. <br /><br />[Video description begins] <em>Line 11 reads as: private ArrayList&lt;String&gt; myList &#61; new ArrayList&lt;String&gt;();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 12 reads as: List&lt;String&gt; mySyncList &#61;. Line 13 reads as: Collections.synchronizedList(new ArrayList&lt;String&gt;());.</em> [Video description ends] <br /><br />Which at its heart is an ArrayList with a synchronization wrapper around it.</p>
<p>Then we have a Vector called myVector.<br /><br />[Video description begins] <em>Line 14 reads as: private Vector&lt;String&gt; myVector &#61;new Vector&lt;String&gt;();.</em> [Video description ends] <br /><br />And then finally, myCOWList is a copy on write ArrayList.<br /><br />[Video description begins] <em>Line 15 reads as: private CopyOnWriteArrayList&lt;String&gt;myCOWList &#61;. Line 16 reads as: new CopyOnWriteArrayList&lt;String&gt;();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 19 reads as: private static final int NUM_ITERATIONS &#61; 100000;.</em> [Video description ends] <br /><br />We will perform a total of 100000 writes, and this will be regulated by the variable NUM_ITERATIONS. Moving along then to the functions which we need. First, to test out the ArrayList, we have a testArrayList function. <br /><br />[Video description begins] <em>Line 21 reads as: public void testArrayList() {.</em> [Video description ends] <br /><br />Before we perform any write operations, we get the startTime by invoking System.currentTimeMillis(). <br /><br />[Video description begins] <em>Line 23 reads as: long startTime &#61; System.currentTimeMillis();.</em> [Video description ends]</p>
<p>And then using a for loop, we add 100000 elements into this ArrayList. <br /><br />[Video description begins] <em>Line 25 reads as: for (int i&#61;0;i&lt;NUM_ITERATIONS;i&#43;&#43;) {. Line 26 reads as: myList.add(&#34;data-&#34; &#43; i);. Line 27 reads as: }.</em> [Video description ends] <br /><br />Once all of that is done, we retrieve the time from the System once again and this is stored in the endTime variable.<br /><br />[Video description begins] <em>Line 29 reads as: long endTime &#61; System.currentTimeMillis();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 30 reads as: System.out.println(&#34; Total time ArrayList:&#34; &#43; (endTime-startTime) &#43; &#34;ms&#34;);.</em> [Video description ends] <br /><br />And the total time taken to add 100000 values into the ArrayList can be calculated as endTime minus startTime, which we publish over to the Console. Keep in mind though, that this elapsed time will be measured in milliseconds, which is why we include the ms unit at the end. Moving along then to the next function, in order to test out a SynchronizedList. <br /><br />[Video description begins] <em>Line 33 reads as: public void testSynchronizedList() {.</em> [Video description ends]</p>
<p>So once again we calculate the startTime.<br /><br />[Video description begins] <em>Line 35 reads as: long startTime &#61; System.currentTimeMillis();.</em> [Video description ends] <br /><br />And in the for loop, we add elements over to the SynchronizedList.<br /><br />[Video description begins] <em>Line 37 reads as: for (int i&#61;0;i&lt;NUM_ITERATIONS;i&#43;&#43;) {. Line 38 reads as: myList.add(&#34;data-&#34; &#43; i);. Line 39 reads as: }.</em> [Video description ends] <br /><br />And then we calculate the endTime and push out to the Console the total elapsed time.<br /><br />[Video description begins] <em>Line 41 reads as: long endTime &#61; System.currentTimeMillis();. Line 42 reads as: System.out.println(&#34; Total time synchronizedList:&#34; &#43; (endTime-startTime) &#43; &#34;ms&#34;);.</em> [Video description ends] <br /><br />Also, to do a like for like comparison, the data which is written to the SynchronizedList is exactly the same as what we write over to the ArrayList. Where we write data dash followed by the iteration number. And the next data structure to test out is the Vector.<br /><br />[Video description begins] <em>He highlights the lines of code from line 45 to line 55.</em> [Video description ends]</p>
<p>So a vector is in fact a thread safe structure, which is why a lock will need to be acquired when a write is performed. We&#39;ll now see what effect that can have on the overall performance of the Vector for writes. And then we move along to testing the copy on write ArrayList.<br /><br />[Video description begins] <em>He highlights the lines of code from line 57 to line 67.</em> [Video description ends]<br /><br />We have already discussed the fact that a write to such an ArrayList does in fact involve a fair amount of overhead. Since an entire copy of the ArrayList needs to be generated, and then eventually merged. So the expectation is that the 100,000 writes to this data structure will be longer than many of the others.</p>
<p>All right, so we have now defined the functions to test out each of the list data structures. And now within the main function, it&#39;s now time for us to invoke each of these functions.<br /><br />[Video description begins] <em>Line 71 reads as: CollectionPerformance cp &#61; new CollectionPerformance();. He highlights the line of code from line 73 to line 76. Line 73 reads as: testArrayList();. In a similar way, the other three functions are also called.</em> [Video description ends]<br /><br />So let&#39;s save things down and then run. And what we observe is that the additions to the ArrayList, the synchronizedList and the Vector take place rather quickly. But it does take a really long time with the copy on write ArrayList. When it&#39;s just write operations which need to be carried out, the difference in performance between an ArrayList and synchronizedList does not seem significant.</p>
<p>But just to confirm, let&#39;s run this program once again. And in fact the output is similar. The biggest takeaway here is that write operations to a copy on write ArrayList take much longer than on the other data structures, concurrent or otherwise. And in fact, the performance will keep slowing down the bigger the size of the underlying array. We can confirm this by one more execution of this program and our observations are now confirmed.</p>
<p>Keep in mind though, that what we are testing here are specifically write operations. And in fact, there is no concurrent access to any of these data structures within this test. As discussed previously, when we have some threads reading from or even iterating over the elements in a list, at the same time as other threads happen to be writing to it, a copy on write ArrayList may in fact deliver the better overall performance. Having covered the performance of add operations on list data structures, we move along now to comparing similar operations on map structures.</p>
<p>We will compare HashMaps, Hashtables, as well as ConcurrentHashMaps. So we import these into our code, and you will note that I&#39;ve cleared out the contents of the class since we will be pasting some new code. We initialize a HashMap, a Hashtable, as well as a ConcurrentHashMap. So these will have Strings as both keys and values. And the goal for us is to perform additions of 10000 key-value pairs into each of them.<br /><br />[Video description begins] <em>Line 15 reads as: private static final int NUM_ITERATIONS &#61; 10000;.</em> [Video description ends]</p>
<p>Starting with the HashMap, we once again calculate the startTime and endTime. And then between that in a for loop, we iterate for the given number of iterations and add a key and a value. <br /><br />[Video description begins] <em>HashMap is initialized in line 9. The code in line 9 reads as: private HashMap&lt;String, String&gt; myHashMap &#61; new HashMap&lt;String, String&gt;();.</em> [Video description ends] <br /><br />[Video description begins] <em>He highlights the code of testHashMap function from line 17 to line 27.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 21 reads as: for (int i&#61;0;i&lt;NUM_ITERATIONS;i&#43;&#43;) {.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 22 reads as: myHashMap.put(&#34;key-&#34; &#43; i, &#34;data-&#34; &#43; i);.</em> [Video description ends] <br /><br />We have covered the fact that a HashMap is not synchronized, so these operations should be relatively quick. Moving along then to the HashTable. <br /><br />[Video description begins] <em>He highlights the code of testHashTable function from line 29 to line 39.</em> [Video description ends] <br /><br />This is a synchronized data structure. When it comes to accessing a HashTable, a thread can lock the entire HashTable structure, even if it only needs to add a single element into it.</p>
<p>So the performance can be great if you have multiple-threads, reading from and writing to such a structure.<br /><br />[Video description begins] <em>Line 34 reads as: myHashTable.put(&#34;key-&#34; &#43; i, &#34;data-&#34; &#43; i);.</em> [Video description ends] <br /><br />In this case, however, we&#39;re only performing put operations and we move along then to ConcurrentHashMaps. <br /><br />[Video description begins] <em>The code of testConcurrentHashMap function displays from line 41 to line 51. Line 41 reads as: public void testConcurrentHashMap() {.</em> [Video description ends] <br /><br />When it comes to concurrent programming, this is in fact the preferred map data structure. And this is because it divides the entire map into a number of buckets. And it is these buckets which are locked when update operations are performed. This means that two threads could in fact concurrently write to a ConcurrentHashMap, as long as they write to different buckets.</p>
<p>On the other hand, single threaded put operations, like what we do here, may in fact prove to be rather slow.<br /><br />[Video description begins] <em>Line 46 reads as: myConcurrentHashMap.put(&#34;key-&#34; &#43; i, &#34;data-&#34; &#43; i);.</em> [Video description ends] <br /><br />Let&#39;s go ahead then to the main function, where we run each of the three functions to test the performance of the put operation on each of these structures. <br /><br />[Video description begins] <em>Line 57 reads as: cp.testHashMap();. Line 58 reads as: cp.testHashTable();. Line 59 reads as: cp.testConcurrentHashMap();.</em> [Video description ends] <br /><br />Â And what we observe is that in this case, there is not a significant difference between these operations. In fact, it is the non-ConcurrentHashMap, which is the slowest. But let&#39;s just rerun to see what we get, and we do see a similar result.</p>
<p>A big takeaway here is that copy on write ArrayList and ConcurrentHashMaps are the newer of the concurrent data structures which are offered in Java. But their performances on put operations do vary significantly, mainly due to how they perform the writes. A ConcurrentHashMap does not create an entire new copy of the data structure. Which is why its put operations are in fact comparable in performance to that for the HashMap and the HashTable.</p></div>
</div>
<div>
<h2 id="309c2b24-8bd2-4f21-99fb-b83b5f35c235">
Course Summary
</h2>
<div>[Video description begins] <em>Topic title: Course Summary</em> [Video description ends]
<p>This course explored the variety of options available in Java to solve concurrency related issues. Let&#39;s quickly recap what we implemented in the labs of this course. We began with the use of Semaphores to restrict access to a SharedResource to only a specific number of threads. We then looked at the use of a Volatile variables to ensure updates to shared data is visible to all concurrent threads. We then explored the use of Atomic variables to perform Atomic operations on data.</p>
<p>Finally, we covered a number of built-in data structures available in Java for concurrent programming. This includes the copy on write ArrayList, and the ConcurrentHashMap. Now that you&#39;ve covered all of the labs in this course, you have a breadth of knowledge on the concurrent objects and data structures, which you can use in various scenarios while building your multi-threaded Java app. You now have the skills required to move on to other advanced topics on concurrent programming in Java, which will enable you to scale up the level of concurrency in your app.</p>
<p>The next course in this path covers the Executor service in Java, and also the fork/Join framework, which greatly simplify the management of a large number of tasks.</p></div>
</div>
</body>
</html>
